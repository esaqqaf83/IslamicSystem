CREATE TABLE COLLATERAL_DOCUMENTS_NEW
(
  DOCUMENT_ID     NUMBER,
  COLLATERAL_ID   NUMBER                        NOT NULL,
  DOCUMENT_TYPE   VARCHAR2(50 BYTE)             NOT NULL,
  DOCUMENT_NAME   VARCHAR2(200 BYTE)            NOT NULL,
  DOCUMENT_PATH   VARCHAR2(500 BYTE)            NOT NULL,
  DOCUMENT_NOTES  VARCHAR2(1000 BYTE),
  STATUS          VARCHAR2(20 BYTE)             DEFAULT 'ACTIVE',
  CREATED_BY      NUMBER,
  CREATION_DATE   TIMESTAMP(6)                  DEFAULT SYSTIMESTAMP,
  UPDATED_BY      NUMBER,
  UPDATE_DATE     TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE COLLATERAL_DOCUMENTS_NEW IS 'جدول يخزن المستندات المتعلقة بالضمانات';


ALTER TABLE COLLATERAL_DOCUMENTS_NEW ADD (
  PRIMARY KEY
  (DOCUMENT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COLLATERAL_VALUATIONS
(
  VALUATION_ID    NUMBER,
  COLLATERAL_ID   NUMBER                        NOT NULL,
  OLD_VALUE       NUMBER,
  NEW_VALUE       NUMBER                        NOT NULL,
  VALUATION_DATE  DATE                          NOT NULL,
  VALUATION_BY    VARCHAR2(100 BYTE),
  NOTES           VARCHAR2(1000 BYTE),
  CREATED_BY      NUMBER,
  CREATION_DATE   TIMESTAMP(6)                  DEFAULT SYSTIMESTAMP,
  UPDATED_BY      NUMBER,
  UPDATE_DATE     TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COLLATERAL_VALUATIONS ADD (
  PRIMARY KEY
  (VALUATION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COMMITTEES
(
  COMMITTEE_ID    NUMBER,
  COMMITTEE_NAME  VARCHAR2(100 BYTE)            NOT NULL,
  COMMITTEE_TYPE  VARCHAR2(50 BYTE)             NOT NULL,
  DESCRIPTION     CLOB,
  APPROVAL_LIMIT  NUMBER,
  STATUS          VARCHAR2(20 BYTE)             DEFAULT 'ACTIVE',
  CREATION_DATE   DATE                          DEFAULT SYSDATE,
  CREATED_BY      NUMBER,
  UPDATE_DATE     DATE,
  UPDATED_BY      NUMBER
)
LOB (DESCRIPTION) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COMMITTEES ADD (
  PRIMARY KEY
  (COMMITTEE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COMMITTEES_ORG
(
  COMMITTEE_ID      NUMBER,
  COMMITTEE_NAME    VARCHAR2(100 BYTE)          NOT NULL,
  COMMITTEE_TYPE    VARCHAR2(50 BYTE)           NOT NULL,
  DESCRIPTION       VARCHAR2(500 BYTE),
  APPROVAL_LIMIT    NUMBER,
  ACTIVE            VARCHAR2(1 BYTE)            DEFAULT 'Y'                   NOT NULL,
  CREATED_BY        NUMBER                      NOT NULL,
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY   NUMBER,
  LAST_UPDATE_DATE  TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COMMITTEES_ORG ADD (
  CONSTRAINT CHK_COMMITTEE_ACTIVE
  CHECK (ACTIVE IN ('Y', 'N'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_COMMITTEE_TYPE
  CHECK (COMMITTEE_TYPE IN ('CREDIT', 'EXECUTIVE', 'RISK', 'SHARIAH', 'SPECIAL'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (COMMITTEE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COMMITTEE_MEETINGS
(
  MEETING_ID        NUMBER,
  COMMITTEE_ID      NUMBER                      NOT NULL,
  MEETING_DATE      TIMESTAMP(6)                NOT NULL,
  MEETING_LOCATION  VARCHAR2(200 BYTE),
  MEETING_STATUS    VARCHAR2(20 BYTE)           DEFAULT 'SCHEDULED'           NOT NULL,
  AGENDA            VARCHAR2(4000 BYTE),
  MINUTES           VARCHAR2(4000 BYTE),
  CREATED_BY        NUMBER                      NOT NULL,
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY   NUMBER,
  LAST_UPDATE_DATE  TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COMMITTEE_MEETINGS ADD (
  CONSTRAINT CHK_MEETING_STATUS
  CHECK (MEETING_STATUS IN ('SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'POSTPONED'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (MEETING_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COMMITTEE_MEMBERS
(
  MEMBER_ID        NUMBER,
  COMMITTEE_ID     NUMBER                       NOT NULL,
  USER_ID          NUMBER                       NOT NULL,
  MEMBER_POSITION  VARCHAR2(100 BYTE),
  IS_CHAIRMAN      NUMBER(1)                    DEFAULT 0,
  STATUS           VARCHAR2(20 BYTE)            DEFAULT 'ACTIVE',
  CREATION_DATE    DATE                         DEFAULT SYSDATE,
  CREATED_BY       NUMBER,
  UPDATE_DATE      DATE,
  UPDATED_BY       NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COMMITTEE_MEMBERS ADD (
  PRIMARY KEY
  (MEMBER_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COMMITTEE_MEMBERS_ORG
(
  COMMITTEE_ID       NUMBER,
  USER_ID            NUMBER,
  ROLE_IN_COMMITTEE  VARCHAR2(50 BYTE)          NOT NULL,
  JOIN_DATE          TIMESTAMP(6)               DEFAULT SYSTIMESTAMP          NOT NULL,
  END_DATE           TIMESTAMP(6),
  ADDED_BY           NUMBER                     NOT NULL
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COMMITTEE_MEMBERS_ORG ADD (
  CONSTRAINT CHK_ROLE_IN_COMMITTEE
  CHECK (ROLE_IN_COMMITTEE IN ('CHAIRMAN', 'SECRETARY', 'MEMBER', 'ADVISOR'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (COMMITTEE_ID, USER_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CREDIT_CRITERIA
(
  CRITERIA_ID    NUMBER,
  CRITERIA_NAME  VARCHAR2(100 BYTE)             NOT NULL,
  CRITERIA_TYPE  VARCHAR2(50 BYTE)              NOT NULL,
  MAX_SCORE      NUMBER                         NOT NULL,
  WEIGHT         NUMBER                         NOT NULL,
  DESCRIPTION    CLOB,
  CREATED_DATE   DATE                           DEFAULT SYSDATE,
  CREATED_BY     VARCHAR2(50 BYTE),
  UPDATED_DATE   DATE,
  UPDATED_BY     VARCHAR2(50 BYTE)
)
LOB (DESCRIPTION) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE CREDIT_CRITERIA ADD (
  PRIMARY KEY
  (CRITERIA_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CREDIT_RATING_HISTORY
(
  RATING_ID       NUMBER GENERATED ALWAYS AS IDENTITY ( START WITH 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 NOCYCLE CACHE 20 NOORDER NOKEEP NOSCALE) NOT NULL,
  CUSTOMER_ID     NUMBER                        NOT NULL,
  PREVIOUS_SCORE  NUMBER,
  NEW_SCORE       NUMBER                        NOT NULL,
  RATING_DATE     TIMESTAMP(6)                  DEFAULT SYSTIMESTAMP          NOT NULL,
  RATING_REASON   VARCHAR2(500 BYTE),
  RATED_BY        NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE CREDIT_RATING_HISTORY ADD (
  PRIMARY KEY
  (RATING_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMERS
(
  CUSTOMER_ID               NUMBER,
  CUSTOMER_TYPE             VARCHAR2(20 BYTE)   NOT NULL,
  FULL_NAME                 VARCHAR2(100 BYTE)  NOT NULL,
  NATIONAL_ID               VARCHAR2(20 BYTE)   NOT NULL,
  MOBILE_NUMBER             VARCHAR2(20 BYTE)   NOT NULL,
  EMAIL                     VARCHAR2(100 BYTE),
  DATE_OF_BIRTH             DATE,
  GENDER                    VARCHAR2(10 BYTE),
  MARITAL_STATUS            VARCHAR2(20 BYTE),
  EDUCATION_LEVEL           VARCHAR2(50 BYTE),
  HOME_ADDRESS              VARCHAR2(200 BYTE),
  WORK_ADDRESS              VARCHAR2(200 BYTE),
  EMPLOYER_NAME             VARCHAR2(100 BYTE),
  JOB_TITLE                 VARCHAR2(100 BYTE),
  EMPLOYMENT_STATUS         VARCHAR2(50 BYTE),
  EMPLOYMENT_DATE           DATE,
  MONTHLY_INCOME            NUMBER,
  ADDITIONAL_INCOME         NUMBER,
  ADDITIONAL_INCOME_SOURCE  VARCHAR2(100 BYTE),
  BANK_ACCOUNT_NUMBER       VARCHAR2(50 BYTE),
  BANK_NAME                 VARCHAR2(100 BYTE),
  IBAN                      VARCHAR2(50 BYTE),
  CREDIT_SCORE              NUMBER,
  CUSTOMER_STATUS           VARCHAR2(20 BYTE)   DEFAULT 'ACTIVE'              NOT NULL,
  RISK_LEVEL                VARCHAR2(20 BYTE),
  NOTES                     VARCHAR2(4000 BYTE),
  CREATION_DATE             TIMESTAMP(6)        DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY                NUMBER,
  LAST_UPDATE_DATE          TIMESTAMP(6),
  LAST_UPDATED_BY           NUMBER,
  PHONE                     VARCHAR2(20 BYTE),
  POSTAL_CODE               VARCHAR2(101 BYTE),
  CITY                      VARCHAR2(101 BYTE),
  RELATIONSHIP_MANAGER      NUMBER,
  CUSTOMER_CLASSIFICATION   VARCHAR2(101 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE CUSTOMERS ADD (
  CONSTRAINT CHK_CUSTOMER_STATUS
  CHECK (CUSTOMER_STATUS IN ('ACTIVE', 'INACTIVE', 'BLACKLISTED', 'DECEASED'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_CUSTOMER_TYPE
  CHECK (CUSTOMER_TYPE IN ('INDIVIDUAL', 'CORPORATE'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_RISK_LEVEL
  CHECK (RISK_LEVEL IN ('LOW', 'MEDIUM', 'HIGH'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (CUSTOMER_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (NATIONAL_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMERS_NEW
(
  CUSTOMER_ID       NUMBER,
  FULL_NAME         VARCHAR2(100 BYTE)          NOT NULL,
  CUSTOMER_TYPE     VARCHAR2(20 BYTE)           NOT NULL,
  CUSTOMER_SEGMENT  VARCHAR2(20 BYTE),
  NATIONAL_ID       VARCHAR2(20 BYTE),
  MOBILE_NUMBER     VARCHAR2(20 BYTE),
  EMAIL             VARCHAR2(100 BYTE),
  ADDRESS           VARCHAR2(200 BYTE),
  BIRTH_DATE        DATE,
  GENDER            VARCHAR2(10 BYTE),
  MARITAL_STATUS    VARCHAR2(20 BYTE),
  OCCUPATION        VARCHAR2(100 BYTE),
  MONTHLY_INCOME    NUMBER,
  STATUS            VARCHAR2(20 BYTE)           DEFAULT 'ACTIVE',
  CREATED_BY        NUMBER,
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP,
  UPDATED_BY        NUMBER,
  UPDATE_DATE       TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE CUSTOMERS_NEW ADD (
  PRIMARY KEY
  (CUSTOMER_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (NATIONAL_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMER_CONTACT_PREFERENCES
(
  PREFERENCE_ID        NUMBER,
  CUSTOMER_ID          NUMBER                   NOT NULL,
  CONTACT_METHOD       VARCHAR2(50 BYTE)        NOT NULL,
  IS_ENABLED           NUMBER(1)                DEFAULT 1                     NOT NULL,
  PREFERRED_TIME_FROM  VARCHAR2(5 BYTE),
  PREFERRED_TIME_TO    VARCHAR2(5 BYTE),
  PREFERRED_DAYS       VARCHAR2(100 BYTE),
  NOTES                VARCHAR2(500 BYTE),
  CREATION_DATE        TIMESTAMP(6)             DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY           NUMBER,
  UPDATE_DATE          TIMESTAMP(6),
  UPDATED_BY           NUMBER,
  ALLOW_SMS            VARCHAR2(1 BYTE),
  ALLOW_EMAIL          VARCHAR2(1 BYTE),
  ALLOW_PHONE          VARCHAR2(1 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE CUSTOMER_CONTACT_PREFERENCES IS 'جدول يخزن تفضيلات الاتصال للعملاء';

COMMENT ON COLUMN CUSTOMER_CONTACT_PREFERENCES.PREFERENCE_ID IS 'معرف فريد لتفضيل الاتصال';

COMMENT ON COLUMN CUSTOMER_CONTACT_PREFERENCES.CUSTOMER_ID IS 'معرف العميل المرتبط بتفضيل الاتصال';

COMMENT ON COLUMN CUSTOMER_CONTACT_PREFERENCES.CONTACT_METHOD IS 'طريقة الاتصال المفضلة (بريد إلكتروني، رسائل نصية، هاتف، واتساب، بريد)';

COMMENT ON COLUMN CUSTOMER_CONTACT_PREFERENCES.IS_ENABLED IS 'حالة تفعيل طريقة الاتصال (1 = مفعل، 0 = غير مفعل)';

COMMENT ON COLUMN CUSTOMER_CONTACT_PREFERENCES.PREFERRED_TIME_FROM IS 'بداية الوقت المفضل للاتصال بتنسيق HH:MM';

COMMENT ON COLUMN CUSTOMER_CONTACT_PREFERENCES.PREFERRED_TIME_TO IS 'نهاية الوقت المفضل للاتصال بتنسيق HH:MM';

COMMENT ON COLUMN CUSTOMER_CONTACT_PREFERENCES.PREFERRED_DAYS IS 'الأيام المفضلة للاتصال مفصولة بفواصل';

COMMENT ON COLUMN CUSTOMER_CONTACT_PREFERENCES.NOTES IS 'ملاحظات إضافية حول تفضيل الاتصال';


CREATE UNIQUE INDEX UQ_CUSTOMER_CONTACT_METHOD ON CUSTOMER_CONTACT_PREFERENCES
(CUSTOMER_ID, CONTACT_METHOD)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

ALTER TABLE CUSTOMER_CONTACT_PREFERENCES ADD (
  CONSTRAINT CHK_CONTACT_METHOD
  CHECK (CONTACT_METHOD IN ('EMAIL', 'SMS', 'PHONE', 'WHATSAPP', 'MAIL'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_IS_ENABLED
  CHECK (IS_ENABLED IN (0, 1))
  ENABLE VALIDATE
,  PRIMARY KEY
  (PREFERENCE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  CONSTRAINT UQ_CUSTOMER_CONTACT_METHOD
  UNIQUE (CUSTOMER_ID, CONTACT_METHOD)
  USING INDEX UQ_CUSTOMER_CONTACT_METHOD
  ENABLE VALIDATE);


CREATE TABLE CUSTOMER_CREDIT_RATINGS
(
  RATING_ID         NUMBER,
  CUSTOMER_ID       NUMBER                      NOT NULL,
  RATING_VALUE      VARCHAR2(20 BYTE)           NOT NULL,
  RATING_SCORE      NUMBER,
  RATING_SOURCE     VARCHAR2(100 BYTE),
  RATING_DATE       DATE                        NOT NULL,
  EXPIRY_DATE       DATE,
  NOTES             VARCHAR2(4000 BYTE),
  CREATED_BY        NUMBER                      NOT NULL,
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY   NUMBER,
  LAST_UPDATE_DATE  TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE CUSTOMER_CREDIT_RATINGS IS 'جدول لتخزين تصنيفات الائتمان للعملاء';

COMMENT ON COLUMN CUSTOMER_CREDIT_RATINGS.RATING_ID IS 'معرف فريد لتصنيف الائتمان';

COMMENT ON COLUMN CUSTOMER_CREDIT_RATINGS.CUSTOMER_ID IS 'معرف العميل المرتبط بالتصنيف';

COMMENT ON COLUMN CUSTOMER_CREDIT_RATINGS.RATING_VALUE IS 'قيمة التصنيف (A+, A, B+, إلخ)';

COMMENT ON COLUMN CUSTOMER_CREDIT_RATINGS.RATING_SCORE IS 'درجة رقمية للتصنيف';

COMMENT ON COLUMN CUSTOMER_CREDIT_RATINGS.RATING_SOURCE IS 'مصدر التصنيف الائتماني';

COMMENT ON COLUMN CUSTOMER_CREDIT_RATINGS.RATING_DATE IS 'تاريخ إصدار التصنيف';

COMMENT ON COLUMN CUSTOMER_CREDIT_RATINGS.EXPIRY_DATE IS 'تاريخ انتهاء صلاحية التصنيف';

COMMENT ON COLUMN CUSTOMER_CREDIT_RATINGS.NOTES IS 'ملاحظات إضافية حول التصنيف';


ALTER TABLE CUSTOMER_CREDIT_RATINGS ADD (
  CONSTRAINT CHK_RATING_VALUE
  CHECK (RATING_VALUE IN ('A+', 'A', 'B+', 'B', 'C+', 'C', 'D', 'E', 'F'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (RATING_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMER_CREDIT_SCORES
(
  SCORE_ID         NUMBER,
  CUSTOMER_ID      NUMBER                       NOT NULL,
  CRITERIA_ID      NUMBER                       NOT NULL,
  SCORE_VALUE      NUMBER                       NOT NULL,
  EVALUATION_DATE  DATE                         DEFAULT SYSDATE,
  CREATED_DATE     DATE                         DEFAULT SYSDATE,
  CREATED_BY       VARCHAR2(50 BYTE),
  UPDATED_DATE     DATE,
  UPDATED_BY       VARCHAR2(50 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE CUSTOMER_CREDIT_SCORES ADD (
  PRIMARY KEY
  (SCORE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMER_DOCUMENTS
(
  DOCUMENT_ID      NUMBER,
  CUSTOMER_ID      NUMBER                       NOT NULL,
  DOCUMENT_TYPE    VARCHAR2(50 BYTE)            NOT NULL,
  DOCUMENT_NUMBER  VARCHAR2(100 BYTE),
  ISSUE_DATE       DATE,
  EXPIRY_DATE      DATE,
  DOCUMENT_PATH    VARCHAR2(500 BYTE),
  DOCUMENT_STATUS  VARCHAR2(20 BYTE)            DEFAULT 'ACTIVE'              NOT NULL,
  NOTES            CLOB,
  CREATED_DATE     TIMESTAMP(6)                 DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY       VARCHAR2(50 BYTE)            NOT NULL,
  UPDATED_DATE     TIMESTAMP(6),
  UPDATED_BY       VARCHAR2(50 BYTE)
)
LOB (NOTES) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE CUSTOMER_DOCUMENTS IS 'جدول يخزن مستندات العملاء مثل الهوية وكشوف الحسابات وغيرها';


ALTER TABLE CUSTOMER_DOCUMENTS ADD (
  CONSTRAINT CHK_CUST_DOC_STATUS
  CHECK (DOCUMENT_STATUS IN ('ACTIVE', 'EXPIRED', 'REJECTED', 'PENDING', 'ARCHIVED'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (DOCUMENT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMER_EMERGENCY_CONTACTS
(
  CONTACT_ID         NUMBER,
  CUSTOMER_ID        NUMBER,
  CONTACT_NAME       VARCHAR2(151 BYTE),
  RELATIONSHIP       VARCHAR2(31 BYTE),
  PHONE              VARCHAR2(31 BYTE),
  MOBILE             VARCHAR2(31 BYTE),
  EMAIL              VARCHAR2(101 BYTE),
  ADDRESS            VARCHAR2(151 BYTE),
  CREATION_DATE      DATE,
  CREATED_BY         NUMBER,
  LAST_UPDATED_DATE  DATE,
  LAST_UPDATED_BY    NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE CUSTOMER_FINANCIAL_OBLIGATIONS
(
  OBLIGATION_ID     NUMBER,
  CUSTOMER_ID       NUMBER                      NOT NULL,
  OBLIGATION_TYPE   VARCHAR2(50 BYTE)           NOT NULL,
  CREDITOR_NAME     VARCHAR2(100 BYTE),
  ORIGINAL_AMOUNT   NUMBER                      NOT NULL,
  REMAINING_AMOUNT  NUMBER                      NOT NULL,
  MONTHLY_PAYMENT   NUMBER                      NOT NULL,
  START_DATE        DATE                        NOT NULL,
  END_DATE          DATE                        NOT NULL,
  NOTES             VARCHAR2(500 BYTE),
  CREATED_BY        NUMBER                      NOT NULL,
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY   NUMBER,
  LAST_UPDATE_DATE  TIMESTAMP(6),
  DESCRIPTION       VARCHAR2(101 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE CUSTOMER_FINANCIAL_OBLIGATIONS ADD (
  CONSTRAINT CHK_OBLIGATION_TYPE
  CHECK (OBLIGATION_TYPE IN ('LOAN', 'CREDIT_CARD', 'MORTGAGE', 'CAR_LOAN', 'PERSONAL_LOAN', 'OTHER'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (OBLIGATION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMER_INCOME
(
  INCOME_ID         NUMBER,
  CUSTOMER_ID       NUMBER,
  INCOME_SOURCE     VARCHAR2(101 BYTE),
  INCOME_AMOUNT     NUMBER,
  INCOME_FREQUENCY  VARCHAR2(51 BYTE),
  START_DATE        DATE,
  END_DATE          DATE,
  NOTES             VARCHAR2(151 BYTE),
  CREATION_DATE     DATE,
  CREATED_BY        NUMBER,
  LAST_UPDATE_DATE  DATE,
  LAST_UPDATE_BY    NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE CUSTOMER_NOTES
(
  NOTE_ID              NUMBER,
  CUSTOMER_ID          NUMBER                   NOT NULL,
  NOTE_TYPE            VARCHAR2(50 BYTE)        NOT NULL,
  NOTE_TITLE           VARCHAR2(200 BYTE),
  NOTE_TEXT            CLOB,
  IMPORTANCE           VARCHAR2(20 BYTE)        DEFAULT 'NORMAL',
  IS_PRIVATE           NUMBER(1)                DEFAULT 0,
  FOLLOW_UP_DATE       DATE,
  FOLLOW_UP_DONE       NUMBER(1)                DEFAULT 0,
  FOLLOW_UP_NOTES      CLOB,
  FOLLOW_UP_DONE_DATE  DATE,
  FOLLOW_UP_DONE_BY    NUMBER,
  STATUS               VARCHAR2(20 BYTE)        DEFAULT 'ACTIVE',
  CREATION_DATE        TIMESTAMP(6)             DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY           NUMBER                   NOT NULL,
  UPDATE_DATE          TIMESTAMP(6),
  UPDATED_BY           NUMBER
)
LOB (FOLLOW_UP_NOTES) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
LOB (NOTE_TEXT) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE CUSTOMER_NOTES IS 'جدول يخزن ملاحظات العملاء والمتابعات';

COMMENT ON COLUMN CUSTOMER_NOTES.NOTE_ID IS 'معرف فريد للملاحظة';

COMMENT ON COLUMN CUSTOMER_NOTES.CUSTOMER_ID IS 'معرف العميل المرتبط بالملاحظة';

COMMENT ON COLUMN CUSTOMER_NOTES.NOTE_TYPE IS 'نوع الملاحظة (عامة، ائتمان، شكوى، متابعة، اجتماع، أخرى)';

COMMENT ON COLUMN CUSTOMER_NOTES.NOTE_TITLE IS 'عنوان الملاحظة';

COMMENT ON COLUMN CUSTOMER_NOTES.NOTE_TEXT IS 'نص الملاحظة';

COMMENT ON COLUMN CUSTOMER_NOTES.IMPORTANCE IS 'أهمية الملاحظة (منخفضة، عادية، عالية، عاجلة)';

COMMENT ON COLUMN CUSTOMER_NOTES.IS_PRIVATE IS 'هل الملاحظة خاصة (0 = عام، 1 = خاص)';

COMMENT ON COLUMN CUSTOMER_NOTES.FOLLOW_UP_DATE IS 'تاريخ المتابعة المطلوب';

COMMENT ON COLUMN CUSTOMER_NOTES.FOLLOW_UP_DONE IS 'هل تمت المتابعة (0 = لم يتم، 1 = تم)';

COMMENT ON COLUMN CUSTOMER_NOTES.FOLLOW_UP_NOTES IS 'ملاحظات المتابعة';

COMMENT ON COLUMN CUSTOMER_NOTES.FOLLOW_UP_DONE_DATE IS 'تاريخ إتمام المتابعة';

COMMENT ON COLUMN CUSTOMER_NOTES.FOLLOW_UP_DONE_BY IS 'معرف المستخدم الذي قام بالمتابعة';

COMMENT ON COLUMN CUSTOMER_NOTES.STATUS IS 'حالة الملاحظة (نشطة، مؤرشفة، محذوفة)';


ALTER TABLE CUSTOMER_NOTES ADD (
  CONSTRAINT CHK_NOTE_FOLLOWUP_DONE
  CHECK (FOLLOW_UP_DONE IN (0, 1))
  ENABLE VALIDATE
,  CONSTRAINT CHK_NOTE_IMPORTANCE
  CHECK (IMPORTANCE IN ('LOW', 'NORMAL', 'HIGH', 'URGENT'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_NOTE_IS_PRIVATE
  CHECK (IS_PRIVATE IN (0, 1))
  ENABLE VALIDATE
,  CONSTRAINT CHK_NOTE_STATUS
  CHECK (STATUS IN ('ACTIVE', 'ARCHIVED', 'DELETED'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_NOTE_TYPE
  CHECK (NOTE_TYPE IN ('GENERAL', 'CREDIT', 'COMPLAINT', 'FOLLOW_UP', 'MEETING', 'OTHER'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (NOTE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMER_NOTIFICATIONS
(
  NOTIFICATION_ID     NUMBER,
  CUSTOMER_ID         NUMBER                    NOT NULL,
  NOTIFICATION_TYPE   VARCHAR2(50 BYTE)         NOT NULL,
  NOTIFICATION_TITLE  VARCHAR2(200 BYTE),
  NOTIFICATION_TEXT   VARCHAR2(4000 BYTE)       NOT NULL,
  RELATED_ENTITY      VARCHAR2(50 BYTE),
  RELATED_ENTITY_ID   NUMBER,
  NOTIFICATION_DATE   DATE                      DEFAULT SYSDATE               NOT NULL,
  IS_READ             NUMBER(1)                 DEFAULT 0                     NOT NULL,
  READ_DATE           DATE,
  CREATED_BY          NUMBER,
  CREATION_DATE       DATE                      DEFAULT SYSDATE,
  LAST_UPDATED_BY     NUMBER,
  LAST_UPDATE_DATE    DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE CUSTOMER_NOTIFICATIONS IS 'جدول لتخزين إشعارات العملاء في نظام التمويل الإسلامي';

COMMENT ON COLUMN CUSTOMER_NOTIFICATIONS.NOTIFICATION_ID IS 'المعرف الفريد للإشعار';

COMMENT ON COLUMN CUSTOMER_NOTIFICATIONS.CUSTOMER_ID IS 'معرف العميل المرسل إليه الإشعار';

COMMENT ON COLUMN CUSTOMER_NOTIFICATIONS.NOTIFICATION_TYPE IS 'نوع الإشعار (مثل: تذكير، تنبيه، إلخ)';

COMMENT ON COLUMN CUSTOMER_NOTIFICATIONS.IS_READ IS 'مؤشر ما إذا كان الإشعار مقروءًا (0=غير مقروء، 1=مقروء)';


ALTER TABLE CUSTOMER_NOTIFICATIONS ADD (
  PRIMARY KEY
  (NOTIFICATION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE CUSTOMER_STATUS_HISTORY
(
  HISTORY_ID     NUMBER,
  CUSTOMER_ID    NUMBER,
  OLD_STATUS     VARCHAR2(31 BYTE),
  NEW_STATUS     VARCHAR2(31 BYTE),
  CHANGE_REASON  VARCHAR2(151 BYTE),
  CHANGE_DATE    DATE,
  CHANGED_BY     NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE DEBT_CLASSIFICATIONS
(
  CLASSIFICATION_ID     NUMBER,
  CLASSIFICATION_NAME   VARCHAR2(50 BYTE)       NOT NULL,
  DESCRIPTION           VARCHAR2(500 BYTE),
  DAYS_OVERDUE_MIN      NUMBER                  NOT NULL,
  DAYS_OVERDUE_MAX      NUMBER,
  PROVISION_PERCENTAGE  NUMBER                  NOT NULL,
  IS_ACTIVE             VARCHAR2(1 BYTE)        DEFAULT 'Y'                   NOT NULL,
  CREATED_BY            NUMBER                  NOT NULL,
  CREATION_DATE         TIMESTAMP(6)            DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY       NUMBER,
  LAST_UPDATE_DATE      TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE DEBT_CLASSIFICATIONS ADD (
  CONSTRAINT CHK_DEBT_CLASS_ACTIVE
  CHECK (IS_ACTIVE IN ('Y', 'N'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (CLASSIFICATION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE DEBT_CLASSIFICATIONS_ORG
(
  CLASSIFICATION_ID     NUMBER,
  CLASSIFICATION_NAME   VARCHAR2(100 BYTE)      NOT NULL,
  MIN_DAYS_PAST_DUE     NUMBER,
  MAX_DAYS_PAST_DUE     NUMBER,
  PROVISION_PERCENTAGE  NUMBER                  NOT NULL,
  DESCRIPTION           VARCHAR2(301 BYTE),
  CREATED_DATE          DATE                    DEFAULT SYSDATE,
  CREATED_BY            VARCHAR2(50 BYTE),
  UPDATED_DATE          DATE,
  UPDATED_BY            VARCHAR2(50 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE DEBT_CLASSIFICATIONS_ORG ADD (
  PRIMARY KEY
  (CLASSIFICATION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE DOCUMENT_TYPES
(
  DOCUMENT_TYPE_ID  NUMBER,
  TYPE_NAME         VARCHAR2(100 BYTE)          NOT NULL,
  DESCRIPTION       VARCHAR2(500 BYTE),
  REQUIRED_FOR      VARCHAR2(50 BYTE)           NOT NULL,
  IS_MANDATORY      VARCHAR2(1 BYTE)            DEFAULT 'N'                   NOT NULL,
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY        NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE DOCUMENT_TYPES ADD (
  CONSTRAINT CHK_IS_MANDATORY
  CHECK (IS_MANDATORY IN ('Y', 'N'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_REQUIRED_FOR
  CHECK (REQUIRED_FOR IN ('CUSTOMER', 'FINANCING_REQUEST', 'FINANCING_CONTRACT', 'COLLATERAL'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (DOCUMENT_TYPE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE EARLY_SETTLEMENTS
(
  FINANCING_ID        NUMBER,
  SETTLEMENT_DATE     DATE,
  ORIGINAL_REMAINING  NUMBER,
  SETTLEMENT_AMOUNT   NUMBER,
  DISCOUNT_AMOUNT     NUMBER,
  SETTLEMENT_REASON   VARCHAR2(101 BYTE),
  CREATED_BY          NUMBER,
  CREATION_DATE       DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE EMAIL_LOGS
(
  EMAIL_ID         NUMBER,
  EMAIL_TO         VARCHAR2(101 BYTE),
  EMAIL_CC         VARCHAR2(101 BYTE),
  EMAIL_BCC        VARCHAR2(101 BYTE),
  EMAIL_FROM       VARCHAR2(101 BYTE),
  SUBJECT          VARCHAR2(101 BYTE),
  EMAIL_BODY       VARCHAR2(3001 BYTE),
  ATTACHMENT_PATH  VARCHAR2(301 BYTE),
  STATUS           VARCHAR2(101 BYTE),
  CREATED_DATE     DATE,
  SENT_DATE        DATE,
  ERROR_MESSAGE    VARCHAR2(1001 BYTE),
  REFERENCE_TYPE   VARCHAR2(101 BYTE),
  REFERENCE_ID     NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE ERROR_LOG
(
  LOG_ID          NUMBER GENERATED ALWAYS AS IDENTITY ( START WITH 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 NOCYCLE CACHE 20 NOORDER NOKEEP NOSCALE) NOT NULL,
  ERROR_CODE      NUMBER,
  ERROR_MESSAGE   VARCHAR2(4000 BYTE),
  PROCEDURE_NAME  VARCHAR2(100 BYTE),
  ERROR_DATE      DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE ERROR_LOG ADD (
  PRIMARY KEY
  (LOG_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FAQ
(
  FAQ_ID            NUMBER GENERATED ALWAYS AS IDENTITY ( START WITH 21 MAXVALUE 9999999999999999999999999999 MINVALUE 1 NOCYCLE CACHE 20 NOORDER NOKEEP NOSCALE) NOT NULL,
  QUESTION          VARCHAR2(500 BYTE)          NOT NULL,
  ANSWER            VARCHAR2(4000 BYTE)         NOT NULL,
  CATEGORY          VARCHAR2(100 BYTE)          NOT NULL,
  DISPLAY_ORDER     NUMBER,
  IS_ACTIVE         VARCHAR2(1 BYTE)            DEFAULT 'Y'                   NOT NULL,
  CREATED_BY        NUMBER                      NOT NULL,
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY   NUMBER,
  LAST_UPDATE_DATE  TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FAQ ADD (
  CONSTRAINT CHK_FAQ_ACTIVE
  CHECK (IS_ACTIVE IN ('Y', 'N'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (FAQ_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FEES_COMMISSIONS
(
  FEE_ID        NUMBER,
  PRODUCT_ID    NUMBER                          NOT NULL,
  STAGE_ID      NUMBER,
  FEE_NAME      VARCHAR2(100 BYTE)              NOT NULL,
  FEE_TYPE      VARCHAR2(50 BYTE)               NOT NULL,
  FEE_VALUE     NUMBER                          NOT NULL,
  MIN_VALUE     NUMBER,
  MAX_VALUE     NUMBER,
  DESCRIPTION   CLOB,
  CREATED_DATE  DATE                            DEFAULT SYSDATE,
  CREATED_BY    VARCHAR2(50 BYTE),
  UPDATED_DATE  DATE,
  UPDATED_BY    VARCHAR2(50 BYTE)
)
LOB (DESCRIPTION) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FEES_COMMISSIONS ADD (
  PRIMARY KEY
  (FEE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FINANCING_COLLATERALS
(
  FINANCING_COLLATERAL_ID  NUMBER,
  REQUEST_ID               NUMBER               NOT NULL,
  COLLATERAL_ID            NUMBER               NOT NULL,
  CREATED_BY               NUMBER,
  CREATION_DATE            TIMESTAMP(6)         DEFAULT SYSTIMESTAMP,
  UPDATED_BY               NUMBER,
  UPDATE_DATE              TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE UNIQUE INDEX UQ_FINANCING_COLLATERAL ON FINANCING_COLLATERALS
(REQUEST_ID, COLLATERAL_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

ALTER TABLE FINANCING_COLLATERALS ADD (
  PRIMARY KEY
  (FINANCING_COLLATERAL_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  CONSTRAINT UQ_FINANCING_COLLATERAL
  UNIQUE (REQUEST_ID, COLLATERAL_ID)
  USING INDEX UQ_FINANCING_COLLATERAL
  ENABLE VALIDATE);


CREATE TABLE FINANCING_NOTES
(
  NOTE_ID        NUMBER,
  FINANCING_ID   NUMBER                         NOT NULL,
  NOTE_TEXT      VARCHAR2(4000 BYTE)            NOT NULL,
  CREATED_BY     NUMBER                         NOT NULL,
  CREATION_DATE  TIMESTAMP(6)                   DEFAULT SYSTIMESTAMP          NOT NULL,
  REQUEST_ID     NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FINANCING_NOTES ADD (
  PRIMARY KEY
  (NOTE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FINANCING_REQUESTS
(
  REQUEST_ID         NUMBER,
  CUSTOMER_ID        NUMBER                     NOT NULL,
  PRODUCT_ID         NUMBER                     NOT NULL,
  CURRENT_STAGE_ID   NUMBER,
  REQUESTED_AMOUNT   NUMBER                     NOT NULL,
  APPROVED_AMOUNT    NUMBER,
  FINANCING_PERIOD   NUMBER,
  PROFIT_RATE        NUMBER,
  REQUEST_STATUS     VARCHAR2(50 BYTE)          DEFAULT 'NEW',
  REQUEST_DATE       DATE                       DEFAULT SYSDATE,
  APPROVAL_DATE      DATE,
  DISBURSEMENT_DATE  DATE,
  CREATED_DATE       DATE                       DEFAULT SYSDATE,
  CREATED_BY         VARCHAR2(50 BYTE),
  UPDATED_DATE       DATE,
  UPDATED_BY         VARCHAR2(50 BYTE),
  REQUEST_NUMBER     VARCHAR2(101 BYTE),
  ASSIGNED_TO        NUMBER,
  STAGE_START_DATE   DATE,
  REJECT_REASONS     VARCHAR2(501 BYTE),
  ASSIGNED_DATE      DATE,
  WORKFLOW_ID        NUMBER,
  PURPOSE            VARCHAR2(301 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FINANCING_REQUESTS ADD (
  PRIMARY KEY
  (REQUEST_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FINANCING_REQUESTS_NEW
(
  REQUEST_ID           NUMBER,
  CUSTOMER_ID          NUMBER                   NOT NULL,
  AMOUNT               NUMBER                   NOT NULL,
  TENURE_MONTHS        NUMBER                   NOT NULL,
  PROFIT_RATE          NUMBER                   NOT NULL,
  PURPOSE              VARCHAR2(200 BYTE),
  MONTHLY_INSTALLMENT  NUMBER,
  STATUS               VARCHAR2(20 BYTE)        DEFAULT 'PENDING',
  REJECTION_REASON     VARCHAR2(500 BYTE),
  WORKFLOW_ID          NUMBER,
  CREATED_BY           NUMBER,
  CREATION_DATE        TIMESTAMP(6)             DEFAULT SYSTIMESTAMP,
  UPDATED_BY           NUMBER,
  UPDATE_DATE          TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FINANCING_REQUESTS_NEW ADD (
  PRIMARY KEY
  (REQUEST_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FINANCING_REQUESTS_NEW1
(
  REQUEST_ID               NUMBER,
  CUSTOMER_ID              NUMBER               NOT NULL,
  PRODUCT_ID               NUMBER               NOT NULL,
  FINANCING_AMOUNT         NUMBER               NOT NULL,
  FINANCING_PERIOD         NUMBER               NOT NULL,
  MONTHLY_INCOME           NUMBER,
  PURPOSE                  VARCHAR2(200 BYTE),
  REQUEST_STATUS           VARCHAR2(50 BYTE)    DEFAULT 'PENDING'             NOT NULL,
  REJECTION_REASON         VARCHAR2(500 BYTE),
  NOTES                    VARCHAR2(4000 BYTE),
  CREDIT_SCORE             NUMBER,
  DTI_RATIO                NUMBER,
  ASSIGNED_TO              NUMBER,
  COMMITTEE_DECISION       VARCHAR2(50 BYTE),
  COMMITTEE_NOTES          VARCHAR2(1000 BYTE),
  COMMITTEE_DECISION_DATE  TIMESTAMP(6),
  CREATION_DATE            TIMESTAMP(6)         DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY               NUMBER,
  LAST_UPDATE_DATE         TIMESTAMP(6),
  LAST_UPDATED_BY          NUMBER,
  REQUEST_NUMBER           VARCHAR2(101 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FINANCING_REQUESTS_NEW1 ADD (
  CONSTRAINT CHK_REQUEST_STATUS
  CHECK (REQUEST_STATUS IN ('PENDING', 'UNDER_REVIEW', 'APPROVED', 'REJECTED', 'CANCELLED', 'COMPLETED'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (REQUEST_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FINANCING_STATUS_HISTORY
(
  HISTORY_ID     NUMBER,
  FINANCING_ID   NUMBER                         NOT NULL,
  OLD_STATUS     VARCHAR2(50 BYTE),
  NEW_STATUS     VARCHAR2(50 BYTE)              NOT NULL,
  CHANGE_REASON  VARCHAR2(500 BYTE),
  CHANGE_DATE    TIMESTAMP(6)                   DEFAULT SYSTIMESTAMP          NOT NULL,
  CHANGED_BY     NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FINANCING_STATUS_HISTORY ADD (
  PRIMARY KEY
  (HISTORY_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE HOLIDAYS
(
  HOLIDAY_ID     NUMBER GENERATED ALWAYS AS IDENTITY ( START WITH 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 NOCYCLE CACHE 20 NOORDER NOKEEP NOSCALE) NOT NULL,
  HOLIDAY_DATE   DATE                           NOT NULL,
  HOLIDAY_NAME   VARCHAR2(100 BYTE)             NOT NULL,
  HOLIDAY_TYPE   VARCHAR2(50 BYTE)              NOT NULL,
  DESCRIPTION    VARCHAR2(500 BYTE),
  CREATED_BY     NUMBER                         NOT NULL,
  CREATION_DATE  TIMESTAMP(6)                   DEFAULT SYSTIMESTAMP          NOT NULL
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE HOLIDAYS ADD (
  CONSTRAINT CHK_HOLIDAY_TYPE
  CHECK (HOLIDAY_TYPE IN ('NATIONAL', 'RELIGIOUS', 'BANK_HOLIDAY', 'WEEKEND'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (HOLIDAY_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE INSTALLMENT_SCHEDULE
(
  INSTALLMENT_ID      NUMBER,
  REQUEST_ID          NUMBER                    NOT NULL,
  CONTRACT_ID         NUMBER                    NOT NULL,
  DUE_DATE            DATE                      NOT NULL,
  PRINCIPAL_AMOUNT    NUMBER                    NOT NULL,
  PROFIT_AMOUNT       NUMBER                    NOT NULL,
  FEES_AMOUNT         NUMBER                    DEFAULT 0,
  TOTAL_AMOUNT        NUMBER                    NOT NULL,
  PAID_AMOUNT         NUMBER                    DEFAULT 0,
  PAYMENT_DATE        DATE,
  INSTALLMENT_STATUS  VARCHAR2(50 BYTE)         DEFAULT 'SCHEDULED',
  CREATED_DATE        DATE                      DEFAULT SYSDATE,
  CREATED_BY          VARCHAR2(50 BYTE),
  UPDATED_DATE        DATE,
  UPDATED_BY          VARCHAR2(50 BYTE),
  REMAINING_AMOUNT    NUMBER,
  LATE_FEES           NUMBER,
  INSTALLMENT_SEQ     NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE INSTALLMENT_SCHEDULE ADD (
  PRIMARY KEY
  (INSTALLMENT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE INSTALLMENT_SCHEDULE_NEW
(
  INSTALLMENT_ID      NUMBER,
  FINANCING_ID        NUMBER                    NOT NULL,
  INSTALLMENT_NUMBER  NUMBER                    NOT NULL,
  INSTALLMENT_AMOUNT  NUMBER                    NOT NULL,
  PRINCIPAL_AMOUNT    NUMBER                    NOT NULL,
  PROFIT_AMOUNT       NUMBER                    NOT NULL,
  DUE_DATE            DATE                      NOT NULL,
  INSTALLMENT_STATUS  VARCHAR2(20 BYTE)         DEFAULT 'UNPAID'              NOT NULL,
  PAID_DATE           DATE,
  PAID_AMOUNT         NUMBER,
  REMAINING_AMOUNT    NUMBER                    NOT NULL,
  LATE_FEES           NUMBER                    DEFAULT 0,
  CREATION_DATE       TIMESTAMP(6)              DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATE_DATE    TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE INSTALLMENT_SCHEDULE_NEW ADD (
  CONSTRAINT CHK_INSTALLMENT_STATUS
  CHECK (INSTALLMENT_STATUS IN ('UNPAID', 'PARTIALLY_PAID', 'PAID', 'OVERDUE', 'WAIVED'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (INSTALLMENT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE ISLAMIC_PRODUCTS
(
  PRODUCT_ID             NUMBER,
  PRODUCT_CODE           VARCHAR2(20 BYTE)      NOT NULL,
  PRODUCT_NAME           VARCHAR2(100 BYTE)     NOT NULL,
  PRODUCT_TYPE           VARCHAR2(50 BYTE)      NOT NULL,
  DESCRIPTION            VARCHAR2(4000 BYTE),
  PROFIT_RATE            NUMBER                 NOT NULL,
  MIN_FINANCING_AMOUNT   NUMBER,
  MAX_FINANCING_AMOUNT   NUMBER,
  MIN_FINANCING_PERIOD   NUMBER,
  MAX_FINANCING_PERIOD   NUMBER,
  ADMIN_FEES             NUMBER,
  EARLY_SETTLEMENT_FEES  NUMBER,
  LATE_PAYMENT_FEES      NUMBER,
  REQUIRED_DOCUMENTS     VARCHAR2(4000 BYTE),
  ELIGIBILITY_CRITERIA   VARCHAR2(4000 BYTE),
  PRODUCT_STATUS         VARCHAR2(20 BYTE)      DEFAULT 'ACTIVE'              NOT NULL,
  CREATION_DATE          TIMESTAMP(6)           DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY             NUMBER,
  LAST_UPDATE_DATE       TIMESTAMP(6),
  LAST_UPDATED_BY        NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE ISLAMIC_PRODUCTS ADD (
  CONSTRAINT CHK_PRODUCT_STATUS
  CHECK (PRODUCT_STATUS IN ('ACTIVE', 'INACTIVE', 'DISCONTINUED'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_PRODUCT_TYPE
  CHECK (PRODUCT_TYPE IN ('MURABAHA', 'IJARA', 'ISTISNA', 'MUSHARAKA', 'MUDARABA', 'TAWARRUQ', 'SALAM'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (PRODUCT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (PRODUCT_CODE)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE LOGIN_HISTORY
(
  LOGIN_ID        NUMBER GENERATED ALWAYS AS IDENTITY ( START WITH 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 NOCYCLE CACHE 20 NOORDER NOKEEP NOSCALE) NOT NULL,
  USER_ID         NUMBER                        NOT NULL,
  LOGIN_DATE      TIMESTAMP(6)                  DEFAULT SYSTIMESTAMP          NOT NULL,
  LOGOUT_DATE     TIMESTAMP(6),
  IP_ADDRESS      VARCHAR2(50 BYTE),
  USER_AGENT      VARCHAR2(500 BYTE),
  LOGIN_STATUS    VARCHAR2(20 BYTE)             NOT NULL,
  FAILURE_REASON  VARCHAR2(200 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE LOGIN_HISTORY ADD (
  CONSTRAINT CHK_LOGIN_STATUS
  CHECK (LOGIN_STATUS IN ('SUCCESS', 'FAILED', 'LOCKED'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (LOGIN_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE MEETING_ATTENDANCE
(
  MEETING_ID         NUMBER,
  USER_ID            NUMBER,
  ATTENDANCE_STATUS  VARCHAR2(20 BYTE)          DEFAULT 'PENDING'             NOT NULL,
  NOTES              VARCHAR2(500 BYTE),
  RECORDED_BY        NUMBER                     NOT NULL,
  RECORDED_DATE      TIMESTAMP(6)               DEFAULT SYSTIMESTAMP          NOT NULL
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE MEETING_ATTENDANCE ADD (
  CONSTRAINT CHK_ATTENDANCE_STATUS
  CHECK (ATTENDANCE_STATUS IN ('PENDING', 'PRESENT', 'ABSENT', 'EXCUSED'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (MEETING_ID, USER_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE NOTIFICATIONS
(
  NOTIFICATION_ID     NUMBER,
  USER_ID             NUMBER                    NOT NULL,
  NOTIFICATION_TYPE   VARCHAR2(50 BYTE)         NOT NULL,
  NOTIFICATION_TITLE  VARCHAR2(200 BYTE)        NOT NULL,
  NOTIFICATION_TEXT   VARCHAR2(4000 BYTE)       NOT NULL,
  REFERENCE_TYPE      VARCHAR2(50 BYTE),
  REFERENCE_ID        NUMBER,
  IS_READ             VARCHAR2(1 BYTE)          DEFAULT 'N'                   NOT NULL,
  READ_DATE           TIMESTAMP(6),
  CREATION_DATE       TIMESTAMP(6)              DEFAULT SYSTIMESTAMP          NOT NULL,
  EXPIRY_DATE         TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE NOTIFICATIONS ADD (
  CONSTRAINT CHK_IS_READ
  CHECK (IS_READ IN ('Y', 'N'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_NOTIFICATION_TYPE
  CHECK (NOTIFICATION_TYPE IN ('TASK', 'ALERT', 'REMINDER', 'SYSTEM', 'INFO'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_REFERENCE_TYPE_NOTIF
  CHECK (REFERENCE_TYPE IN ('FINANCING_REQUEST', 'FINANCING_CONTRACT', 'INSTALLMENT', 'PAYMENT', 'TASK', 'MEETING', 'CUSTOMER', 'OTHER'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (NOTIFICATION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE PAYMENTS
(
  PAYMENT_ID           NUMBER,
  FINANCING_ID         NUMBER                   NOT NULL,
  INSTALLMENT_ID       NUMBER,
  PAYMENT_AMOUNT       NUMBER                   NOT NULL,
  PAYMENT_METHOD       VARCHAR2(50 BYTE)        NOT NULL,
  PAYMENT_DATE         DATE                     NOT NULL,
  PAYMENT_STATUS       VARCHAR2(20 BYTE)        DEFAULT 'PENDING'             NOT NULL,
  REFERENCE_NUMBER     VARCHAR2(100 BYTE),
  NOTES                VARCHAR2(500 BYTE),
  CREATED_BY           NUMBER                   NOT NULL,
  CREATION_DATE        TIMESTAMP(6)             DEFAULT SYSTIMESTAMP          NOT NULL,
  CANCELLATION_REASON  VARCHAR2(500 BYTE),
  CANCELLED_BY         NUMBER,
  CANCELLATION_DATE    TIMESTAMP(6),
  PAYMENT_TYPE         VARCHAR2(101 BYTE),
  PAYMENT_REFERENCE    VARCHAR2(101 BYTE),
  PROFIT_AMOUNT        NUMBER,
  FEE_AMOUNT           NUMBER,
  LATE_PAYMENT_FEES    NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE PAYMENTS ADD (
  CONSTRAINT CHK_PAYMENT_METHOD
  CHECK (PAYMENT_METHOD IN ('CASH', 'BANK_TRANSFER', 'CHEQUE', 'DIRECT_DEBIT', 'CREDIT_CARD', 'DEBIT_CARD'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_PAYMENT_STATUS
  CHECK (PAYMENT_STATUS IN ('PENDING', 'COMPLETED', 'FAILED', 'CANCELLED'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (PAYMENT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE PERFORMANCE_METRICS
(
  METRIC_ID          NUMBER,
  METRIC_NAME        VARCHAR2(151 BYTE),
  METRIC_VALUE       NUMBER,
  METRIC_PERIOD      VARCHAR2(151 BYTE),
  PERIOD_START_DATE  DATE,
  PERIOD_END_DATE    DATE,
  CREATED_BY         NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE PERMISSIONS
(
  PERMISSION_ID    NUMBER,
  PERMISSION_CODE  VARCHAR2(100 BYTE)           NOT NULL,
  DESCRIPTION      VARCHAR2(200 BYTE),
  MODULE           VARCHAR2(50 BYTE)            NOT NULL,
  CREATION_DATE    TIMESTAMP(6)                 DEFAULT SYSTIMESTAMP          NOT NULL,
  PERMISSION_NAME  VARCHAR2(101 BYTE),
  CREATED_BY       NUMBER,
  UPDATED_DATE     DATE,
  UPDATED_BY       NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE PERMISSIONS ADD (
  PRIMARY KEY
  (PERMISSION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (PERMISSION_CODE)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE PRODUCT_CONDITIONS
(
  CONDITION_ID           NUMBER,
  PRODUCT_ID             NUMBER                 NOT NULL,
  CONDITION_NAME         VARCHAR2(100 BYTE)     NOT NULL,
  CONDITION_DESCRIPTION  CLOB,
  IS_MANDATORY           NUMBER(1)              DEFAULT 0,
  CREATED_DATE           DATE                   DEFAULT SYSDATE,
  CREATED_BY             VARCHAR2(50 BYTE),
  UPDATED_DATE           DATE,
  UPDATED_BY             VARCHAR2(50 BYTE)
)
LOB (CONDITION_DESCRIPTION) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE PRODUCT_CONDITIONS ADD (
  PRIMARY KEY
  (CONDITION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE PRODUCT_REQUIRED_DOCUMENTS
(
  PRODUCT_ID     NUMBER                         NOT NULL,
  DOCUMENT_TYPE  VARCHAR2(50 BYTE)              NOT NULL,
  IS_MANDATORY   NUMBER(1)                      DEFAULT 1                     NOT NULL,
  DESCRIPTION    VARCHAR2(500 BYTE),
  CREATED_DATE   TIMESTAMP(6)                   DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY     VARCHAR2(50 BYTE)              NOT NULL,
  UPDATED_DATE   TIMESTAMP(6),
  UPDATED_BY     VARCHAR2(50 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE PRODUCT_REQUIRED_DOCUMENTS IS 'جدول يحدد المستندات المطلوبة لكل منتج تمويلي';


ALTER TABLE PRODUCT_REQUIRED_DOCUMENTS ADD (
  CONSTRAINT CHK_PROD_DOC_MANDATORY
  CHECK (IS_MANDATORY IN (0, 1))
  ENABLE VALIDATE
,  PRIMARY KEY
  (PRODUCT_ID, DOCUMENT_TYPE)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE PRODUCT_STAGES
(
  STAGE_ID      NUMBER,
  PRODUCT_ID    NUMBER                          NOT NULL,
  STAGE_NAME    VARCHAR2(100 BYTE)              NOT NULL,
  STAGE_ORDER   NUMBER                          NOT NULL,
  DESCRIPTION   CLOB,
  CREATED_DATE  DATE                            DEFAULT SYSDATE,
  CREATED_BY    VARCHAR2(50 BYTE),
  UPDATED_DATE  DATE,
  UPDATED_BY    VARCHAR2(50 BYTE)
)
LOB (DESCRIPTION) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE PRODUCT_STAGES ADD (
  PRIMARY KEY
  (STAGE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE PROVISIONS
(
  PROVISION_ID       NUMBER,
  REQUEST_ID         NUMBER                     NOT NULL,
  CLASSIFICATION_ID  NUMBER                     NOT NULL,
  PROVISION_AMOUNT   NUMBER                     NOT NULL,
  CALCULATION_DATE   DATE                       DEFAULT SYSDATE,
  CREATED_DATE       DATE                       DEFAULT SYSDATE,
  CREATED_BY         VARCHAR2(50 BYTE),
  UPDATED_DATE       DATE,
  UPDATED_BY         VARCHAR2(50 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE PROVISIONS ADD (
  PRIMARY KEY
  (PROVISION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE REMINDER_MESSAGES
(
  MESSAGE_ID       NUMBER,
  CUSTOMER_ID      NUMBER                       NOT NULL,
  REQUEST_ID       NUMBER                       NOT NULL,
  INSTALLMENT_ID   NUMBER,
  MESSAGE_TYPE     VARCHAR2(50 BYTE)            NOT NULL,
  MESSAGE_CONTENT  CLOB,
  SEND_DATE        DATE                         DEFAULT SYSDATE,
  DELIVERY_STATUS  VARCHAR2(50 BYTE),
  CREATED_DATE     DATE                         DEFAULT SYSDATE,
  CREATED_BY       VARCHAR2(50 BYTE),
  UPDATED_DATE     DATE,
  UPDATED_BY       VARCHAR2(50 BYTE),
  REMINDER_TEXT    VARCHAR2(4000 BYTE),
  REMINDER_TYPE    VARCHAR2(31 BYTE)
)
LOB (MESSAGE_CONTENT) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE REMINDER_MESSAGES ADD (
  PRIMARY KEY
  (MESSAGE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE REMINDER_MESSAGES_NEW
(
  REMINDER_ID      NUMBER,
  CUSTOMER_ID      NUMBER                       NOT NULL,
  FINANCING_ID     NUMBER,
  INSTALLMENT_ID   NUMBER,
  REMINDER_TYPE    VARCHAR2(50 BYTE)            NOT NULL,
  MESSAGE_TEXT     VARCHAR2(4000 BYTE)          NOT NULL,
  DELIVERY_METHOD  VARCHAR2(50 BYTE)            NOT NULL,
  DELIVERY_STATUS  VARCHAR2(20 BYTE)            DEFAULT 'PENDING'             NOT NULL,
  SCHEDULED_DATE   TIMESTAMP(6)                 NOT NULL,
  SENT_DATE        TIMESTAMP(6),
  CREATED_BY       NUMBER                       NOT NULL,
  CREATION_DATE    TIMESTAMP(6)                 DEFAULT SYSTIMESTAMP          NOT NULL
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE REMINDER_MESSAGES_NEW ADD (
  CONSTRAINT CHK_DELIVERY_METHOD
  CHECK (DELIVERY_METHOD IN ('SMS', 'EMAIL', 'PUSH_NOTIFICATION', 'LETTER', 'PHONE_CALL'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_DELIVERY_STATUS
  CHECK (DELIVERY_STATUS IN ('PENDING', 'SENT', 'DELIVERED', 'FAILED', 'CANCELLED'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_REMINDER_TYPE
  CHECK (REMINDER_TYPE IN ('UPCOMING_INSTALLMENT', 'OVERDUE_INSTALLMENT', 'CONTRACT_EXPIRY', 'DOCUMENT_EXPIRY', 'GENERAL'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (REMINDER_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE REPORTS
(
  REPORT_ID           NUMBER,
  REPORT_NAME         VARCHAR2(100 BYTE)        NOT NULL,
  REPORT_DESCRIPTION  VARCHAR2(500 BYTE),
  REPORT_TYPE         VARCHAR2(50 BYTE)         NOT NULL,
  REPORT_QUERY        CLOB,
  REPORT_PARAMETERS   VARCHAR2(4000 BYTE),
  REPORT_FORMAT       VARCHAR2(20 BYTE)         DEFAULT 'PDF'                 NOT NULL,
  IS_ACTIVE           VARCHAR2(1 BYTE)          DEFAULT 'Y'                   NOT NULL,
  CREATED_BY          NUMBER                    NOT NULL,
  CREATION_DATE       TIMESTAMP(6)              DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY     NUMBER,
  LAST_UPDATE_DATE    TIMESTAMP(6),
  START_DATE          DATE,
  END_DATE            DATE
)
LOB (REPORT_QUERY) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING
      STORAGE    (
                  INITIAL          104K
                  NEXT             1M
                  MINEXTENTS       1
                  MAXEXTENTS       UNLIMITED
                  PCTINCREASE      0
                  BUFFER_POOL      DEFAULT
                 ))
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE REPORTS ADD (
  CONSTRAINT CHK_REPORT_ACTIVE
  CHECK (IS_ACTIVE IN ('Y', 'N'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_REPORT_FORMAT
  CHECK (REPORT_FORMAT IN ('PDF', 'EXCEL', 'CSV', 'HTML', 'TEXT'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_REPORT_TYPE
  CHECK (REPORT_TYPE IN ('FINANCIAL', 'OPERATIONAL', 'CUSTOMER', 'REGULATORY', 'MANAGEMENT', 'AUDIT'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (REPORT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE REQUEST_COLLATERALS
(
  REQUEST_COLLATERAL_ID  NUMBER,
  REQUEST_ID             NUMBER                 NOT NULL,
  COLLATERAL_ID          NUMBER                 NOT NULL,
  COVERAGE_RATIO         NUMBER,
  CREATED_DATE           DATE                   DEFAULT SYSDATE,
  CREATED_BY             VARCHAR2(50 BYTE),
  UPDATED_DATE           DATE,
  UPDATED_BY             VARCHAR2(50 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE REQUEST_COLLATERALS ADD (
  PRIMARY KEY
  (REQUEST_COLLATERAL_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE REQUEST_DOCUMENTS
(
  DOCUMENT_ID      NUMBER,
  REQUEST_ID       NUMBER                       NOT NULL,
  DOCUMENT_TYPE    VARCHAR2(50 BYTE)            NOT NULL,
  DOCUMENT_NUMBER  VARCHAR2(100 BYTE),
  ISSUE_DATE       DATE,
  EXPIRY_DATE      DATE,
  DOCUMENT_PATH    VARCHAR2(500 BYTE),
  DOCUMENT_STATUS  VARCHAR2(20 BYTE)            DEFAULT 'ACTIVE'              NOT NULL,
  NOTES            CLOB,
  CREATED_DATE     TIMESTAMP(6)                 DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY       VARCHAR2(50 BYTE)            NOT NULL,
  UPDATED_DATE     TIMESTAMP(6),
  UPDATED_BY       VARCHAR2(50 BYTE)
)
LOB (NOTES) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE REQUEST_DOCUMENTS IS 'جدول يخزن المستندات المتعلقة بطلبات التمويل';


ALTER TABLE REQUEST_DOCUMENTS ADD (
  CONSTRAINT CHK_REQ_DOC_STATUS
  CHECK (DOCUMENT_STATUS IN ('ACTIVE', 'EXPIRED', 'REJECTED', 'PENDING', 'ARCHIVED'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (DOCUMENT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE REQUEST_STAGES
(
  STAGE_ID            NUMBER,
  STAGE_NAME          VARCHAR2(50 BYTE)         NOT NULL,
  STAGE_DESCRIPTION   VARCHAR2(500 BYTE),
  STAGE_ORDER         NUMBER                    NOT NULL,
  MAX_DAYS_IN_STAGE   NUMBER                    NOT NULL,
  REQUIRED_ACTIONS    VARCHAR2(4000 BYTE),
  REQUIRED_DOCUMENTS  VARCHAR2(4000 BYTE),
  NEXT_STAGES         VARCHAR2(200 BYTE),
  PREVIOUS_STAGES     VARCHAR2(200 BYTE),
  IS_ACTIVE           NUMBER(1)                 DEFAULT 1                     NOT NULL,
  CREATED_BY          NUMBER,
  CREATION_DATE       DATE                      DEFAULT SYSDATE               NOT NULL,
  LAST_UPDATED_BY     NUMBER,
  LAST_UPDATE_DATE    DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE REQUEST_STAGES IS 'جدول لتخزين مراحل طلبات التمويل وخصائصها';

COMMENT ON COLUMN REQUEST_STAGES.STAGE_ID IS 'المعرف الفريد للمرحلة';

COMMENT ON COLUMN REQUEST_STAGES.STAGE_NAME IS 'اسم المرحلة (مثل: تقديم الطلب، التحقق من الأهلية، الموافقة، إلخ)';

COMMENT ON COLUMN REQUEST_STAGES.STAGE_ORDER IS 'ترتيب المرحلة في سير العمل';

COMMENT ON COLUMN REQUEST_STAGES.MAX_DAYS_IN_STAGE IS 'الحد الأقصى لعدد الأيام المسموح بها في هذه المرحلة (SLA)';

COMMENT ON COLUMN REQUEST_STAGES.REQUIRED_ACTIONS IS 'الإجراءات المطلوبة في هذه المرحلة';

COMMENT ON COLUMN REQUEST_STAGES.REQUIRED_DOCUMENTS IS 'المستندات المطلوبة في هذه المرحلة';

COMMENT ON COLUMN REQUEST_STAGES.NEXT_STAGES IS 'المراحل المحتملة التالية (مفصولة بفواصل)';

COMMENT ON COLUMN REQUEST_STAGES.PREVIOUS_STAGES IS 'المراحل السابقة المحتملة (مفصولة بفواصل)';

COMMENT ON COLUMN REQUEST_STAGES.IS_ACTIVE IS 'مؤشر ما إذا كانت المرحلة نشطة (1) أو غير نشطة (0)';


CREATE UNIQUE INDEX IDX_STAGE_NAME ON REQUEST_STAGES
(STAGE_NAME)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

ALTER TABLE REQUEST_STAGES ADD (
  PRIMARY KEY
  (STAGE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE REQUEST_STATUS_HISTORY
(
  HISTORY_ID     NUMBER,
  REQUEST_ID     NUMBER                         NOT NULL,
  OLD_STATUS     VARCHAR2(50 BYTE),
  NEW_STATUS     VARCHAR2(50 BYTE)              NOT NULL,
  CHANGE_REASON  VARCHAR2(500 BYTE),
  CHANGE_DATE    TIMESTAMP(6)                   DEFAULT SYSTIMESTAMP          NOT NULL,
  CHANGED_BY     NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE REQUEST_STATUS_HISTORY ADD (
  PRIMARY KEY
  (HISTORY_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE ROLES
(
  ROLE_ID           NUMBER,
  ROLE_NAME         VARCHAR2(50 BYTE)           NOT NULL,
  DESCRIPTION       VARCHAR2(200 BYTE),
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY        NUMBER,
  LAST_UPDATE_DATE  TIMESTAMP(6),
  LAST_UPDATED_BY   NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE ROLES ADD (
  PRIMARY KEY
  (ROLE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (ROLE_NAME)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE ROLE_PERMISSIONS
(
  ROLE_ID        NUMBER,
  PERMISSION_ID  NUMBER,
  GRANTED_DATE   TIMESTAMP(6)                   DEFAULT SYSTIMESTAMP          NOT NULL,
  GRANTED_BY     NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE ROLE_PERMISSIONS ADD (
  PRIMARY KEY
  (ROLE_ID, PERMISSION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE SCHEDULED_JOBS
(
  JOB_ID            NUMBER,
  JOB_NAME          VARCHAR2(100 BYTE)          NOT NULL,
  JOB_DESCRIPTION   VARCHAR2(500 BYTE),
  JOB_TYPE          VARCHAR2(50 BYTE)           NOT NULL,
  CRON_EXPRESSION   VARCHAR2(100 BYTE),
  NEXT_RUN_DATE     TIMESTAMP(6),
  LAST_RUN_DATE     TIMESTAMP(6),
  LAST_RUN_STATUS   VARCHAR2(20 BYTE),
  LAST_RUN_MESSAGE  VARCHAR2(4000 BYTE),
  IS_ACTIVE         VARCHAR2(1 BYTE)            DEFAULT 'Y'                   NOT NULL,
  CREATED_BY        NUMBER                      NOT NULL,
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY   NUMBER,
  LAST_UPDATE_DATE  TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE SCHEDULED_JOBS ADD (
  CONSTRAINT CHK_JOB_ACTIVE
  CHECK (IS_ACTIVE IN ('Y', 'N'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_JOB_STATUS
  CHECK (LAST_RUN_STATUS IN ('SUCCESS', 'FAILED', 'RUNNING', 'CANCELLED', 'NOT_RUN'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_JOB_TYPE
  CHECK (JOB_TYPE IN ('REMINDER', 'REPORT', 'DATA_PROCESSING', 'SYSTEM_MAINTENANCE', 'INSTALLMENT_UPDATE'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (JOB_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE SYSTEM_ERRORS
(
  ERROR_CODE      VARCHAR2(101 BYTE),
  ERROR_MESSAGE   VARCHAR2(101 BYTE),
  SOURCE          VARCHAR2(101 BYTE),
  STACK_TRACE     VARCHAR2(101 BYTE),
  USER_ID         NUMBER,
  REFERENCE_ID    NUMBER,
  REFERENCE_TYPE  VARCHAR2(101 BYTE),
  ERROR_TIME      DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE SYSTEM_EVENTS
(
  EVENT_TYPE         VARCHAR2(101 BYTE),
  EVENT_DESCRIPTION  VARCHAR2(101 BYTE),
  SOURCE             VARCHAR2(101 BYTE),
  USER_ID            NUMBER,
  REFERENCE_ID       NUMBER,
  REFERENCE_TYPE     VARCHAR2(101 BYTE),
  EVENT_TIME         DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE SYSTEM_LOGS
(
  LOG_ID          NUMBER,
  LOG_TYPE        VARCHAR2(50 BYTE)             NOT NULL,
  LOG_MESSAGE     VARCHAR2(4000 BYTE)           NOT NULL,
  USER_ID         NUMBER,
  IP_ADDRESS      VARCHAR2(50 BYTE),
  REFERENCE_TYPE  VARCHAR2(50 BYTE),
  REFERENCE_ID    NUMBER,
  CREATION_DATE   TIMESTAMP(6)                  DEFAULT SYSTIMESTAMP          NOT NULL,
  LOG_DETAILS     VARCHAR2(1001 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE SYSTEM_LOGS ADD (
  CONSTRAINT CHK_LOG_TYPE
  CHECK (LOG_TYPE IN ('INFO', 'WARNING', 'ERROR', 'SECURITY', 'AUDIT', 'FINANCING', 'PAYMENT', 'SYSTEM'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (LOG_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE SYSTEM_LOGS_NEW
(
  LOG_ID       NUMBER,
  LOG_TYPE     VARCHAR2(50 BYTE)                NOT NULL,
  LOG_MESSAGE  VARCHAR2(4000 BYTE)              NOT NULL,
  USER_ID      NUMBER,
  LOG_DATE     TIMESTAMP(6)                     DEFAULT SYSTIMESTAMP,
  IP_ADDRESS   VARCHAR2(50 BYTE),
  USER_AGENT   VARCHAR2(500 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE SYSTEM_LOGS_NEW ADD (
  PRIMARY KEY
  (LOG_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE SYSTEM_NOTIFICATIONS
(
  NOTIFICATION_ID       NUMBER,
  NOTIFICATION_TYPE     VARCHAR2(50 BYTE)       NOT NULL,
  NOTIFICATION_TITLE    VARCHAR2(200 BYTE)      NOT NULL,
  NOTIFICATION_MESSAGE  VARCHAR2(4000 BYTE)     NOT NULL,
  START_DATE            DATE                    NOT NULL,
  END_DATE              DATE,
  TARGET_USERS          VARCHAR2(1000 BYTE),
  TARGET_ROLES          VARCHAR2(1000 BYTE),
  IS_ACTIVE             NUMBER(1)               DEFAULT 1                     NOT NULL,
  CREATED_BY            NUMBER,
  CREATION_DATE         DATE                    DEFAULT SYSDATE               NOT NULL,
  LAST_UPDATED_BY       NUMBER,
  LAST_UPDATE_DATE      DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE SYSTEM_NOTIFICATIONS IS 'جدول لتخزين إشعارات النظام العامة في نظام التمويل الإسلامي';

COMMENT ON COLUMN SYSTEM_NOTIFICATIONS.NOTIFICATION_ID IS 'المعرف الفريد للإشعار';

COMMENT ON COLUMN SYSTEM_NOTIFICATIONS.NOTIFICATION_TYPE IS 'نوع الإشعار (مثل: إعلان، تحديث نظام، صيانة، إلخ)';

COMMENT ON COLUMN SYSTEM_NOTIFICATIONS.START_DATE IS 'تاريخ بدء عرض الإشعار';

COMMENT ON COLUMN SYSTEM_NOTIFICATIONS.END_DATE IS 'تاريخ انتهاء عرض الإشعار (اختياري)';

COMMENT ON COLUMN SYSTEM_NOTIFICATIONS.TARGET_USERS IS 'قائمة معرفات المستخدمين المستهدفين (NULL = الكل)';

COMMENT ON COLUMN SYSTEM_NOTIFICATIONS.TARGET_ROLES IS 'قائمة الأدوار المستهدفة (NULL = الكل)';

COMMENT ON COLUMN SYSTEM_NOTIFICATIONS.IS_ACTIVE IS 'مؤشر ما إذا كان الإشعار نشطًا (1) أو غير نشط (0)';


ALTER TABLE SYSTEM_NOTIFICATIONS ADD (
  PRIMARY KEY
  (NOTIFICATION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE SYSTEM_SETTINGS
(
  SETTING_KEY          VARCHAR2(100 BYTE),
  SETTING_VALUE        VARCHAR2(4000 BYTE)      NOT NULL,
  SETTING_DESCRIPTION  VARCHAR2(500 BYTE),
  SETTING_GROUP        VARCHAR2(100 BYTE),
  IS_EDITABLE          VARCHAR2(1 BYTE)         DEFAULT 'Y'                   NOT NULL,
  LAST_UPDATED_BY      NUMBER,
  LAST_UPDATE_DATE     TIMESTAMP(6)             DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_DATE         DATE,
  CREATED_BY           NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE SYSTEM_SETTINGS ADD (
  CONSTRAINT CHK_SETTING_EDITABLE
  CHECK (IS_EDITABLE IN ('Y', 'N'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (SETTING_KEY)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE TASKS
(
  TASK_ID           NUMBER,
  TASK_TITLE        VARCHAR2(200 BYTE)          NOT NULL,
  TASK_DESCRIPTION  VARCHAR2(4000 BYTE),
  ASSIGNED_TO       NUMBER                      NOT NULL,
  ASSIGNED_BY       NUMBER                      NOT NULL,
  REFERENCE_TYPE    VARCHAR2(50 BYTE),
  REFERENCE_ID      NUMBER,
  PRIORITY          VARCHAR2(20 BYTE)           DEFAULT 'MEDIUM'              NOT NULL,
  DUE_DATE          TIMESTAMP(6),
  TASK_STATUS       VARCHAR2(20 BYTE)           DEFAULT 'PENDING'             NOT NULL,
  COMPLETION_DATE   TIMESTAMP(6),
  COMPLETION_NOTES  VARCHAR2(1000 BYTE),
  CREATION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATE_DATE  TIMESTAMP(6),
  CREATED_BY        NUMBER,
  UPDATED_BY        NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE TASKS ADD (
  CONSTRAINT CHK_REFERENCE_TYPE_TASK
  CHECK (REFERENCE_TYPE IN ('FINANCING_REQUEST', 'FINANCING_CONTRACT', 'CUSTOMER', 'COLLATERAL', 'PAYMENT', 'OTHER'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_TASK_PRIORITY
  CHECK (PRIORITY IN ('LOW', 'MEDIUM', 'HIGH', 'URGENT'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_TASK_STATUS
  CHECK (TASK_STATUS IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'OVERDUE'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (TASK_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE TASK_REASSIGNMENTS
(
  TASK_ID              NUMBER,
  OLD_ASSIGNED_TO      NUMBER,
  NEW_ASSIGNED_TO      NUMBER,
  REASSIGNMENT_REASON  VARCHAR2(101 BYTE),
  REASSIGNED_BY        NUMBER,
  REASSIGNMENT_DATE    DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE TRANSACTION_LOG
(
  LOG_ID            NUMBER GENERATED ALWAYS AS IDENTITY ( START WITH 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 NOCYCLE CACHE 20 NOORDER NOKEEP NOSCALE) NOT NULL,
  CONTRACT_ID       NUMBER,
  TRANSACTION_TYPE  VARCHAR2(50 BYTE),
  DESCRIPTION       VARCHAR2(500 BYTE),
  TRANSACTION_DATE  DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE TRANSACTION_LOG ADD (
  PRIMARY KEY
  (LOG_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE USERS
(
  USER_ID               NUMBER,
  USERNAME              VARCHAR2(50 BYTE)       NOT NULL,
  PASSWORD              VARCHAR2(100 BYTE)      NOT NULL,
  FULL_NAME             VARCHAR2(100 BYTE)      NOT NULL,
  EMAIL                 VARCHAR2(100 BYTE)      NOT NULL,
  MOBILE_NUMBER         VARCHAR2(20 BYTE),
  POSITION              VARCHAR2(100 BYTE),
  DEPARTMENT            VARCHAR2(100 BYTE),
  USER_STATUS           VARCHAR2(20 BYTE)       DEFAULT 'ACTIVE'              NOT NULL,
  LAST_LOGIN_DATE       TIMESTAMP(6),
  PASSWORD_CHANGE_DATE  DATE,
  CREATION_DATE         TIMESTAMP(6)            DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY            NUMBER,
  LAST_UPDATE_DATE      TIMESTAMP(6),
  LAST_UPDATED_BY       NUMBER,
  MANAGER_ID            NUMBER,
  USER_ROLE             NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE USERS ADD (
  CONSTRAINT CHK_USER_STATUS
  CHECK (USER_STATUS IN ('ACTIVE', 'INACTIVE', 'LOCKED', 'PENDING'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (USER_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (USERNAME)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (EMAIL)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE USERS_NEW
(
  USER_ID          NUMBER,
  USERNAME         VARCHAR2(50 BYTE)            NOT NULL,
  PASSWORD         VARCHAR2(100 BYTE)           NOT NULL,
  FULL_NAME        VARCHAR2(100 BYTE)           NOT NULL,
  EMAIL            VARCHAR2(100 BYTE),
  MOBILE_NUMBER    VARCHAR2(20 BYTE),
  USER_ROLE        VARCHAR2(50 BYTE)            NOT NULL,
  DEPARTMENT       VARCHAR2(50 BYTE),
  STATUS           VARCHAR2(20 BYTE)            DEFAULT 'ACTIVE',
  LAST_LOGIN_DATE  TIMESTAMP(6),
  CREATED_BY       NUMBER,
  CREATION_DATE    TIMESTAMP(6)                 DEFAULT SYSTIMESTAMP,
  UPDATED_BY       NUMBER,
  UPDATE_DATE      TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE USERS_NEW ADD (
  PRIMARY KEY
  (USER_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (USERNAME)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (EMAIL)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE USER_ACTIVITIES
(
  USER_ID               NUMBER,
  ACTIVITY_TYPE         VARCHAR2(101 BYTE),
  ACTIVITY_DESCRIPTION  VARCHAR2(101 BYTE),
  IP_ADDRESS            VARCHAR2(101 BYTE),
  REFERENCE_ID          NUMBER,
  REFERENCE_TYPE        VARCHAR2(101 BYTE),
  ACTIVITY_TIME         DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE USER_NOTIFICATIONS
(
  NOTIFICATION_ID       NUMBER,
  USER_ID               NUMBER                  NOT NULL,
  NOTIFICATION_TYPE     VARCHAR2(50 BYTE)       NOT NULL,
  NOTIFICATION_TITLE    VARCHAR2(200 BYTE),
  NOTIFICATION_MESSAGE  VARCHAR2(4000 BYTE)     NOT NULL,
  RELATED_ENTITY_TYPE   VARCHAR2(50 BYTE),
  RELATED_ENTITY_ID     NUMBER,
  NOTIFICATION_DATE     DATE                    DEFAULT SYSDATE               NOT NULL,
  IS_READ               NUMBER(1)               DEFAULT 0                     NOT NULL,
  READ_DATE             DATE,
  CREATED_BY            NUMBER,
  CREATION_DATE         DATE                    DEFAULT SYSDATE,
  LAST_UPDATED_BY       NUMBER,
  LAST_UPDATE_DATE      DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE USER_NOTIFICATIONS IS 'جدول لتخزين إشعارات المستخدمين في نظام التمويل الإسلامي';

COMMENT ON COLUMN USER_NOTIFICATIONS.NOTIFICATION_ID IS 'المعرف الفريد للإشعار';

COMMENT ON COLUMN USER_NOTIFICATIONS.USER_ID IS 'معرف المستخدم المرسل إليه الإشعار';

COMMENT ON COLUMN USER_NOTIFICATIONS.NOTIFICATION_TYPE IS 'نوع الإشعار (مثل: تذكير، تنبيه، إلخ)';

COMMENT ON COLUMN USER_NOTIFICATIONS.IS_READ IS 'مؤشر ما إذا كان الإشعار مقروءًا (0=غير مقروء، 1=مقروء)';


ALTER TABLE USER_NOTIFICATIONS ADD (
  PRIMARY KEY
  (NOTIFICATION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE USER_PERMISSIONS
(
  USER_ID        NUMBER,
  PERMISSION_ID  NUMBER,
  GRANTED_BY     NUMBER,
  GRANTED_DATE   DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE USER_ROLES
(
  USER_ID        NUMBER,
  ROLE_ID        NUMBER,
  ASSIGNED_DATE  TIMESTAMP(6)                   DEFAULT SYSTIMESTAMP          NOT NULL,
  ASSIGNED_BY    NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE USER_ROLES ADD (
  PRIMARY KEY
  (USER_ID, ROLE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                INITIAL          64K
                NEXT             1M
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE WORKFLOWS
(
  WORKFLOW_ID       NUMBER,
  WORKFLOW_TYPE     VARCHAR2(101 BYTE),
  REFERENCE_TYPE    VARCHAR2(101 BYTE),
  REFERENCE_ID      NUMBER,
  WORKFLOW_STATUS   VARCHAR2(51 BYTE),
  PRIORITY          VARCHAR2(51 BYTE),
  CREATED_BY        NUMBER,
  CREATION_DATE     DATE,
  LAST_UPDATE_BY    NUMBER,
  LAST_UPDATE_DATE  DATE,
  COMPLETION_DATE   DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE WORKFLOW_HISTORY
(
  HISTORY_ID   NUMBER,
  WORKFLOW_ID  NUMBER,
  ACTION_TYPE  VARCHAR2(101 BYTE),
  ACTION_BY    NUMBER,
  ACTION_DATE  DATE,
  COMMENTS     VARCHAR2(301 BYTE),
  TASK_ID      NUMBER
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


CREATE TABLE WORKFLOW_TASKS
(
  TASK_ID           NUMBER,
  WORKFLOW_ID       NUMBER,
  TASK_TYPE         VARCHAR2(101 BYTE),
  TASK_NAME         VARCHAR2(101 BYTE),
  TASK_DESCRIPTION  VARCHAR2(101 BYTE),
  ASSIGNED_TO       NUMBER,
  DUE_DATE          DATE,
  SEQUENCE_NUMBER   NUMBER,
  TASK_STATUS       VARCHAR2(31 BYTE),
  CREATED_BY        NUMBER,
  CREATION_DATE     DATE,
  LAST_UPDATE_BY    NUMBER,
  LAST_UPDATE_DATE  DATE,
  COMPLETION_DATE   DATE
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


-- Sequence ISEQ$$_167590 is created automatically by Oracle for use with an Identity column


-- Sequence ISEQ$$_167593 is created automatically by Oracle for use with an Identity column


-- Sequence ISEQ$$_167596 is created automatically by Oracle for use with an Identity column


-- Sequence ISEQ$$_167599 is created automatically by Oracle for use with an Identity column


-- Sequence ISEQ$$_168015 is created automatically by Oracle for use with an Identity column


-- Sequence ISEQ$$_168018 is created automatically by Oracle for use with an Identity column


CREATE INDEX IDX_CCR_CUSTOMER_ID ON CUSTOMER_CREDIT_RATINGS
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CCR_RATING_DATE ON CUSTOMER_CREDIT_RATINGS
(RATING_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COMMITTEE_MEMBER_COMMITTEE ON COMMITTEE_MEMBERS
(COMMITTEE_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COMMITTEE_MEMBER_USER ON COMMITTEE_MEMBERS
(USER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COMMITTEE_STATUS ON COMMITTEES
(STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COMMITTEE_TYPE ON COMMITTEES
(COMMITTEE_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COND_PROD ON PRODUCT_CONDITIONS
(PRODUCT_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CONTACT_PREF_CUSTOMER ON CUSTOMER_CONTACT_PREFERENCES
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CONTACT_PREF_ENABLED ON CUSTOMER_CONTACT_PREFERENCES
(IS_ENABLED)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CONTACT_PREF_METHOD ON CUSTOMER_CONTACT_PREFERENCES
(CONTACT_METHOD)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUSTOMER_NOTE_CREATED_BY ON CUSTOMER_NOTES
(CREATED_BY)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUSTOMER_NOTE_CUSTOMER ON CUSTOMER_NOTES
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUSTOMER_NOTE_FOLLOWUP ON CUSTOMER_NOTES
(FOLLOW_UP_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUSTOMER_NOTE_IMPORTANCE ON CUSTOMER_NOTES
(IMPORTANCE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUSTOMER_NOTE_STATUS ON CUSTOMER_NOTES
(STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUSTOMER_NOTE_TYPE ON CUSTOMER_NOTES
(NOTE_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUST_DOC_CUSTOMER ON CUSTOMER_DOCUMENTS
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUST_DOC_EXPIRY ON CUSTOMER_DOCUMENTS
(EXPIRY_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUST_DOC_STATUS ON CUSTOMER_DOCUMENTS
(DOCUMENT_STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUST_DOC_TYPE ON CUSTOMER_DOCUMENTS
(DOCUMENT_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUST_NOTIF_CUST_ID ON CUSTOMER_NOTIFICATIONS
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUST_NOTIF_DATE ON CUSTOMER_NOTIFICATIONS
(NOTIFICATION_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUST_NOTIF_IS_READ ON CUSTOMER_NOTIFICATIONS
(IS_READ)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_CUST_NOTIF_TYPE ON CUSTOMER_NOTIFICATIONS
(NOTIFICATION_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_DOCUMENT_COLLATERAL ON COLLATERAL_DOCUMENTS_NEW
(COLLATERAL_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_DOCUMENT_STATUS ON COLLATERAL_DOCUMENTS_NEW
(STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_DOCUMENT_TYPE ON COLLATERAL_DOCUMENTS_NEW
(DOCUMENT_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_FEE_PROD ON FEES_COMMISSIONS
(PRODUCT_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_FEE_STAGE ON FEES_COMMISSIONS
(STAGE_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_FINANCING_COLLATERAL_COLLATERAL ON FINANCING_COLLATERALS
(COLLATERAL_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_FINANCING_COLLATERAL_REQUEST ON FINANCING_COLLATERALS
(REQUEST_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_FINANCING_REQUEST_CUSTOMER ON FINANCING_REQUESTS_NEW
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_FINANCING_REQUEST_STATUS ON FINANCING_REQUESTS_NEW
(STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_INST_DUE ON INSTALLMENT_SCHEDULE
(DUE_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_INST_REQ ON INSTALLMENT_SCHEDULE
(REQUEST_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_INST_STATUS ON INSTALLMENT_SCHEDULE
(INSTALLMENT_STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_MSG_CUST ON REMINDER_MESSAGES
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_MSG_INST ON REMINDER_MESSAGES
(INSTALLMENT_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_MSG_REQ ON REMINDER_MESSAGES
(REQUEST_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_PROV_CLASS ON PROVISIONS
(CLASSIFICATION_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_PROV_REQ ON PROVISIONS
(REQUEST_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQCOL_COL ON REQUEST_COLLATERALS
(COLLATERAL_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQCOL_REQ ON REQUEST_COLLATERALS
(REQUEST_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQ_CUST ON FINANCING_REQUESTS
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQ_DOC_EXPIRY ON REQUEST_DOCUMENTS
(EXPIRY_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQ_DOC_REQUEST ON REQUEST_DOCUMENTS
(REQUEST_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQ_DOC_STATUS ON REQUEST_DOCUMENTS
(DOCUMENT_STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQ_DOC_TYPE ON REQUEST_DOCUMENTS
(DOCUMENT_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQ_PROD ON FINANCING_REQUESTS
(PRODUCT_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_REQ_STATUS ON FINANCING_REQUESTS
(REQUEST_STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_STAGE_ACTIVE ON REQUEST_STAGES
(IS_ACTIVE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_STAGE_ORDER ON REQUEST_STAGES
(STAGE_ORDER)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_STAGE_PROD ON PRODUCT_STAGES
(PRODUCT_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_SYSTEM_LOGS_DATE ON SYSTEM_LOGS_NEW
(LOG_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_SYSTEM_LOGS_TYPE ON SYSTEM_LOGS_NEW
(LOG_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_SYS_NOTIF_ACTIVE ON SYSTEM_NOTIFICATIONS
(IS_ACTIVE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_SYS_NOTIF_DATES ON SYSTEM_NOTIFICATIONS
(START_DATE, END_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_SYS_NOTIF_TYPE ON SYSTEM_NOTIFICATIONS
(NOTIFICATION_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_USER_NOTIF_DATE ON USER_NOTIFICATIONS
(NOTIFICATION_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_USER_NOTIF_IS_READ ON USER_NOTIFICATIONS
(IS_READ)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_USER_NOTIF_TYPE ON USER_NOTIFICATIONS
(NOTIFICATION_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_USER_NOTIF_USER_ID ON USER_NOTIFICATIONS
(USER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_VALUATION_COLLATERAL ON COLLATERAL_VALUATIONS
(COLLATERAL_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074064.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074065.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074066.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074069.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074070.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074074.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074081.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074082.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074084.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074097.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074098.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074109.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074110.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074120.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074129.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074158.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074171.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074182.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074211.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074230.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074243.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074254.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074261.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074271.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074279.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074303.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074314.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074328.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074341.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074348.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074359.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074369.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074382.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074389.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074395.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074405.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074415.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074424.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074425.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074430.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074431.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074432.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074444.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074450.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074458.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074463.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074471.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074477.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074482.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074496.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074500.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074509.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074521.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074525.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074532.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074537.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074576.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074584.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074598.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074603.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074608.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074618.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074634.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074640.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074646.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074653.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074656.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074661.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074673.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074679.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074684.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074686.
--  The object is created when the parent object is created.

CREATE SEQUENCE SEQ_NOTIFICATION_ID
  START WITH 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
  NOKEEP
  NOSCALE
  GLOBAL;


CREATE OR REPLACE TRIGGER TRG_CREATE_TASK_NOTIFICATION
AFTER INSERT ON TASKS
FOR EACH ROW
BEGIN
    INSERT INTO NOTIFICATIONS (
        NOTIFICATION_ID, USER_ID, NOTIFICATION_TYPE, NOTIFICATION_TITLE,
        NOTIFICATION_TEXT, REFERENCE_TYPE, REFERENCE_ID, CREATION_DATE
    ) VALUES (
        SEQ_NOTIFICATION_ID.NEXTVAL, :NEW.ASSIGNED_TO, 'TASK', 'مهمة جديدة',
        'تم تعيين مهمة جديدة لك: ' || :NEW.TASK_TITLE, 'TASK', :NEW.TASK_ID, SYSTIMESTAMP
    );
END;
/


CREATE SEQUENCE SEQ_CUSTOMER_ID
  START WITH 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
  NOKEEP
  NOSCALE
  GLOBAL;


CREATE OR REPLACE TRIGGER TRG_CUSTOMER_ID
BEFORE INSERT ON "CUSTOMERS"
FOR EACH ROW
BEGIN
    IF :NEW.CUSTOMER_ID IS NULL THEN
        SELECT SEQ_CUSTOMER_ID.NEXTVAL INTO :NEW.CUSTOMER_ID FROM DUAL;
    END IF;
END;
/


CREATE SEQUENCE SEQ_EMAIL_ID
  START WITH 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
  NOKEEP
  NOSCALE
  GLOBAL;


CREATE OR REPLACE TRIGGER TRG_EMAIL_LOGS
BEFORE INSERT ON EMAIL_LOGS
FOR EACH ROW
BEGIN
---
IF NVL(:NEW.EMAIL_ID,0)=0 THEN
---
:NEW.EMAIL_ID:=SEQ_EMAIL_ID.NEXTVAL;
---
END IF;
---
END;
/


CREATE SEQUENCE SEQ_FINANCING_ID
  START WITH 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
  NOKEEP
  NOSCALE
  GLOBAL;


CREATE SEQUENCE SEQ_FINANCING_REQUEST_ID
  START WITH 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
  NOKEEP
  NOSCALE
  GLOBAL;


CREATE OR REPLACE TRIGGER TRG_FINANCING_REQUEST_ID
BEFORE INSERT ON FINANCING_REQUESTS
FOR EACH ROW
BEGIN
    IF :NEW.REQUEST_ID IS NULL THEN
        SELECT SEQ_FINANCING_REQUEST_ID.NEXTVAL INTO :NEW.REQUEST_ID FROM DUAL;
    END IF;
    
    -- إنشاء رقم الطلب بتنسيق معين
    IF :NEW.REQUEST_NUMBER IS NULL THEN
        :NEW.REQUEST_NUMBER := 'REQ-' || TO_CHAR(SYSDATE, 'YYYYMMDD') || '-' || LPAD(:NEW.REQUEST_ID, 5, '0');
    END IF;
END;
/


CREATE SEQUENCE SEQ_HISTORY_ID
  START WITH 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
  NOKEEP
  NOSCALE
  GLOBAL;


CREATE OR REPLACE TRIGGER TRG_UPDATE_INSTALLMENT_STATUS
AFTER INSERT OR UPDATE OF PAYMENT_STATUS ON PAYMENTS
FOR EACH ROW
DECLARE
    v_remaining NUMBER;
    v_installment_amount NUMBER;
BEGIN
    IF :NEW.INSTALLMENT_ID IS NOT NULL AND :NEW.PAYMENT_STATUS = 'COMPLETED' THEN
        -- الحصول على قيمة القسط
        SELECT INSTALLMENT_AMOUNT INTO v_installment_amount
        FROM INSTALLMENT_SCHEDULE
        WHERE INSTALLMENT_ID = :NEW.INSTALLMENT_ID;
        
        -- حساب المبلغ المتبقي من القسط
        SELECT NVL(SUM(PAYMENT_AMOUNT), 0) INTO v_remaining
        FROM PAYMENTS
        WHERE INSTALLMENT_ID = :NEW.INSTALLMENT_ID
        AND PAYMENT_STATUS = 'COMPLETED';
        
        -- تحديث حالة القسط بناءً على المبلغ المدفوع
        IF v_remaining >= v_installment_amount THEN
            UPDATE INSTALLMENT_SCHEDULE
            SET INSTALLMENT_STATUS = 'PAID',
                PAYMENT_DATE = :NEW.PAYMENT_DATE,
                UPDATED_DATE = SYSTIMESTAMP
            WHERE INSTALLMENT_ID = :NEW.INSTALLMENT_ID;
        ELSE
            UPDATE INSTALLMENT_SCHEDULE
            SET INSTALLMENT_STATUS = 'PARTIALLY_PAID',
                UPDATED_DATE = SYSTIMESTAMP
            WHERE INSTALLMENT_ID = :NEW.INSTALLMENT_ID;
        END IF;
    END IF;
END;
/


CREATE OR REPLACE TRIGGER TRG_UPDATE_OVERDUE_INSTALLMENTS
BEFORE INSERT OR UPDATE ON INSTALLMENT_SCHEDULE
FOR EACH ROW
BEGIN
    IF :NEW.INSTALLMENT_STATUS IN ('PENDING', 'PARTIALLY_PAID') AND :NEW.DUE_DATE < SYSDATE THEN
        :NEW.INSTALLMENT_STATUS := 'OVERDUE';
        :NEW.UPDATED_DATE := SYSTIMESTAMP;
    END IF;
END;
/


CREATE OR REPLACE TRIGGER TRG_UPDATE_REMAINING_AMOUNT
AFTER UPDATE OF INSTALLMENT_STATUS ON INSTALLMENT_SCHEDULE
FOR EACH ROW
BEGIN
    IF :NEW.INSTALLMENT_STATUS = 'PAID' AND :OLD.INSTALLMENT_STATUS <> 'PAID' THEN
        UPDATE FINANCING_CONTRACTS
        SET REMAINING_AMOUNT = REMAINING_AMOUNT - :NEW.PRINCIPAL_AMOUNT,
            LAST_UPDATE_DATE = SYSTIMESTAMP
        WHERE REQUEST_ID = :NEW.REQUEST_ID;
    END IF;
END;
/


CREATE TABLE ACCOUNTING_FORMULAS
(
  FORMULA_ID          NUMBER,
  PRODUCT_ID          NUMBER                    NOT NULL,
  STAGE_ID            NUMBER,
  FORMULA_NAME        VARCHAR2(100 BYTE)        NOT NULL,
  FORMULA_EXPRESSION  CLOB                      NOT NULL,
  DESCRIPTION         CLOB,
  CREATED_DATE        DATE                      DEFAULT SYSDATE,
  CREATED_BY          VARCHAR2(50 BYTE),
  UPDATED_DATE        DATE,
  UPDATED_BY          VARCHAR2(50 BYTE)
)
LOB (DESCRIPTION) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
LOB (FORMULA_EXPRESSION) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE ACCOUNTING_FORMULAS ADD (
  PRIMARY KEY
  (FORMULA_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COLLATERALS
(
  COLLATERAL_ID           NUMBER,
  CUSTOMER_ID             NUMBER                NOT NULL,
  COLLATERAL_TYPE         VARCHAR2(50 BYTE)     NOT NULL,
  COLLATERAL_DESCRIPTION  VARCHAR2(500 BYTE),
  ESTIMATED_VALUE         NUMBER                NOT NULL,
  OWNERSHIP_DOCUMENT_NO   VARCHAR2(50 BYTE),
  OWNERSHIP_STATUS        VARCHAR2(50 BYTE),
  STATUS                  VARCHAR2(20 BYTE)     DEFAULT 'ACTIVE',
  NOTES                   VARCHAR2(1000 BYTE),
  CREATED_BY              NUMBER,
  CREATION_DATE           TIMESTAMP(6)          DEFAULT SYSTIMESTAMP,
  UPDATED_BY              NUMBER,
  UPDATE_DATE             TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE COLLATERALS IS 'جدول يخزن معلومات الضمانات المقدمة من العملاء';


ALTER TABLE COLLATERALS ADD (
  PRIMARY KEY
  (COLLATERAL_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COLLATERALS_ORG
(
  COLLATERAL_ID        NUMBER,
  CUSTOMER_ID          NUMBER                   NOT NULL,
  COLLATERAL_TYPE      VARCHAR2(50 BYTE)        NOT NULL,
  COLLATERAL_VALUE     NUMBER                   NOT NULL,
  DESCRIPTION          VARCHAR2(500 BYTE),
  REGISTRATION_NUMBER  VARCHAR2(100 BYTE),
  REGISTRATION_DATE    DATE,
  EXPIRY_DATE          DATE,
  STATUS               VARCHAR2(20 BYTE)        DEFAULT 'ACTIVE'              NOT NULL,
  NOTES                VARCHAR2(1000 BYTE),
  CREATED_BY           NUMBER                   NOT NULL,
  CREATION_DATE        TIMESTAMP(6)             DEFAULT SYSTIMESTAMP          NOT NULL,
  LAST_UPDATED_BY      NUMBER,
  LAST_UPDATE_DATE     TIMESTAMP(6)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COLLATERALS_ORG ADD (
  CONSTRAINT CHK_COLLATERAL_STATUS
  CHECK (STATUS IN ('ACTIVE', 'RELEASED', 'EXPIRED', 'UNDER_REVIEW'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_COLLATERAL_TYPE
  CHECK (COLLATERAL_TYPE IN ('REAL_ESTATE', 'VEHICLE', 'EQUIPMENT', 'CASH_DEPOSIT', 'INVESTMENT_PORTFOLIO', 'PERSONAL_GUARANTEE', 'CORPORATE_GUARANTEE', 'OTHER'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (COLLATERAL_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COLLATERAL_DOCUMENTS
(
  DOCUMENT_ID      NUMBER,
  COLLATERAL_ID    NUMBER                       NOT NULL,
  DOCUMENT_TYPE    VARCHAR2(50 BYTE)            NOT NULL,
  DOCUMENT_NUMBER  VARCHAR2(100 BYTE),
  ISSUE_DATE       DATE,
  EXPIRY_DATE      DATE,
  DOCUMENT_PATH    VARCHAR2(500 BYTE),
  NOTES            CLOB,
  CREATED_DATE     TIMESTAMP(6)                 DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY       VARCHAR2(50 BYTE)            NOT NULL,
  UPDATED_DATE     TIMESTAMP(6),
  UPDATED_BY       VARCHAR2(50 BYTE),
  STATUS           VARCHAR2(20 BYTE)            DEFAULT 'ACTIVE',
  DOCUMENT_NOTES   VARCHAR2(151 BYTE),
  DOCUMENT_NAME    VARCHAR2(101 BYTE)
)
LOB (NOTES) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;

COMMENT ON TABLE COLLATERAL_DOCUMENTS IS 'جدول يخزن المستندات المتعلقة بالضمانات';


ALTER TABLE COLLATERAL_DOCUMENTS ADD (
  PRIMARY KEY
  (DOCUMENT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COMMITTEE_DECISIONS
(
  DECISION_ID       NUMBER,
  MEETING_ID        NUMBER                      NOT NULL,
  REFERENCE_TYPE    VARCHAR2(50 BYTE)           NOT NULL,
  REFERENCE_ID      NUMBER                      NOT NULL,
  DECISION          VARCHAR2(50 BYTE)           NOT NULL,
  DECISION_DETAILS  VARCHAR2(4000 BYTE),
  DECISION_DATE     TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  DECIDED_BY        NUMBER                      NOT NULL,
  NOTES             VARCHAR2(1000 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COMMITTEE_DECISIONS ADD (
  CONSTRAINT CHK_DECISION
  CHECK (DECISION IN ('APPROVED', 'REJECTED', 'POSTPONED', 'APPROVED_WITH_CONDITIONS', 'REFERRED_BACK', 'ESCALATED'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_REFERENCE_TYPE_DEC
  CHECK (REFERENCE_TYPE IN ('FINANCING_REQUEST', 'FINANCING_CONTRACT', 'POLICY', 'OTHER'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (DECISION_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE COMMITTEE_REQUESTS
(
  REQUEST_ID       NUMBER,
  COMMITTEE_ID     NUMBER,
  SUBMISSION_DATE  DATE                         DEFAULT SYSDATE,
  NOTES            CLOB,
  DECISION_STATUS  VARCHAR2(20 BYTE)            DEFAULT 'PENDING',
  DECISION_NOTES   CLOB,
  DECISION_DATE    DATE,
  CREATION_DATE    DATE                         DEFAULT SYSDATE,
  CREATED_BY       NUMBER,
  UPDATE_DATE      DATE,
  UPDATED_BY       NUMBER
)
LOB (DECISION_NOTES) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
LOB (NOTES) STORE AS SECUREFILE (
  TABLESPACE  USERS
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  NOCACHE
  LOGGING)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE COMMITTEE_REQUESTS ADD (
  PRIMARY KEY
  (REQUEST_ID, COMMITTEE_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE DOCUMENTS
(
  DOCUMENT_ID       NUMBER,
  DOCUMENT_TYPE_ID  NUMBER                      NOT NULL,
  REFERENCE_TYPE    VARCHAR2(50 BYTE)           NOT NULL,
  REFERENCE_ID      NUMBER                      NOT NULL,
  DOCUMENT_NAME     VARCHAR2(200 BYTE)          NOT NULL,
  FILE_PATH         VARCHAR2(500 BYTE)          NOT NULL,
  FILE_SIZE         NUMBER,
  FILE_TYPE         VARCHAR2(100 BYTE),
  UPLOAD_DATE       TIMESTAMP(6)                DEFAULT SYSTIMESTAMP          NOT NULL,
  UPLOADED_BY       NUMBER                      NOT NULL,
  EXPIRY_DATE       DATE,
  DOCUMENT_STATUS   VARCHAR2(20 BYTE)           DEFAULT 'ACTIVE'              NOT NULL,
  NOTES             VARCHAR2(500 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE DOCUMENTS ADD (
  CONSTRAINT CHK_DOCUMENT_STATUS
  CHECK (DOCUMENT_STATUS IN ('ACTIVE', 'ARCHIVED', 'EXPIRED', 'REJECTED'))
  ENABLE VALIDATE
,  CONSTRAINT CHK_REFERENCE_TYPE
  CHECK (REFERENCE_TYPE IN ('CUSTOMER', 'FINANCING_REQUEST', 'FINANCING_CONTRACT', 'COLLATERAL', 'PAYMENT'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (DOCUMENT_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FINANCING_COLLATERALS_ORG
(
  FINANCING_ID   NUMBER,
  COLLATERAL_ID  NUMBER,
  ADDED_DATE     TIMESTAMP(6)                   DEFAULT SYSTIMESTAMP          NOT NULL,
  ADDED_BY       NUMBER                         NOT NULL
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FINANCING_COLLATERALS_ORG ADD (
  PRIMARY KEY
  (FINANCING_ID, COLLATERAL_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE TABLE FINANCING_CONTRACTS
(
  FINANCING_ID         NUMBER,
  CONTRACT_NUMBER      VARCHAR2(20 BYTE)        NOT NULL,
  CUSTOMER_ID          NUMBER                   NOT NULL,
  PRODUCT_ID           NUMBER                   NOT NULL,
  REQUEST_ID           NUMBER,
  FINANCING_AMOUNT     NUMBER                   NOT NULL,
  PROFIT_RATE          NUMBER                   NOT NULL,
  PROFIT_AMOUNT        NUMBER                   NOT NULL,
  TOTAL_AMOUNT         NUMBER                   NOT NULL,
  REMAINING_AMOUNT     NUMBER                   NOT NULL,
  INSTALLMENT_COUNT    NUMBER                   NOT NULL,
  INSTALLMENT_AMOUNT   NUMBER                   NOT NULL,
  START_DATE           DATE                     NOT NULL,
  END_DATE             DATE                     NOT NULL,
  CONTRACT_STATUS      VARCHAR2(50 BYTE)        DEFAULT 'PENDING_APPROVAL'    NOT NULL,
  NOTES                VARCHAR2(4000 BYTE),
  PARENT_FINANCING_ID  NUMBER,
  CREATION_DATE        TIMESTAMP(6)             DEFAULT SYSTIMESTAMP          NOT NULL,
  CREATED_BY           NUMBER,
  LAST_UPDATE_DATE     TIMESTAMP(6),
  LAST_UPDATED_BY      NUMBER,
  COMPLETION_DATE      DATE,
  FINANCING_TYPE       VARCHAR2(101 BYTE),
  FINANCING_PERIOD     NUMBER,
  PURPOSE              VARCHAR2(301 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FINANCING_CONTRACTS ADD (
  CONSTRAINT CHK_CONTRACT_STATUS
  CHECK (CONTRACT_STATUS IN ('PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'COMPLETED', 'CANCELLED', 'DEFAULTED', 'WRITTEN_OFF', 'RESTRUCTURED', 'EARLY_SETTLEMENT'))
  ENABLE VALIDATE
,  PRIMARY KEY
  (FINANCING_ID)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE
,  UNIQUE (CONTRACT_NUMBER)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


CREATE INDEX IDX_COLLATERAL_CUSTOMER ON COLLATERALS
(CUSTOMER_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COLLATERAL_STATUS ON COLLATERALS
(STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COLLATERAL_TYPE ON COLLATERALS
(COLLATERAL_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COLL_DOC_COLLATERAL ON COLLATERAL_DOCUMENTS
(COLLATERAL_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COLL_DOC_EXPIRY ON COLLATERAL_DOCUMENTS
(EXPIRY_DATE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COLL_DOC_TYPE ON COLLATERAL_DOCUMENTS
(DOCUMENT_TYPE)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COMMITTEE_REQUEST_COMMITTEE ON COMMITTEE_REQUESTS
(COMMITTEE_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_COMMITTEE_REQUEST_STATUS ON COMMITTEE_REQUESTS
(DECISION_STATUS)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_FORM_PROD ON ACCOUNTING_FORMULAS
(PRODUCT_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

CREATE INDEX IDX_FORM_STAGE ON ACCOUNTING_FORMULAS
(STAGE_ID)
LOGGING
TABLESPACE USERS
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074147.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074148.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074195.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074201.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074223.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074291.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074436.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074487.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074590.
--  The object is created when the parent object is created.

--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074666.
--  The object is created when the parent object is created.

CREATE OR REPLACE TRIGGER TRG_CHECK_CONTRACT_COMPLETION
AFTER UPDATE OF REMAINING_AMOUNT ON "FINANCING_CONTRACTS"
FOR EACH ROW
BEGIN
    IF :NEW.REMAINING_AMOUNT <= 0 AND :NEW.CONTRACT_STATUS = 'ACTIVE' THEN
        UPDATE FINANCING_CONTRACTS
        SET CONTRACT_STATUS = 'COMPLETED',
            COMPLETION_DATE = SYSTIMESTAMP,
            LAST_UPDATE_DATE = SYSTIMESTAMP
        WHERE FINANCING_ID = :NEW.FINANCING_ID;
    END IF;
END;
/


CREATE OR REPLACE TRIGGER TRG_FINANCING_CONTRACT_ID
BEFORE INSERT ON "FINANCING_CONTRACTS"
FOR EACH ROW
BEGIN
    IF :NEW.FINANCING_ID IS NULL THEN
        SELECT SEQ_FINANCING_ID.NEXTVAL INTO :NEW.FINANCING_ID FROM DUAL;
    END IF;
    
    -- إنشاء رقم العقد بتنسيق معين
    IF :NEW.CONTRACT_NUMBER IS NULL THEN
        :NEW.CONTRACT_NUMBER := 'FIN-' || TO_CHAR(SYSDATE, 'YYYYMMDD') || '-' || LPAD(:NEW.FINANCING_ID, 5, '0');
    END IF;
END;
/


CREATE OR REPLACE TRIGGER TRG_FINANCING_STATUS_HISTORY
AFTER UPDATE OF CONTRACT_STATUS ON "FINANCING_CONTRACTS"
FOR EACH ROW
BEGIN
    IF :OLD.CONTRACT_STATUS <> :NEW.CONTRACT_STATUS THEN
        INSERT INTO FINANCING_STATUS_HISTORY (
            HISTORY_ID, FINANCING_ID, OLD_STATUS, NEW_STATUS,
            CHANGE_REASON, CHANGE_DATE, CHANGED_BY
        ) VALUES (
            SEQ_HISTORY_ID.NEXTVAL, :NEW.FINANCING_ID, :OLD.CONTRACT_STATUS, :NEW.CONTRACT_STATUS,
            NULL, SYSTIMESTAMP, :NEW.LAST_UPDATED_BY
        );
    END IF;
END;
/


CREATE OR REPLACE TRIGGER TRG_UPDATE_REQUEST_STATUS
AFTER INSERT ON "FINANCING_CONTRACTS"
FOR EACH ROW
BEGIN
    UPDATE FINANCING_REQUESTS
    SET REQUEST_STATUS = 'APPROVED',
        UPDATED_DATE = SYSTIMESTAMP,
        UPDATED_BY = :NEW.CREATED_BY
    WHERE REQUEST_ID = :NEW.REQUEST_ID;
END;
/


CREATE TABLE FINANCING_CLASSIFICATIONS
(
  FINANCING_ID         NUMBER,
  CLASSIFICATION_ID    NUMBER,
  CLASSIFICATION_DATE  TIMESTAMP(6)             DEFAULT SYSTIMESTAMP          NOT NULL,
  CLASSIFIED_BY        NUMBER                   NOT NULL,
  NOTES                VARCHAR2(500 BYTE)
)
TABLESPACE USERS
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE;


ALTER TABLE FINANCING_CLASSIFICATIONS ADD (
  PRIMARY KEY
  (FINANCING_ID, CLASSIFICATION_ID, CLASSIFICATION_DATE)
  USING INDEX
    TABLESPACE USERS
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
                PCTINCREASE      0
                BUFFER_POOL      DEFAULT
               )
  ENABLE VALIDATE);


--  There is no statement for index ISLAMIC_LOANS4.SYS_C0074374.
--  The object is created when the parent object is created.

ALTER TABLE COLLATERAL_DOCUMENTS_NEW ADD (
  CONSTRAINT FK_DOCUMENT_COLLATERAL 
  FOREIGN KEY (COLLATERAL_ID) 
  REFERENCES COLLATERALS (COLLATERAL_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_DOCUMENT_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_DOCUMENT_UPDATED_BY 
  FOREIGN KEY (UPDATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE COLLATERAL_VALUATIONS ADD (
  CONSTRAINT FK_VALUATION_COLLATERAL 
  FOREIGN KEY (COLLATERAL_ID) 
  REFERENCES COLLATERALS (COLLATERAL_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_VALUATION_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_VALUATION_UPDATED_BY 
  FOREIGN KEY (UPDATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE COMMITTEES ADD (
  CONSTRAINT FK_COMMITTEE_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMMITTEE_UPDATED_BY 
  FOREIGN KEY (UPDATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE COMMITTEES_ORG ADD (
  CONSTRAINT FK_COMMITTEES_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMMITTEES_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE COMMITTEE_MEETINGS ADD (
  CONSTRAINT FK_MEETINGS_COMMITTEE_ID 
  FOREIGN KEY (COMMITTEE_ID) 
  REFERENCES COMMITTEES_ORG (COMMITTEE_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_MEETINGS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_MEETINGS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE COMMITTEE_MEMBERS ADD (
  CONSTRAINT FK_COMMITTEE_MEMBER_COMMITTEE 
  FOREIGN KEY (COMMITTEE_ID) 
  REFERENCES COMMITTEES (COMMITTEE_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMMITTEE_MEMBER_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMMITTEE_MEMBER_UPDATED_BY 
  FOREIGN KEY (UPDATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMMITTEE_MEMBER_USER 
  FOREIGN KEY (USER_ID) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE COMMITTEE_MEMBERS_ORG ADD (
  CONSTRAINT FK_COMM_MEMBERS_ADDED_BY 
  FOREIGN KEY (ADDED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMM_MEMBERS_COMMITTEE_ID 
  FOREIGN KEY (COMMITTEE_ID) 
  REFERENCES COMMITTEES_ORG (COMMITTEE_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMM_MEMBERS_USER_ID 
  FOREIGN KEY (USER_ID) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE CREDIT_RATING_HISTORY ADD (
  CONSTRAINT FK_RATING_CUSTOMER_ID 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_RATING_RATED_BY 
  FOREIGN KEY (RATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE CUSTOMERS ADD (
  CONSTRAINT FK_CUSTOMERS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_CUSTOMERS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE CUSTOMER_CONTACT_PREFERENCES ADD (
  CONSTRAINT FK_CONTACT_PREF_CUSTOMER 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE);

ALTER TABLE CUSTOMER_CREDIT_RATINGS ADD (
  CONSTRAINT FK_CCR_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_CCR_CUSTOMER 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_CCR_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE CUSTOMER_CREDIT_SCORES ADD (
  CONSTRAINT FK_SCORE_CRIT 
  FOREIGN KEY (CRITERIA_ID) 
  REFERENCES CREDIT_CRITERIA (CRITERIA_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_SCORE_CUST 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS_NEW (CUSTOMER_ID)
  ENABLE VALIDATE);

ALTER TABLE CUSTOMER_DOCUMENTS ADD (
  CONSTRAINT FK_CUST_DOC_CUSTOMER 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE);

ALTER TABLE CUSTOMER_FINANCIAL_OBLIGATIONS ADD (
  CONSTRAINT FK_OBLIGATIONS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_OBLIGATIONS_CUSTOMER_ID 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_OBLIGATIONS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE CUSTOMER_NOTES ADD (
  CONSTRAINT FK_CUSTOMER_NOTE_CUSTOMER 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE);

ALTER TABLE DEBT_CLASSIFICATIONS ADD (
  CONSTRAINT FK_DEBT_CLASS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_DEBT_CLASS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE DOCUMENT_TYPES ADD (
  CONSTRAINT FK_DOC_TYPES_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE FAQ ADD (
  CONSTRAINT FK_FAQ_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FAQ_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE FEES_COMMISSIONS ADD (
  CONSTRAINT FK_FEE_PROD 
  FOREIGN KEY (PRODUCT_ID) 
  REFERENCES ISLAMIC_PRODUCTS (PRODUCT_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FEE_STAGE 
  FOREIGN KEY (STAGE_ID) 
  REFERENCES PRODUCT_STAGES (STAGE_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_COLLATERALS ADD (
  CONSTRAINT FK_FINANCING_COLLATERAL_COLLATERAL 
  FOREIGN KEY (COLLATERAL_ID) 
  REFERENCES COLLATERALS (COLLATERAL_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FINANCING_COLLATERAL_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FINANCING_COLLATERAL_REQUEST 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS_NEW (REQUEST_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FINANCING_COLLATERAL_UPDATED_BY 
  FOREIGN KEY (UPDATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_NOTES ADD (
  CONSTRAINT FK_NOTES_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_NOTES_FINANCING_ID 
  FOREIGN KEY (FINANCING_ID) 
  REFERENCES FINANCING_CONTRACTS (FINANCING_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_REQUESTS ADD (
  CONSTRAINT FK_REQ_CUST 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQ_PROD 
  FOREIGN KEY (PRODUCT_ID) 
  REFERENCES ISLAMIC_PRODUCTS (PRODUCT_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQ_STAGE 
  FOREIGN KEY (CURRENT_STAGE_ID) 
  REFERENCES PRODUCT_STAGES (STAGE_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_REQUESTS_NEW ADD (
  CONSTRAINT FK_REQUEST_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQUEST_CUSTOMER 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS_NEW (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQUEST_UPDATED_BY 
  FOREIGN KEY (UPDATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_REQUESTS_NEW1 ADD (
  CONSTRAINT FK_REQUESTS_ASSIGNED_TO 
  FOREIGN KEY (ASSIGNED_TO) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQUESTS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQUESTS_CUSTOMER_ID 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQUESTS_PRODUCT_ID 
  FOREIGN KEY (PRODUCT_ID) 
  REFERENCES ISLAMIC_PRODUCTS (PRODUCT_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQUESTS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_STATUS_HISTORY ADD (
  CONSTRAINT FK_FIN_HISTORY_CHANGED_BY 
  FOREIGN KEY (CHANGED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FIN_HISTORY_FINANCING_ID 
  FOREIGN KEY (FINANCING_ID) 
  REFERENCES FINANCING_CONTRACTS (FINANCING_ID)
  ENABLE VALIDATE);

ALTER TABLE HOLIDAYS ADD (
  CONSTRAINT FK_HOLIDAYS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE INSTALLMENT_SCHEDULE ADD (
  CONSTRAINT FK_INST_REQ 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS_NEW1 (REQUEST_ID)
  ENABLE VALIDATE);

ALTER TABLE INSTALLMENT_SCHEDULE_NEW ADD (
  CONSTRAINT FK_INSTALLMENT_FINANCING_ID 
  FOREIGN KEY (FINANCING_ID) 
  REFERENCES FINANCING_CONTRACTS (FINANCING_ID)
  ENABLE VALIDATE);

ALTER TABLE ISLAMIC_PRODUCTS ADD (
  CONSTRAINT FK_PRODUCTS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_PRODUCTS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE LOGIN_HISTORY ADD (
  CONSTRAINT FK_LOGIN_USER_ID 
  FOREIGN KEY (USER_ID) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE MEETING_ATTENDANCE ADD (
  CONSTRAINT FK_ATTENDANCE_MEETING_ID 
  FOREIGN KEY (MEETING_ID) 
  REFERENCES COMMITTEE_MEETINGS (MEETING_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_ATTENDANCE_RECORDED_BY 
  FOREIGN KEY (RECORDED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_ATTENDANCE_USER_ID 
  FOREIGN KEY (USER_ID) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE NOTIFICATIONS ADD (
  CONSTRAINT FK_NOTIFICATIONS_USER_ID 
  FOREIGN KEY (USER_ID) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE PAYMENTS ADD (
  CONSTRAINT FK_PAYMENTS_CANCELLED_BY 
  FOREIGN KEY (CANCELLED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_PAYMENTS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_PAYMENTS_FINANCING_ID 
  FOREIGN KEY (FINANCING_ID) 
  REFERENCES FINANCING_CONTRACTS (FINANCING_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_PAYMENTS_INSTALLMENT_ID 
  FOREIGN KEY (INSTALLMENT_ID) 
  REFERENCES INSTALLMENT_SCHEDULE_NEW (INSTALLMENT_ID)
  ENABLE VALIDATE);

ALTER TABLE PRODUCT_CONDITIONS ADD (
  CONSTRAINT FK_PROD_COND 
  FOREIGN KEY (PRODUCT_ID) 
  REFERENCES ISLAMIC_PRODUCTS (PRODUCT_ID)
  ENABLE VALIDATE);

ALTER TABLE PRODUCT_REQUIRED_DOCUMENTS ADD (
  CONSTRAINT FK_PROD_DOC_PRODUCT 
  FOREIGN KEY (PRODUCT_ID) 
  REFERENCES ISLAMIC_PRODUCTS (PRODUCT_ID)
  ENABLE VALIDATE);

ALTER TABLE PRODUCT_STAGES ADD (
  CONSTRAINT FK_PROD_STAGE 
  FOREIGN KEY (PRODUCT_ID) 
  REFERENCES ISLAMIC_PRODUCTS (PRODUCT_ID)
  ENABLE VALIDATE);

ALTER TABLE PROVISIONS ADD (
  CONSTRAINT FK_PROV_CLASS 
  FOREIGN KEY (CLASSIFICATION_ID) 
  REFERENCES DEBT_CLASSIFICATIONS (CLASSIFICATION_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_PROV_REQ 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS_NEW1 (REQUEST_ID)
  ENABLE VALIDATE);

ALTER TABLE REMINDER_MESSAGES ADD (
  CONSTRAINT FK_MSG_CUST 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_MSG_INST 
  FOREIGN KEY (INSTALLMENT_ID) 
  REFERENCES INSTALLMENT_SCHEDULE (INSTALLMENT_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_MSG_REQ 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS (REQUEST_ID)
  ENABLE VALIDATE);

ALTER TABLE REMINDER_MESSAGES_NEW ADD (
  CONSTRAINT FK_REMINDERS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REMINDERS_CUSTOMER_ID 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REMINDERS_FINANCING_ID 
  FOREIGN KEY (FINANCING_ID) 
  REFERENCES FINANCING_CONTRACTS (FINANCING_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REMINDERS_INSTALLMENT_ID 
  FOREIGN KEY (INSTALLMENT_ID) 
  REFERENCES INSTALLMENT_SCHEDULE_NEW (INSTALLMENT_ID)
  ENABLE VALIDATE);

ALTER TABLE REPORTS ADD (
  CONSTRAINT FK_REPORTS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REPORTS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE REQUEST_COLLATERALS ADD (
  CONSTRAINT FK_REQCOL_COL 
  FOREIGN KEY (COLLATERAL_ID) 
  REFERENCES COLLATERALS (COLLATERAL_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQCOL_REQ 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS (REQUEST_ID)
  ENABLE VALIDATE);

ALTER TABLE REQUEST_DOCUMENTS ADD (
  CONSTRAINT FK_REQ_DOC_REQUEST 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS_NEW1 (REQUEST_ID)
  ENABLE VALIDATE);

ALTER TABLE REQUEST_STATUS_HISTORY ADD (
  CONSTRAINT FK_REQ_HISTORY_CHANGED_BY 
  FOREIGN KEY (CHANGED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_REQ_HISTORY_REQUEST_ID 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS_NEW1 (REQUEST_ID)
  ENABLE VALIDATE);

ALTER TABLE ROLES ADD (
  CONSTRAINT FK_ROLES_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_ROLES_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE ROLE_PERMISSIONS ADD (
  CONSTRAINT FK_ROLE_PERM_GRANTED_BY 
  FOREIGN KEY (GRANTED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_ROLE_PERM_PERM_ID 
  FOREIGN KEY (PERMISSION_ID) 
  REFERENCES PERMISSIONS (PERMISSION_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_ROLE_PERM_ROLE_ID 
  FOREIGN KEY (ROLE_ID) 
  REFERENCES ROLES (ROLE_ID)
  ENABLE VALIDATE);

ALTER TABLE SCHEDULED_JOBS ADD (
  CONSTRAINT FK_JOBS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_JOBS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE SYSTEM_LOGS ADD (
  CONSTRAINT FK_LOGS_USER_ID 
  FOREIGN KEY (USER_ID) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE SYSTEM_LOGS_NEW ADD (
  CONSTRAINT FK_LOG_USER 
  FOREIGN KEY (USER_ID) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE SYSTEM_SETTINGS ADD (
  CONSTRAINT FK_SETTINGS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE TASKS ADD (
  CONSTRAINT FK_TASKS_ASSIGNED_BY 
  FOREIGN KEY (ASSIGNED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_TASKS_ASSIGNED_TO 
  FOREIGN KEY (ASSIGNED_TO) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE USER_ROLES ADD (
  CONSTRAINT FK_USER_ROLES_ASSIGNED_BY 
  FOREIGN KEY (ASSIGNED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_USER_ROLES_ROLE_ID 
  FOREIGN KEY (ROLE_ID) 
  REFERENCES ROLES (ROLE_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_USER_ROLES_USER_ID 
  FOREIGN KEY (USER_ID) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE ACCOUNTING_FORMULAS ADD (
  CONSTRAINT FK_FORM_PROD 
  FOREIGN KEY (PRODUCT_ID) 
  REFERENCES ISLAMIC_PRODUCTS (PRODUCT_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FORM_STAGE 
  FOREIGN KEY (STAGE_ID) 
  REFERENCES PRODUCT_STAGES (STAGE_ID)
  ENABLE VALIDATE);

ALTER TABLE COLLATERALS ADD (
  CONSTRAINT FK_COLLATERAL_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COLLATERAL_CUSTOMER 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS_NEW (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COLLATERAL_UPDATED_BY 
  FOREIGN KEY (UPDATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE COLLATERALS_ORG ADD (
  CONSTRAINT FK_COLLATERALS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COLLATERALS_CUSTOMER_ID 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COLLATERALS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE COLLATERAL_DOCUMENTS ADD (
  CONSTRAINT FK_COLL_DOC_COLLATERAL 
  FOREIGN KEY (COLLATERAL_ID) 
  REFERENCES COLLATERALS (COLLATERAL_ID)
  ENABLE VALIDATE);

ALTER TABLE COMMITTEE_DECISIONS ADD (
  CONSTRAINT FK_DECISIONS_DECIDED_BY 
  FOREIGN KEY (DECIDED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_DECISIONS_MEETING_ID 
  FOREIGN KEY (MEETING_ID) 
  REFERENCES COMMITTEE_MEETINGS (MEETING_ID)
  ENABLE VALIDATE);

ALTER TABLE COMMITTEE_REQUESTS ADD (
  CONSTRAINT FK_COMMITTEE_REQUEST_COMMITTEE 
  FOREIGN KEY (COMMITTEE_ID) 
  REFERENCES COMMITTEES (COMMITTEE_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMMITTEE_REQUEST_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMMITTEE_REQUEST_REQUEST 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS_NEW (REQUEST_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_COMMITTEE_REQUEST_UPDATED_BY 
  FOREIGN KEY (UPDATED_BY) 
  REFERENCES USERS_NEW (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE DOCUMENTS ADD (
  CONSTRAINT FK_DOCUMENTS_TYPE_ID 
  FOREIGN KEY (DOCUMENT_TYPE_ID) 
  REFERENCES DOCUMENT_TYPES (DOCUMENT_TYPE_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_DOCUMENTS_UPLOADED_BY 
  FOREIGN KEY (UPLOADED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_COLLATERALS_ORG ADD (
  CONSTRAINT FK_FIN_COLL_ADDED_BY 
  FOREIGN KEY (ADDED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FIN_COLL_COLLATERAL_ID 
  FOREIGN KEY (COLLATERAL_ID) 
  REFERENCES COLLATERALS_ORG (COLLATERAL_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FIN_COLL_FINANCING_ID 
  FOREIGN KEY (FINANCING_ID) 
  REFERENCES FINANCING_CONTRACTS (FINANCING_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_CONTRACTS ADD (
  CONSTRAINT FK_CONTRACTS_CREATED_BY 
  FOREIGN KEY (CREATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_CONTRACTS_CUSTOMER_ID 
  FOREIGN KEY (CUSTOMER_ID) 
  REFERENCES CUSTOMERS (CUSTOMER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_CONTRACTS_PARENT_ID 
  FOREIGN KEY (PARENT_FINANCING_ID) 
  REFERENCES FINANCING_CONTRACTS (FINANCING_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_CONTRACTS_PRODUCT_ID 
  FOREIGN KEY (PRODUCT_ID) 
  REFERENCES ISLAMIC_PRODUCTS (PRODUCT_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_CONTRACTS_REQUEST_ID 
  FOREIGN KEY (REQUEST_ID) 
  REFERENCES FINANCING_REQUESTS_NEW1 (REQUEST_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_CONTRACTS_UPDATED_BY 
  FOREIGN KEY (LAST_UPDATED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE);

ALTER TABLE FINANCING_CLASSIFICATIONS ADD (
  CONSTRAINT FK_FIN_CLASS_CLASSIFIED_BY 
  FOREIGN KEY (CLASSIFIED_BY) 
  REFERENCES USERS (USER_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FIN_CLASS_CLASS_ID 
  FOREIGN KEY (CLASSIFICATION_ID) 
  REFERENCES DEBT_CLASSIFICATIONS (CLASSIFICATION_ID)
  ENABLE VALIDATE
,  CONSTRAINT FK_FIN_CLASS_FINANCING_ID 
  FOREIGN KEY (FINANCING_ID) 
  REFERENCES FINANCING_CONTRACTS (FINANCING_ID)
  ENABLE VALIDATE);


CREATE OR REPLACE FUNCTION                API_GET_CONTRACT_INFO(
    p_financing_id IN NUMBER
) RETURN CLOB IS
    v_result CLOB;
BEGIN
    SELECT JSON_OBJECT(
        'financing_id' VALUE fc.FINANCING_ID,
        'contract_number' VALUE fc.CONTRACT_NUMBER,
        'customer' VALUE JSON_OBJECT(
            'customer_id' VALUE c.CUSTOMER_ID,
            'full_name' VALUE c.FULL_NAME,
            'national_id' VALUE c.NATIONAL_ID,
            'mobile_number' VALUE c.MOBILE_NUMBER
        ),
        'product' VALUE JSON_OBJECT(
            'product_id' VALUE ip.PRODUCT_ID,
            'product_name' VALUE ip.PRODUCT_NAME,
            'product_type' VALUE ip.PRODUCT_TYPE
        ),
        'financing_amount' VALUE fc.FINANCING_AMOUNT,
        'remaining_amount' VALUE fc.REMAINING_AMOUNT,
        'profit_rate' VALUE fc.PROFIT_RATE,
        'financing_period' VALUE fc.FINANCING_PERIOD,
        'start_date' VALUE TO_CHAR(fc.START_DATE, 'YYYY-MM-DD'),
        'end_date' VALUE TO_CHAR(fc.END_DATE, 'YYYY-MM-DD'),
        'contract_status' VALUE fc.CONTRACT_STATUS,
        'installments' VALUE (
            SELECT JSON_ARRAYAGG(
                JSON_OBJECT(
                    'installment_id' VALUE is1.INSTALLMENT_ID,
                    'installment_number' VALUE is1.INSTALLMENT_SEQ,
                    'installment_amount' VALUE is1.TOTAL_AMOUNT,
                    'principal_amount' VALUE is1.PRINCIPAL_AMOUNT,
                    'profit_amount' VALUE is1.PROFIT_AMOUNT,
                    'due_date' VALUE TO_CHAR(is1.DUE_DATE, 'YYYY-MM-DD'),
                    'installment_status' VALUE is1.INSTALLMENT_STATUS,
                    'actual_payment_date' VALUE TO_CHAR(is1.PAYMENT_DATE, 'YYYY-MM-DD')
                )
                ORDER BY is1.INSTALLMENT_SEQ
            )
            FROM INSTALLMENT_SCHEDULE is1
            WHERE is1.REQUEST_ID = fc.REQUEST_ID
        ),
        'payments' VALUE (
            SELECT JSON_ARRAYAGG(
                JSON_OBJECT(
                    'payment_id' VALUE p.PAYMENT_ID,
                    'payment_amount' VALUE p.PAYMENT_AMOUNT,
                    'payment_method' VALUE p.PAYMENT_METHOD,
                    'payment_reference' VALUE p.PAYMENT_REFERENCE,
                    'payment_date' VALUE TO_CHAR(p.PAYMENT_DATE, 'YYYY-MM-DD'),
                    'payment_status' VALUE p.PAYMENT_STATUS
                )
                ORDER BY p.PAYMENT_DATE DESC
            )
            FROM PAYMENTS p
            WHERE p.FINANCING_ID = fc.FINANCING_ID
        )
    ) INTO v_result
    FROM FINANCING_CONTRACTS fc
    JOIN CUSTOMERS c ON fc.CUSTOMER_ID = c.CUSTOMER_ID
    JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
    WHERE fc.FINANCING_ID = p_financing_id;
    
    RETURN v_result;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN JSON_OBJECT('error' VALUE 'Contract not found');
    WHEN OTHERS THEN
        RETURN JSON_OBJECT('error' VALUE SQLERRM);
END API_GET_CONTRACT_INFO;
/


CREATE OR REPLACE FUNCTION API_REGISTER_PAYMENT(
    p_financing_id IN NUMBER,
    p_installment_id IN NUMBER,
    p_payment_amount IN NUMBER,
    p_payment_method IN VARCHAR2,
    p_payment_reference IN VARCHAR2,
    p_payment_date IN DATE,
    p_created_by IN NUMBER
) RETURN CLOB IS
    v_payment_id NUMBER;
BEGIN
    -- تسجيل الدفعة
    ---PKG_FINANCING.REGISTER_PAYMENT(
    REGISTER_PAYMENT(
        p_financing_id => p_financing_id,
        p_installment_id => p_installment_id,
        p_payment_amount => p_payment_amount,
        p_payment_method => p_payment_method,
        p_payment_reference => p_payment_reference,
        p_payment_date => p_payment_date,
        p_created_by => p_created_by,
        p_payment_id => v_payment_id
    );
    
    -- إنشاء الاستجابة بتنسيق JSON
    RETURN JSON_OBJECT(
        'success' VALUE TRUE,
        'payment_id' VALUE v_payment_id,
        'message' VALUE 'تم تسجيل الدفعة بنجاح'
    );
EXCEPTION
    WHEN OTHERS THEN
        RETURN JSON_OBJECT(
            'success' VALUE FALSE,
            'message' VALUE 'حدث خطأ أثناء تسجيل الدفعة',
            'error' VALUE SQLERRM
        );
END API_REGISTER_PAYMENT;
/


CREATE OR REPLACE FUNCTION                CALCULATE_DTI_RATIO(
    p_customer_id IN NUMBER,
    p_new_installment_amount IN NUMBER DEFAULT 0
) RETURN NUMBER IS
    v_monthly_income NUMBER;
    v_current_installments NUMBER := 0;
    v_dti_ratio NUMBER;
BEGIN
    -- الحصول على الدخل الشهري للعميل
    SELECT MONTHLY_INCOME INTO v_monthly_income
    FROM CUSTOMERS
    WHERE CUSTOMER_ID = p_customer_id;
    
    -- حساب مجموع الأقساط الشهرية الحالية
    SELECT NVL(SUM(is1.TOTAL_AMOUNT), 0)
    INTO v_current_installments
    FROM INSTALLMENT_SCHEDULE is1
    JOIN FINANCING_CONTRACTS fc ON is1.REQUEST_ID = fc.REQUEST_ID
    WHERE fc.CUSTOMER_ID = p_customer_id
    AND fc.CONTRACT_STATUS = 'ACTIVE'
    AND is1.INSTALLMENT_STATUS = 'PENDING'
    AND is1.DUE_DATE = (
        SELECT MIN(DUE_DATE)
        FROM INSTALLMENT_SCHEDULE
        WHERE FINANCING_ID = fc.FINANCING_ID
        AND INSTALLMENT_STATUS = 'PENDING'
    );
    
    -- حساب نسبة الأقساط إلى الدخل
    v_dti_ratio := ((v_current_installments + p_new_installment_amount) / v_monthly_income) * 100;
    
    RETURN v_dti_ratio;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
END CALCULATE_DTI_RATIO;
/


CREATE OR REPLACE FUNCTION CALCULATE_EXPECTED_PROFIT(
    p_financing_amount IN NUMBER,
    p_profit_rate IN NUMBER,
    p_financing_period IN NUMBER
) RETURN NUMBER IS
    v_total_amount NUMBER;
    v_profit_amount NUMBER;
BEGIN
    -- حساب إجمالي المبلغ المستحق (المبلغ الأصلي + الربح)
    v_total_amount := p_financing_amount * (1 + (p_profit_rate/100 * p_financing_period/12));
    
    -- حساب مبلغ الربح
    v_profit_amount := v_total_amount - p_financing_amount;
    
    RETURN ROUND(v_profit_amount, 2);
END CALCULATE_EXPECTED_PROFIT;
/


CREATE OR REPLACE FUNCTION CALCULATE_IRR(
    p_financing_amount IN NUMBER,
    p_installment_amount IN NUMBER,
    p_financing_period IN NUMBER
) RETURN NUMBER IS
    v_irr NUMBER := 0.1; -- قيمة أولية للتقريب
    v_npv NUMBER;
    v_step NUMBER := 0.001;
    v_max_iterations NUMBER := 1000;
    v_iteration NUMBER := 0;
BEGIN
    -- حساب معدل العائد الداخلي باستخدام طريقة التقريب
    LOOP
        v_npv := -p_financing_amount;
        
        FOR i IN 1..p_financing_period LOOP
            v_npv := v_npv + (p_installment_amount / POWER(1 + v_irr, i));
        END LOOP;
        
        EXIT WHEN ABS(v_npv) < 0.01 OR v_iteration >= v_max_iterations;
        
        IF v_npv > 0 THEN
            v_irr := v_irr + v_step;
        ELSE
            v_irr := v_irr - v_step;
            v_step := v_step / 2;
        END IF;
        
        v_iteration := v_iteration + 1;
    END LOOP;
    
    RETURN ROUND(v_irr * 12 * 100, 2); -- تحويل إلى نسبة مئوية سنوية
END CALCULATE_IRR;
/


CREATE OR REPLACE FUNCTION                CHECK_CUSTOMER_ELIGIBILITY(
    p_customer_id IN NUMBER,
    p_product_id IN NUMBER,
    p_financing_amount IN NUMBER,
    p_financing_period IN NUMBER
) RETURN VARCHAR2 IS
    v_product_min_amount NUMBER;
    v_product_max_amount NUMBER;
    v_product_min_period NUMBER;
    v_product_max_period NUMBER;
    v_monthly_income NUMBER;
    v_max_dti_ratio NUMBER := 50; -- الحد الأقصى لنسبة الأقساط إلى الدخل (50%)
    v_dti_ratio NUMBER;
    v_installment_amount NUMBER;
    v_profit_rate NUMBER;
    v_result VARCHAR2(1000) := 'ELIGIBLE'; -- مؤهل افتراضياً
BEGIN
    -- الحصول على بيانات المنتج
    SELECT MIN_FINANCING_AMOUNT, MAX_FINANCING_AMOUNT, 
           MIN_FINANCING_PERIOD, MAX_FINANCING_PERIOD, PROFIT_RATE
    INTO v_product_min_amount, v_product_max_amount, 
         v_product_min_period, v_product_max_period, v_profit_rate
    FROM ISLAMIC_PRODUCTS
    WHERE PRODUCT_ID = p_product_id
    AND PRODUCT_STATUS = 'ACTIVE';
    
    -- الحصول على الدخل الشهري للعميل
    SELECT MONTHLY_INCOME INTO v_monthly_income
    FROM CUSTOMERS
    WHERE CUSTOMER_ID = p_customer_id;
    
    -- التحقق من مبلغ التمويل
    IF p_financing_amount < v_product_min_amount THEN
        v_result := 'NOT_ELIGIBLE: مبلغ التمويل أقل من الحد الأدنى المسموح به (' || v_product_min_amount || ')';
        RETURN v_result;
    END IF;
    
    IF p_financing_amount > v_product_max_amount THEN
        v_result := 'NOT_ELIGIBLE: مبلغ التمويل أكبر من الحد الأقصى المسموح به (' || v_product_max_amount || ')';
        RETURN v_result;
    END IF;
    
    -- التحقق من مدة التمويل
    IF p_financing_period < v_product_min_period THEN
        v_result := 'NOT_ELIGIBLE: مدة التمويل أقل من الحد الأدنى المسموح به (' || v_product_min_period || ' شهر)';
        RETURN v_result;
    END IF;
    
    IF p_financing_period > v_product_max_period THEN
        v_result := 'NOT_ELIGIBLE: مدة التمويل أكبر من الحد الأقصى المسموح به (' || v_product_max_period || ' شهر)';
        RETURN v_result;
    END IF;
    
    -- حساب قيمة القسط الشهري التقريبية
    v_installment_amount := ROUND((p_financing_amount * (1 + (v_profit_rate/100 * p_financing_period/12))) / p_financing_period, 2);
    
    -- حساب نسبة الأقساط إلى الدخل
    v_dti_ratio := CALCULATE_DTI_RATIO(p_customer_id, v_installment_amount);
    
    -- التحقق من نسبة الأقساط إلى الدخل
    IF v_dti_ratio > v_max_dti_ratio THEN
        v_result := 'NOT_ELIGIBLE: نسبة الأقساط إلى الدخل (' || ROUND(v_dti_ratio, 2) || '%) تتجاوز الحد المسموح به (' || v_max_dti_ratio || '%)';
        RETURN v_result;
    END IF;
    
    -- التحقق من وجود أقساط متأخرة
    DECLARE
        v_overdue_count NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO v_overdue_count
        FROM INSTALLMENT_SCHEDULE is1
        JOIN FINANCING_CONTRACTS fc ON is1.REQUEST_ID = fc.REQUEST_ID
        WHERE fc.CUSTOMER_ID = p_customer_id
        AND is1.INSTALLMENT_STATUS = 'OVERDUE';
        
        IF v_overdue_count > 0 THEN
            v_result := 'NOT_ELIGIBLE: يوجد لدى العميل ' || v_overdue_count || ' قسط متأخر';
            RETURN v_result;
        END IF;
    END;
    
    RETURN v_result;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'NOT_ELIGIBLE: بيانات المنتج أو العميل غير متوفرة';
    WHEN OTHERS THEN
        RETURN 'ERROR: ' || SQLERRM;
END CHECK_CUSTOMER_ELIGIBILITY;
/


CREATE OR REPLACE FUNCTION GET_CUSTOMER_ACTIVE_FINANCING(
    p_customer_id IN NUMBER
) RETURN NUMBER IS
    v_total NUMBER;
BEGIN
    SELECT NVL(SUM(REMAINING_AMOUNT), 0)
    INTO v_total
    FROM FINANCING_CONTRACTS
    WHERE CUSTOMER_ID = p_customer_id
    AND CONTRACT_STATUS = 'ACTIVE';
    
    RETURN v_total;
END GET_CUSTOMER_ACTIVE_FINANCING;
/


CREATE OR REPLACE FUNCTION                GET_CUSTOMER_OVERDUE_AMOUNT(
    p_customer_id IN NUMBER
) RETURN NUMBER IS
    v_total NUMBER;
BEGIN
    SELECT NVL(SUM(is1.TOTAL_AMOUNT), 0)
    INTO v_total
    FROM INSTALLMENT_SCHEDULE is1
    JOIN FINANCING_CONTRACTS fc ON is1.REQUEST_ID = fc.REQUEST_ID
    WHERE fc.CUSTOMER_ID = p_customer_id
    AND is1.INSTALLMENT_STATUS = 'OVERDUE';
    
    RETURN v_total;
END GET_CUSTOMER_OVERDUE_AMOUNT;
/


CREATE OR REPLACE FUNCTION GET_CUSTOMER_TOTAL_FINANCING(
    p_customer_id IN NUMBER
) RETURN NUMBER IS
    v_total NUMBER;
BEGIN
    SELECT NVL(SUM(FINANCING_AMOUNT), 0)
    INTO v_total
    FROM FINANCING_CONTRACTS
    WHERE CUSTOMER_ID = p_customer_id
    AND CONTRACT_STATUS IN ('ACTIVE', 'COMPLETED');
    
    RETURN v_total;
END GET_CUSTOMER_TOTAL_FINANCING;
/


CREATE OR REPLACE FUNCTION                API_CREATE_FINANCING_REQUEST(
    p_customer_id IN NUMBER,
    p_product_id IN NUMBER,
    p_financing_amount IN NUMBER,
    p_financing_period IN NUMBER,
    p_purpose IN VARCHAR2,
    p_created_by IN NUMBER
) RETURN CLOB IS
    v_request_id NUMBER;
    v_eligibility VARCHAR2(1000);
BEGIN
    -- التحقق من أهلية العميل
    v_eligibility := CHECK_CUSTOMER_ELIGIBILITY(
        p_customer_id, p_product_id, p_financing_amount, p_financing_period
    );
    
    IF v_eligibility <> 'ELIGIBLE' THEN
        RETURN JSON_OBJECT(
            'success' VALUE FALSE,
            'message' VALUE 'العميل غير مؤهل للتمويل',
            'eligibility_message' VALUE v_eligibility
        );
    END IF;
    
    -- إنشاء طلب التمويل
    ---PKG_FINANCING.CREATE_FINANCING_REQUEST
    CREATE_FINANCING_REQUEST
    (
        p_customer_id => p_customer_id,
        p_product_id => p_product_id,
        p_financing_amount => p_financing_amount,
        p_financing_period => p_financing_period,
        p_purpose => p_purpose,
        p_created_by => p_created_by,
        p_request_id => v_request_id
    );
    
  
    -- إنشاء الاستجابة بتنسيق JSON
    RETURN JSON_OBJECT(
        'success' VALUE TRUE,
        'request_id' VALUE v_request_id,
        'message' VALUE 'تم إنشاء طلب التمويل بنجاح'
    );
EXCEPTION
    WHEN OTHERS THEN
        RETURN JSON_OBJECT(
            'success' VALUE FALSE,
            'message' VALUE 'حدث خطأ أثناء إنشاء طلب التمويل',
            'error' VALUE SQLERRM
        );
END API_CREATE_FINANCING_REQUEST;
/


CREATE OR REPLACE FUNCTION                CALCULATE_CUSTOMER_RATING(
    p_customer_id IN NUMBER
) RETURN VARCHAR2 IS
    v_total_financing NUMBER;
    v_active_financing NUMBER;
    v_overdue_amount NUMBER;
    v_monthly_income NUMBER;
    v_dti_ratio NUMBER;
    v_payment_history NUMBER;
    v_rating_score NUMBER := 0;
    v_rating VARCHAR2(2);
BEGIN
    -- الحصول على بيانات العميل
    SELECT MONTHLY_INCOME
    INTO v_monthly_income
    FROM CUSTOMERS
    WHERE CUSTOMER_ID = p_customer_id;
    
    -- حساب إجمالي التمويلات
    v_total_financing := GET_CUSTOMER_TOTAL_FINANCING(p_customer_id);
    
    -- حساب التمويلات النشطة
    v_active_financing := GET_CUSTOMER_ACTIVE_FINANCING(p_customer_id);
    
    -- حساب المبالغ المتأخرة
    v_overdue_amount := GET_CUSTOMER_OVERDUE_AMOUNT(p_customer_id);
    
    -- حساب نسبة الأقساط إلى الدخل
    v_dti_ratio := CALCULATE_DTI_RATIO(p_customer_id);
    
    -- حساب تاريخ السداد (عدد الأقساط المدفوعة في الوقت المحدد)
    SELECT COUNT(*)
    INTO v_payment_history
    FROM INSTALLMENT_SCHEDULE is1
    JOIN FINANCING_CONTRACTS fc ON is1.REQUEST_ID = fc.REQUEST_ID
    WHERE fc.CUSTOMER_ID = p_customer_id
    AND is1.INSTALLMENT_STATUS = 'PAID'
    AND is1.PAYMENT_DATE <= is1.DUE_DATE;
    
    -- حساب درجة التصنيف
    -- 1. تاريخ السداد (40 نقطة)
    IF v_payment_history > 20 THEN
        v_rating_score := v_rating_score + 40;
    ELSIF v_payment_history > 10 THEN
        v_rating_score := v_rating_score + 30;
    ELSIF v_payment_history > 5 THEN
        v_rating_score := v_rating_score + 20;
    ELSIF v_payment_history > 0 THEN
        v_rating_score := v_rating_score + 10;
    END IF;
    
    -- 2. نسبة الأقساط إلى الدخل (30 نقطة)
    IF v_dti_ratio IS NULL OR v_dti_ratio = 0 THEN
        v_rating_score := v_rating_score + 30;
    ELSIF v_dti_ratio < 20 THEN
        v_rating_score := v_rating_score + 30;
    ELSIF v_dti_ratio < 30 THEN
        v_rating_score := v_rating_score + 25;
    ELSIF v_dti_ratio < 40 THEN
        v_rating_score := v_rating_score + 15;
    ELSIF v_dti_ratio < 50 THEN
        v_rating_score := v_rating_score + 5;
    END IF;
    
    -- 3. المبالغ المتأخرة (30 نقطة)
    IF v_overdue_amount = 0 THEN
        v_rating_score := v_rating_score + 30;
    ELSIF v_overdue_amount < (v_monthly_income * 0.1) THEN
        v_rating_score := v_rating_score + 20;
    ELSIF v_overdue_amount < (v_monthly_income * 0.3) THEN
        v_rating_score := v_rating_score + 10;
    END IF;
    
    -- تحديد التصنيف النهائي
    IF v_rating_score >= 90 THEN
        v_rating := 'A+';
    ELSIF v_rating_score >= 80 THEN
        v_rating := 'A';
    ELSIF v_rating_score >= 70 THEN
        v_rating := 'B+';
    ELSIF v_rating_score >= 60 THEN
        v_rating := 'B';
    ELSIF v_rating_score >= 50 THEN
        v_rating := 'C+';
    ELSIF v_rating_score >= 40 THEN
        v_rating := 'C';
    ELSIF v_rating_score >= 30 THEN
        v_rating := 'D';
    ELSE
        v_rating := 'E';
    END IF;
    
    RETURN v_rating;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'N/A';
    WHEN OTHERS THEN
        RETURN 'ERR';
END CALCULATE_CUSTOMER_RATING;
/


CREATE OR REPLACE FUNCTION                API_CHECK_ELIGIBILITY(
    p_customer_id IN NUMBER,
    p_product_id IN NUMBER,
    p_financing_amount IN NUMBER,
    p_financing_period IN NUMBER
) RETURN CLOB IS
    v_eligibility VARCHAR2(1000);
    v_product_name VARCHAR2(100);
    v_customer_name VARCHAR2(100);
    v_profit_rate NUMBER;
    v_installment_amount NUMBER;
    v_total_amount NUMBER;
    v_profit_amount NUMBER;
    v_dti_ratio NUMBER;
BEGIN
    -- الحصول على بيانات المنتج والعميل
    SELECT PRODUCT_NAME, PROFIT_RATE INTO v_product_name, v_profit_rate
    FROM ISLAMIC_PRODUCTS
    WHERE PRODUCT_ID = p_product_id;
    
    SELECT FULL_NAME INTO v_customer_name
    FROM CUSTOMERS
    WHERE CUSTOMER_ID = p_customer_id;
    
    -- التحقق من الأهلية
    v_eligibility := CHECK_CUSTOMER_ELIGIBILITY(
        p_customer_id, p_product_id, p_financing_amount, p_financing_period
    );
    
    -- حساب قيمة القسط الشهري التقريبية
    v_installment_amount := ROUND((p_financing_amount * (1 + (v_profit_rate/100 * p_financing_period/12))) / p_financing_period, 2);
    
    -- حساب إجمالي المبلغ المستحق
    v_total_amount := v_installment_amount * p_financing_period;
    
    -- حساب مبلغ الربح
    v_profit_amount := v_total_amount - p_financing_amount;
    
    -- حساب نسبة الأقساط إلى الدخل
    v_dti_ratio := CALCULATE_DTI_RATIO(p_customer_id, v_installment_amount);
    
    -- إنشاء الاستجابة بتنسيق JSON
    RETURN JSON_OBJECT(
        'customer_id' VALUE p_customer_id,
        'customer_name' VALUE v_customer_name,
        'product_id' VALUE p_product_id,
        'product_name' VALUE v_product_name,
        'financing_amount' VALUE p_financing_amount,
        'financing_period' VALUE p_financing_period,
        'profit_rate' VALUE v_profit_rate,
        'installment_amount' VALUE v_installment_amount,
        'total_amount' VALUE v_total_amount,
        'profit_amount' VALUE v_profit_amount,
        'dti_ratio' VALUE v_dti_ratio,
        'is_eligible' VALUE CASE WHEN v_eligibility = 'ELIGIBLE' THEN TRUE ELSE FALSE END,
        'eligibility_message' VALUE v_eligibility,
        'customer_rating' VALUE CALCULATE_CUSTOMER_RATING(p_customer_id)
    );
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN JSON_OBJECT('error' VALUE 'Customer or product not found');
    WHEN OTHERS THEN
        RETURN JSON_OBJECT('error' VALUE SQLERRM);
END API_CHECK_ELIGIBILITY;
/


CREATE OR REPLACE FUNCTION                API_GET_CUSTOMER_INFO(
    p_customer_id IN NUMBER
) RETURN CLOB IS
    v_result CLOB;
BEGIN
    SELECT JSON_OBJECT(
        'customer_id' VALUE c.CUSTOMER_ID,
        'full_name' VALUE c.FULL_NAME,
        'national_id' VALUE c.NATIONAL_ID,
        'mobile_number' VALUE c.MOBILE_NUMBER,
        'email' VALUE c.EMAIL,
        'monthly_income' VALUE c.MONTHLY_INCOME,
        'customer_segment' VALUE c.CUSTOMER_TYPE,
        'customer_status' VALUE c.CUSTOMER_STATUS,
        'customer_rating' VALUE CALCULATE_CUSTOMER_RATING(c.CUSTOMER_ID),
        'dti_ratio' VALUE CALCULATE_DTI_RATIO(c.CUSTOMER_ID),
        'total_financing' VALUE GET_CUSTOMER_TOTAL_FINANCING(c.CUSTOMER_ID),
        'active_financing' VALUE GET_CUSTOMER_ACTIVE_FINANCING(c.CUSTOMER_ID),
        'overdue_amount' VALUE GET_CUSTOMER_OVERDUE_AMOUNT(c.CUSTOMER_ID),
        'contracts' VALUE (
            SELECT JSON_ARRAYAGG(
                JSON_OBJECT(
                    'financing_id' VALUE fc.FINANCING_ID,
                    'contract_number' VALUE fc.CONTRACT_NUMBER,
                    'product_name' VALUE ip.PRODUCT_NAME,
                    'financing_amount' VALUE fc.FINANCING_AMOUNT,
                    'remaining_amount' VALUE fc.REMAINING_AMOUNT,
                    'start_date' VALUE TO_CHAR(fc.START_DATE, 'YYYY-MM-DD'),
                    'end_date' VALUE TO_CHAR(fc.END_DATE, 'YYYY-MM-DD'),
                    'contract_status' VALUE fc.CONTRACT_STATUS
                )
            )
            FROM FINANCING_CONTRACTS fc
            JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
            WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID
        )
    ) INTO v_result
    FROM CUSTOMERS c
    WHERE c.CUSTOMER_ID = p_customer_id;
    
    RETURN v_result;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN JSON_OBJECT('error' VALUE 'Customer not found');
    WHEN OTHERS THEN
        RETURN JSON_OBJECT('error' VALUE SQLERRM);
END API_GET_CUSTOMER_INFO;
/

CREATE OR REPLACE PROCEDURE                CLEANUP_JOB_LOGS AS
    v_retention_days NUMBER := 30; -- الاحتفاظ بالسجلات لمدة 30 يوم
    v_deleted_count NUMBER := 0;P_ERR_MSG VARCHAR2(1001);
BEGIN
/*
    -- حذف سجلات تنفيذ الوظائف المجدولة القديمة
    DELETE FROM user_scheduler_job_run_details
    WHERE log_date < (SYSDATE - v_retention_days);
    */
    v_deleted_count := SQL%ROWCOUNT;
    
    -- تسجيل نتيجة التنظيف
    INSERT INTO SYSTEM_LOGS (
        LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
    ) VALUES (
        'SCHEDULED_JOB', 'تنظيف سجلات تنفيذ الوظائف المجدولة', 
        'تم حذف ' || v_deleted_count || ' سجل من سجلات تنفيذ الوظائف المجدولة القديمة.',
        1
    );
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
        ---
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'ERROR', 'خطأ في تنظيف سجلات تنفيذ الوظائف المجدولة', 
            P_ERR_MSG,
            1
        );
        
        COMMIT;
END CLEANUP_JOB_LOGS;
/


CREATE OR REPLACE PROCEDURE                CREATE_FINANCING_REQUEST(
    p_customer_id IN NUMBER,
    p_product_id IN NUMBER,
    p_financing_amount IN NUMBER,
    p_financing_period IN NUMBER,
    p_purpose IN VARCHAR2,
    p_created_by IN NUMBER,
    p_request_id OUT NUMBER
) AS
BEGIN
    INSERT INTO FINANCING_REQUESTS (
        REQUEST_ID, CUSTOMER_ID, PRODUCT_ID, REQUESTED_AMOUNT,
        FINANCING_PERIOD, PURPOSE, REQUEST_STATUS,
        CREATED_BY, CREATED_DATE
    ) VALUES (
        SEQ_FINANCING_REQUEST_ID.NEXTVAL, p_customer_id, p_product_id, p_financing_amount,
        p_financing_period, p_purpose, 'PENDING',
        p_created_by, SYSTIMESTAMP
    )
    RETURNING REQUEST_ID INTO p_request_id;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END CREATE_FINANCING_REQUEST;
/


CREATE OR REPLACE PROCEDURE                CREATE_INSTALLMENT_SCHEDULE(
    p_financing_id IN NUMBER,
    p_start_date IN DATE,
    p_financing_amount IN NUMBER,
    p_profit_rate IN NUMBER,
    p_financing_period IN NUMBER,
    p_created_by IN NUMBER
) AS
    v_installment_amount NUMBER;
    v_principal_amount NUMBER;
    v_profit_amount NUMBER;
    v_remaining_amount NUMBER := p_financing_amount;
    v_due_date DATE := p_start_date;
    v_installment_number NUMBER := 1;
BEGIN
    -- حساب قيمة القسط الشهري (تقريبي - طريقة القسط الثابت)
    v_installment_amount := ROUND((p_financing_amount * (1 + (p_profit_rate/100 * p_financing_period/12))) / p_financing_period, 2);
    
    -- إنشاء جدول الأقساط
    FOR i IN 1..p_financing_period LOOP
        -- حساب مكونات القسط
        v_profit_amount := ROUND(v_remaining_amount * (p_profit_rate/100) / 12, 2);
        v_principal_amount := v_installment_amount - v_profit_amount;
        
        -- تعديل القسط الأخير لضمان تساوي المبلغ الإجمالي مع المبلغ الأصلي + الربح
        IF i = p_financing_period THEN
            v_principal_amount := v_remaining_amount;
            v_installment_amount := v_principal_amount + v_profit_amount;
        END IF;
        
        -- إضافة القسط إلى الجدول
        INSERT INTO INSTALLMENT_SCHEDULE (
            INSTALLMENT_ID, REQUEST_ID, INSTALLMENT_SEQ, TOTAL_AMOUNT,
            PRINCIPAL_AMOUNT, PROFIT_AMOUNT, DUE_DATE, INSTALLMENT_STATUS,
            CREATED_BY, CREATED_DATE
        ) VALUES (
            SEQ_INSTALLMENT_ID.NEXTVAL, p_financing_id, v_installment_number, v_installment_amount,
            v_principal_amount, v_profit_amount, v_due_date, 'PENDING',
            p_created_by, SYSTIMESTAMP
        );
        
        -- تحديث المتغيرات للقسط التالي
        v_remaining_amount := v_remaining_amount - v_principal_amount;
        v_due_date := ADD_MONTHS(v_due_date, 1);
        v_installment_number := v_installment_number + 1;
    END LOOP;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END CREATE_INSTALLMENT_SCHEDULE;
/


CREATE OR REPLACE PROCEDURE                LOG_JOB_EXECUTION (
    p_job_name IN VARCHAR2,
    p_status IN VARCHAR2,
    p_details IN VARCHAR2 DEFAULT NULL
) AS
---
P_ERR_MSG VARCHAR2(1001);
---
BEGIN
    INSERT INTO SYSTEM_LOGS (
        LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
    ) VALUES (
        'SCHEDULED_JOB', 'تنفيذ وظيفة مجدولة: ' || p_status, 
        'الوظيفة المجدولة: ' || p_job_name || CHR(10) || 
        'الحالة: ' || p_status || CHR(10) || 
        'التفاصيل: ' || NVL(p_details, 'لا توجد تفاصيل') || CHR(10) || 
        'وقت التنفيذ: ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS'),
        1
    );
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        P_ERR_MSG:='الخطأ: ' || SQLERRM;
        ---
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'ERROR', 'خطأ في تسجيل تنفيذ وظيفة مجدولة', 
            'الوظيفة المجدولة: ' || p_job_name || CHR(10) || 
            P_ERR_MSG,
            1
        );
        
        COMMIT;
END LOG_JOB_EXECUTION;
/


CREATE OR REPLACE PROCEDURE                REGISTER_PAYMENT(
    p_financing_id IN NUMBER,
    p_installment_id IN NUMBER,
    p_payment_amount IN NUMBER,
    p_payment_method IN VARCHAR2,
    p_payment_reference IN VARCHAR2,
    p_payment_date IN DATE,
    p_created_by IN NUMBER,
    p_payment_id OUT NUMBER
) AS
    v_contract_status VARCHAR2(20);
BEGIN
    -- التحقق من حالة عقد التمويل
    SELECT CONTRACT_STATUS INTO v_contract_status
    FROM FINANCING_CONTRACTS
    WHERE FINANCING_ID = p_financing_id;
    
    IF v_contract_status <> 'ACTIVE' THEN
        RAISE_APPLICATION_ERROR(-20001, 'لا يمكن تسجيل دفعة لعقد تمويل غير نشط');
    END IF;
    
    -- تسجيل الدفعة
    INSERT INTO PAYMENTS (
        PAYMENT_ID, FINANCING_ID, INSTALLMENT_ID, PAYMENT_AMOUNT,
        PAYMENT_METHOD, PAYMENT_REFERENCE, PAYMENT_DATE, PAYMENT_STATUS,
        CREATED_BY, CREATION_DATE
    ) VALUES (
        SEQ_PAYMENT_ID.NEXTVAL, p_financing_id, p_installment_id, p_payment_amount,
        p_payment_method, p_payment_reference, p_payment_date, 'COMPLETED',
        p_created_by, SYSTIMESTAMP
    )
    RETURNING PAYMENT_ID INTO p_payment_id;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END REGISTER_PAYMENT;
/


CREATE OR REPLACE PROCEDURE RESTART_FAILED_JOBS AS
    CURSOR c_failed_jobs IS
        SELECT job_name
        FROM user_scheduler_jobs
        WHERE enabled = 'TRUE'
        AND state = 'BROKEN';
        ---
        P_ERR_MSG VARCHAR2(1001);
        ---
BEGIN
-- إنشاء إجراء لإعادة تشغيل الوظائف المجدولة المتوقفة
---
    FOR job_rec IN c_failed_jobs LOOP
        BEGIN
            DBMS_SCHEDULER.STOP_JOB(job_rec.job_name, force => TRUE);
            DBMS_SCHEDULER.ENABLE(job_rec.job_name);
            
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'SCHEDULED_JOB', 'إعادة تشغيل وظيفة مجدولة', 
                'تم إعادة تشغيل الوظيفة المجدولة: ' || job_rec.job_name,
                1
            );
        EXCEPTION
            WHEN OTHERS THEN
            ---
            P_ERR_MSG:='فشل في إعادة تشغيل الوظيفة المجدولة: ' || job_rec.job_name ||' - الخطأ: ' || SQLERRM;
            ---
                INSERT INTO SYSTEM_LOGS (
                    LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
                ) VALUES (
                    'ERROR', 'فشل في إعادة تشغيل وظيفة مجدولة', 
                    P_ERR_MSG,
                    1
                );
        END;
    END LOOP;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
        ---
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'ERROR', 'خطأ عام في إعادة تشغيل الوظائف المجدولة', 
            P_ERR_MSG,
            1
        );
        
        COMMIT;
END RESTART_FAILED_JOBS;
/


CREATE OR REPLACE PROCEDURE                SEND_INSTALLMENT_REMINDERS(
    p_days_before IN NUMBER DEFAULT 5
) AS
    CURSOR c_upcoming_installments IS
        SELECT is1.INSTALLMENT_ID, is1.REQUEST_ID, fc.CUSTOMER_ID, c.FULL_NAME, c.MOBILE_NUMBER, c.EMAIL,
               is1.INSTALLMENT_SEQ, is1.TOTAL_AMOUNT, is1.DUE_DATE
        FROM INSTALLMENT_SCHEDULE is1
        JOIN FINANCING_CONTRACTS fc ON is1.REQUEST_ID = fc.REQUEST_ID
        JOIN CUSTOMERS c ON fc.CUSTOMER_ID = c.CUSTOMER_ID
        WHERE is1.INSTALLMENT_STATUS = 'PENDING'
        AND is1.DUE_DATE BETWEEN SYSDATE AND SYSDATE + p_days_before;
    
    v_reminder_text VARCHAR2(4000);
    v_reminder_id NUMBER;
BEGIN
    FOR r_installment IN c_upcoming_installments LOOP
        -- إنشاء نص التذكير
        v_reminder_text := 'تذكير: يستحق القسط رقم ' || r_installment.INSTALLMENT_SEQ || 
                          ' بقيمة ' || r_installment.TOTAL_AMOUNT || 
                          ' ريال بتاريخ ' || TO_CHAR(r_installment.DUE_DATE, 'DD/MM/YYYY') ||
                          '. نشكر لكم التزامكم بالسداد في الموعد المحدد.';
        
        -- تسجيل رسالة التذكير
        INSERT INTO REMINDER_MESSAGES (
            MESSAGE_ID, CUSTOMER_ID, REMINDER_TYPE, REMINDER_TEXT,
            MESSAGE_TYPE, INSTALLMENT_ID, SEND_DATE, DELIVERY_STATUS,
            CREATED_DATE
        ) VALUES (
            SEQ_REMINDER_ID.NEXTVAL, r_installment.CUSTOMER_ID, 'INSTALLMENT', v_reminder_text,
            'INSTALLMENT', r_installment.INSTALLMENT_ID, SYSDATE, 'PENDING',
            SYSTIMESTAMP
        ) RETURNING MESSAGE_ID INTO v_reminder_id;
        
        -- يمكن إضافة منطق إرسال الرسائل النصية أو البريد الإلكتروني هنا
        -- (تنفيذ فعلي للإرسال سيتطلب استدعاء خدمات خارجية)
        
        -- تحديث حالة التذكير
        UPDATE REMINDER_MESSAGES
        SET DELIVERY_STATUS = 'SENT',
            UPDATED_DATE = SYSTIMESTAMP
        WHERE MESSAGE_ID = v_reminder_id;
    END LOOP;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END SEND_INSTALLMENT_REMINDERS;
/


CREATE OR REPLACE PROCEDURE START_ALL_JOBS AS
    CURSOR c_disabled_jobs IS
        SELECT job_name
        FROM user_scheduler_jobs
        WHERE enabled = 'FALSE';
        ---
        P_ERR_MSG VARCHAR2(1001);
        ---
BEGIN
-- إنشاء إجراء لتشغيل جميع الوظائف المجدولة (بعد الصيانة)
    FOR job_rec IN c_disabled_jobs LOOP
        BEGIN
            DBMS_SCHEDULER.ENABLE(job_rec.job_name);
            
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'SCHEDULED_JOB', 'تشغيل وظيفة مجدولة', 
                'تم تشغيل الوظيفة المجدولة: ' || job_rec.job_name,
                1
            );
        EXCEPTION
            WHEN OTHERS THEN
            P_ERR_MSG:=' - الخطأ: ' || SQLERRM;
            ---
                INSERT INTO SYSTEM_LOGS (
                    LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
                ) VALUES (
                    'ERROR', 'فشل في تشغيل وظيفة مجدولة', 
                    'فشل في تشغيل الوظيفة المجدولة: ' || job_rec.job_name || 
                    P_ERR_MSG,
                    1
                );
        END;
    END LOOP;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
        ---
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'ERROR', 'خطأ عام في تشغيل الوظائف المجدولة', 
            P_ERR_MSG,
            1
        );
        
        COMMIT;
END START_ALL_JOBS;
/


CREATE OR REPLACE PROCEDURE STOP_ALL_JOBS AS
    CURSOR c_active_jobs IS
        SELECT job_name
        FROM user_scheduler_jobs
        WHERE enabled = 'TRUE';
        ---
        P_ERR_MSG VARCHAR2(1001);
        ---
BEGIN
-- إنشاء إجراء لإيقاف جميع الوظائف المجدولة (للصيانة)
---
    FOR job_rec IN c_active_jobs LOOP
        BEGIN
            DBMS_SCHEDULER.DISABLE(job_rec.job_name, force => TRUE);
            
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'SCHEDULED_JOB', 'إيقاف وظيفة مجدولة', 
                'تم إيقاف الوظيفة المجدولة: ' || job_rec.job_name,
                1
            );
        EXCEPTION
            WHEN OTHERS THEN
            ---
            P_ERR_MSG:=' - الخطأ: ' || SQLERRM;
            ---
                INSERT INTO SYSTEM_LOGS (
                    LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
                ) VALUES (
                    'ERROR', 'فشل في إيقاف وظيفة مجدولة', 
                    'فشل في إيقاف الوظيفة المجدولة: ' || job_rec.job_name || 
                    P_ERR_MSG,
                    1
                );
        END;
    END LOOP;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
        ---
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'ERROR', 'خطأ عام في إيقاف الوظائف المجدولة', 
            P_ERR_MSG,
            1
        );
        
        COMMIT;
END STOP_ALL_JOBS;
/


CREATE OR REPLACE PROCEDURE TEST_GET_SYSTEM_NOTIFICATIONS(
    p_user_id IN NUMBER,
    p_user_roles IN VARCHAR2 DEFAULT NULL
) AS
    v_notifications SYS_REFCURSOR;
    v_notification_id NUMBER;
    v_notification_type VARCHAR2(50);
    v_notification_title VARCHAR2(200);
    v_notification_message VARCHAR2(4000);
    v_start_date DATE;
    v_end_date DATE;
    v_target_users VARCHAR2(1000);
    v_target_roles VARCHAR2(1000);
    v_creation_date DATE;
    v_count NUMBER := 0;
BEGIN
    -- الحصول على الإشعارات النشطة للمستخدم
    v_notifications := PKG_NOTIFICATIONS.GET_ACTIVE_SYSTEM_NOTIFICATIONS(
        p_user_id => p_user_id,
        p_user_roles => p_user_roles
    );
    
    -- عرض الإشعارات
    DBMS_OUTPUT.PUT_LINE('الإشعارات النشطة للمستخدم رقم ' || p_user_id || ':');
    DBMS_OUTPUT.PUT_LINE('-------------------------------------------');
    
    LOOP
        FETCH v_notifications INTO 
            v_notification_id, v_notification_type, v_notification_title,
            v_notification_message, v_start_date, v_end_date,
            v_target_users, v_target_roles, v_creation_date;
            
        EXIT WHEN v_notifications%NOTFOUND;
        
        v_count := v_count + 1;
        
        DBMS_OUTPUT.PUT_LINE('الإشعار رقم: ' || v_notification_id);
        DBMS_OUTPUT.PUT_LINE('النوع: ' || v_notification_type);
        DBMS_OUTPUT.PUT_LINE('العنوان: ' || v_notification_title);
        DBMS_OUTPUT.PUT_LINE('الرسالة: ' || v_notification_message);
        DBMS_OUTPUT.PUT_LINE('تاريخ البدء: ' || TO_CHAR(v_start_date, 'DD/MM/YYYY'));
        
        IF v_end_date IS NOT NULL THEN
            DBMS_OUTPUT.PUT_LINE('تاريخ الانتهاء: ' || TO_CHAR(v_end_date, 'DD/MM/YYYY'));
        ELSE
            DBMS_OUTPUT.PUT_LINE('تاريخ الانتهاء: غير محدد');
        END IF;
        
        DBMS_OUTPUT.PUT_LINE('المستخدمون المستهدفون: ' || NVL(v_target_users, 'الكل'));
        DBMS_OUTPUT.PUT_LINE('الأدوار المستهدفة: ' || NVL(v_target_roles, 'الكل'));
        DBMS_OUTPUT.PUT_LINE('تاريخ الإنشاء: ' || TO_CHAR(v_creation_date, 'DD/MM/YYYY HH24:MI:SS'));
        DBMS_OUTPUT.PUT_LINE('-------------------------------------------');
    END LOOP;
    
    CLOSE v_notifications;
    
    IF v_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('لا توجد إشعارات نشطة للمستخدم.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('إجمالي الإشعارات النشطة: ' || v_count);
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        IF v_notifications%ISOPEN THEN
            CLOSE v_notifications;
        END IF;
        DBMS_OUTPUT.PUT_LINE('حدث خطأ: ' || SQLERRM);
END TEST_GET_SYSTEM_NOTIFICATIONS;
/


CREATE OR REPLACE PROCEDURE TEST_SEND_SYSTEM_NOTIFICATION AS
    v_notification_id NUMBER;
BEGIN
    -- اختبار إرسال إشعار نظام عام
    PKG_NOTIFICATIONS.SEND_SYSTEM_NOTIFICATION(
        p_notification_type => 'ANNOUNCEMENT',
        p_notification_title => 'إطلاق منتج تمويل جديد',
        p_notification_message => 'يسرنا الإعلان عن إطلاق منتج تمويل جديد "تمويل السيارات الكهربائية" بمعدل ربح تنافسي. لمزيد من المعلومات، يرجى زيارة صفحة المنتجات.',
        p_start_date => SYSDATE,
        p_end_date => ADD_MONTHS(SYSDATE, 1),
        p_target_users => NULL, -- لجميع المستخدمين
        p_target_roles => NULL, -- لجميع الأدوار
        p_created_by => 1,
        p_notification_id => v_notification_id
    );
    
    DBMS_OUTPUT.PUT_LINE('تم إنشاء إشعار النظام برقم: ' || v_notification_id);
    
    -- اختبار إرسال إشعار نظام لمستخدمين محددين
    PKG_NOTIFICATIONS.SEND_SYSTEM_NOTIFICATION(
        p_notification_type => 'MAINTENANCE',
        p_notification_title => 'صيانة مجدولة للنظام',
        p_notification_message => 'سيتم إجراء صيانة مجدولة للنظام يوم الجمعة القادم من الساعة 10 مساءً حتى 2 صباحًا. يرجى إنهاء جميع المعاملات قبل هذا الوقت.',
        p_start_date => SYSDATE,
        p_end_date => SYSDATE + 7,
        p_target_users => '1,2,3,4,5', -- لمستخدمين محددين
        p_target_roles => NULL,
        p_created_by => 1,
        p_notification_id => v_notification_id
    );
    
    DBMS_OUTPUT.PUT_LINE('تم إنشاء إشعار الصيانة برقم: ' || v_notification_id);
    
    -- اختبار إرسال إشعار نظام لأدوار محددة
    PKG_NOTIFICATIONS.SEND_SYSTEM_NOTIFICATION(
        p_notification_type => 'POLICY_UPDATE',
        p_notification_title => 'تحديث سياسة التمويل',
        p_notification_message => 'تم تحديث سياسة التمويل الشخصي. يرجى الاطلاع على التغييرات في دليل السياسات والإجراءات.',
        p_start_date => SYSDATE,
        p_end_date => ADD_MONTHS(SYSDATE, 3),
        p_target_users => NULL,
        p_target_roles => 'CREDIT_OFFICER,BRANCH_MANAGER,RELATIONSHIP_MANAGER', -- لأدوار محددة
        p_created_by => 1,
        p_notification_id => v_notification_id
    );
    
    DBMS_OUTPUT.PUT_LINE('تم إنشاء إشعار تحديث السياسة برقم: ' || v_notification_id);
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('حدث خطأ: ' || SQLERRM);
END TEST_SEND_SYSTEM_NOTIFICATION;
/


CREATE OR REPLACE PROCEDURE                UPDATE_FINANCING_CONTRACT(
    p_financing_id IN NUMBER,
    p_profit_rate IN NUMBER DEFAULT NULL,
    p_installment_count IN NUMBER DEFAULT NULL,
    p_start_date IN DATE DEFAULT NULL,
    p_notes IN VARCHAR2 DEFAULT NULL,
    p_updated_by IN NUMBER
) IS
    v_contract_status VARCHAR2(50);
    v_old_profit_rate NUMBER;
    v_old_installment_count NUMBER;
    v_old_start_date DATE;
    v_old_end_date DATE;
    v_financing_amount NUMBER;
    v_profit_amount NUMBER;
    v_total_amount NUMBER;
    v_installment_amount NUMBER;
    v_end_date DATE;
    v_regenerate_schedule BOOLEAN := FALSE;
BEGIN
    -- الحصول على معلومات العقد الحالية
    SELECT 
        CONTRACT_STATUS, PROFIT_RATE, INSTALLMENT_COUNT,
        START_DATE, FINANCING_AMOUNT, END_DATE
    INTO 
        v_contract_status, v_old_profit_rate, v_old_installment_count,
        v_old_start_date, v_financing_amount, v_old_end_date
    FROM 
        FINANCING_CONTRACTS
    WHERE 
        FINANCING_ID = p_financing_id;
        
    -- التحقق من إمكانية تحديث العقد
    IF v_contract_status NOT IN ('PENDING_APPROVAL', 'APPROVED', 'ACTIVE') THEN
        RAISE_APPLICATION_ERROR(-20013, 'لا يمكن تحديث عقد التمويل في الحالة الحالية: ' || v_contract_status);
    END IF;
        
    -- تحديد ما إذا كان يجب إعادة إنشاء جدول الأقساط
    IF (p_profit_rate IS NOT NULL AND p_profit_rate != v_old_profit_rate) OR
       (p_installment_count IS NOT NULL AND p_installment_count != v_old_installment_count) OR
       (p_start_date IS NOT NULL AND p_start_date != v_old_start_date) THEN
        v_regenerate_schedule := TRUE;
                
        -- حساب القيم الجديدة
        v_profit_amount := ROUND(v_financing_amount * (COALESCE(p_profit_rate, v_old_profit_rate) / 100) *
                             (COALESCE(p_installment_count, v_old_installment_count) / 12), 2);
        v_total_amount := v_financing_amount + v_profit_amount;
        v_installment_amount := ROUND(v_total_amount / COALESCE(p_installment_count, v_old_installment_count), 2);
        v_end_date := ADD_MONTHS(COALESCE(p_start_date, v_old_start_date), COALESCE(p_installment_count, v_old_installment_count));
    END IF;
        
    -- تحديث عقد التمويل
    UPDATE FINANCING_CONTRACTS
    SET
        PROFIT_RATE = COALESCE(p_profit_rate, PROFIT_RATE),
        INSTALLMENT_COUNT = COALESCE(p_installment_count, INSTALLMENT_COUNT),
        START_DATE = COALESCE(p_start_date, START_DATE),
        END_DATE = CASE WHEN v_regenerate_schedule THEN v_end_date ELSE v_old_end_date END,
        PROFIT_AMOUNT = CASE WHEN v_regenerate_schedule THEN v_profit_amount ELSE PROFIT_AMOUNT END,
        TOTAL_AMOUNT = CASE WHEN v_regenerate_schedule THEN v_total_amount ELSE TOTAL_AMOUNT END,
        REMAINING_AMOUNT = CASE WHEN v_regenerate_schedule THEN v_total_amount ELSE REMAINING_AMOUNT END,
        INSTALLMENT_AMOUNT = CASE WHEN v_regenerate_schedule THEN v_installment_amount ELSE INSTALLMENT_AMOUNT END,
        NOTES = CASE WHEN p_notes IS NOT NULL THEN p_notes ELSE NOTES END,
        LAST_UPDATE_DATE = SYSDATE,
        LAST_UPDATED_BY = p_updated_by
    WHERE 
        FINANCING_ID = p_financing_id;
        
    -- إعادة إنشاء جدول الأقساط إذا لزم الأمر
    IF v_regenerate_schedule THEN
        GENERATE_INSTALLMENT_SCHEDULE(p_financing_id, TRUE);
    END IF;
        
    -- إضافة ملاحظة حول التحديث
    INSERT INTO FINANCING_NOTES (
        NOTE_ID, FINANCING_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
    ) VALUES (
        SEQ_NOTE_ID.NEXTVAL, p_financing_id, 
        'تم تحديث عقد التمويل بواسطة المستخدم رقم ' || p_updated_by,
        p_updated_by, SYSDATE
    );
        
    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
    END UPDATE_FINANCING_CONTRACT_TMP;
/


CREATE OR REPLACE PROCEDURE                UPDATE_OVERDUE_INSTALLMENTS AS
BEGIN
    UPDATE INSTALLMENT_SCHEDULE
    SET INSTALLMENT_STATUS = 'OVERDUE',
        UPDATED_DATE = SYSTIMESTAMP
    WHERE INSTALLMENT_STATUS IN ('PENDING', 'PARTIALLY_PAID')
    AND DUE_DATE < SYSDATE;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END UPDATE_OVERDUE_INSTALLMENTS;
/


CREATE OR REPLACE PROCEDURE                CREATE_FINANCING_CONTRACT(
    p_request_id IN NUMBER,
    p_start_date IN DATE,
    p_created_by IN NUMBER,
    p_financing_id OUT NUMBER
) AS
    v_customer_id NUMBER;
    v_product_id NUMBER;
    v_financing_amount NUMBER;
    v_financing_period NUMBER;
    v_purpose VARCHAR2(500);
    v_profit_rate NUMBER;
    v_end_date DATE;
BEGIN
    -- الحصول على بيانات طلب التمويل
    SELECT CUSTOMER_ID, PRODUCT_ID, REQUESTED_AMOUNT, FINANCING_PERIOD, PURPOSE
    INTO v_customer_id, v_product_id, v_financing_amount, v_financing_period, v_purpose
    FROM FINANCING_REQUESTS
    WHERE REQUEST_ID = p_request_id
    AND REQUEST_STATUS = 'APPROVED';
    
    -- الحصول على نسبة الربح من المنتج
    SELECT PROFIT_RATE
    INTO v_profit_rate
    FROM ISLAMIC_PRODUCTS
    WHERE PRODUCT_ID = v_product_id;
    
    -- حساب تاريخ نهاية العقد
    v_end_date := ADD_MONTHS(p_start_date, v_financing_period);
    
    -- إنشاء عقد التمويل
    INSERT INTO FINANCING_CONTRACTS (
        FINANCING_ID, REQUEST_ID, CUSTOMER_ID, PRODUCT_ID,
        FINANCING_AMOUNT, REMAINING_AMOUNT, PROFIT_RATE, FINANCING_PERIOD,
        START_DATE, END_DATE, PURPOSE, CONTRACT_STATUS,
        CREATED_BY, CREATION_DATE
    ) VALUES (
        SEQ_FINANCING_ID.NEXTVAL, p_request_id, v_customer_id, v_product_id,
        v_financing_amount, v_financing_amount, v_profit_rate, v_financing_period,
        p_start_date, v_end_date, v_purpose, 'ACTIVE',
        p_created_by, SYSTIMESTAMP
    )
    RETURNING FINANCING_ID INTO p_financing_id;
    
    -- إنشاء جدول الأقساط
    CREATE_INSTALLMENT_SCHEDULE(
        p_financing_id => p_financing_id,
        p_start_date => p_start_date,
        p_financing_amount => v_financing_amount,
        p_profit_rate => v_profit_rate,
        p_financing_period => v_financing_period,
        p_created_by => p_created_by
    );
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END CREATE_FINANCING_CONTRACT;
/



CREATE OR REPLACE PACKAGE                email_management AS
    -- إرسال بريد إلكتروني
    PROCEDURE send_email(
        p_to IN VARCHAR2,
        p_subject IN VARCHAR2,
        p_body IN CLOB,
        p_cc IN VARCHAR2 DEFAULT NULL,
        p_bcc IN VARCHAR2 DEFAULT NULL,
        p_attachment_path IN VARCHAR2 DEFAULT NULL,
        p_email_id OUT NUMBER
    );
    
    -- إرسال بريد إلكتروني للعميل
    PROCEDURE send_customer_email(
        p_customer_id IN NUMBER,
        p_subject IN VARCHAR2,
        p_body IN CLOB,
        p_attachment_path IN VARCHAR2 DEFAULT NULL,
        p_email_id OUT NUMBER
    );
    
    -- إرسال بريد إلكتروني للمستخدم
    PROCEDURE send_user_email(
        p_user_id IN NUMBER,
        p_subject IN VARCHAR2,
        p_body IN CLOB,
        p_attachment_path IN VARCHAR2 DEFAULT NULL,
        p_email_id OUT NUMBER
    );
    
    -- إرسال بريد إلكتروني للإشعار بالقسط المستحق
    PROCEDURE send_installment_due_notification(
        p_installment_id IN NUMBER,
        p_email_id OUT NUMBER
    );
    
    -- إرسال بريد إلكتروني للإشعار بالقسط المتأخر
    PROCEDURE send_installment_overdue_notification(
        p_installment_id IN NUMBER,
        p_email_id OUT NUMBER
    );
    
    -- إرسال بريد إلكتروني لتأكيد الدفع
    PROCEDURE send_payment_confirmation(
        p_payment_id IN NUMBER,
        p_email_id OUT NUMBER
    );
    
    -- إرسال بريد إلكتروني لإشعار بحالة الطلب
    PROCEDURE send_application_status_notification(
        p_application_id IN NUMBER,
        p_email_id OUT NUMBER
    );
    
    -- إرسال بريد إلكتروني لإعادة تعيين كلمة المرور
    PROCEDURE send_password_reset_email(
        p_user_id IN NUMBER,
        p_reset_token IN VARCHAR2,
        p_email_id OUT NUMBER
    );
    
    -- الحصول على سجل البريد الإلكتروني
    PROCEDURE get_email_log(
        p_email_id IN NUMBER,
        p_result OUT SYS_REFCURSOR
    );
    
    -- الحصول على سجلات البريد الإلكتروني للعميل
    PROCEDURE get_customer_email_logs(
        p_customer_id IN NUMBER,
        p_result OUT SYS_REFCURSOR
    );
END email_management;
/


CREATE OR REPLACE PACKAGE                islamic_financing AS
  -- إجراءات وظيفية للتمويل الإسلامي
  
  -- حساب المرابحة
  FUNCTION calculate_murabaha(
    p_principal_amount IN NUMBER, 
    p_profit_rate IN NUMBER, 
    p_period_months IN NUMBER
  ) RETURN NUMBER;
  
  -- حساب الإجارة
  FUNCTION calculate_ijara(
    p_asset_value IN NUMBER, 
    p_rental_rate IN NUMBER, 
    p_period_months IN NUMBER
  ) RETURN NUMBER;
  
  -- حساب المشاركة
  FUNCTION calculate_musharaka(
    p_project_value IN NUMBER, 
    p_bank_share_pct IN NUMBER, 
    p_expected_profit IN NUMBER
  ) RETURN NUMBER;
  
  -- إنشاء جدول الأقساط
  PROCEDURE create_installment_schedule(
    p_contract_id IN NUMBER, 
    p_total_amount IN NUMBER, 
    p_period_months IN NUMBER, 
    p_start_date IN DATE
  );
  
  -- تسجيل دفعة
  PROCEDURE record_payment(
    p_installment_id IN NUMBER, 
    p_payment_amount IN NUMBER, 
    p_payment_date IN DATE
  );
  
  -- التحقق من صحة المدخلات
  FUNCTION validate_financing_input(
    p_amount IN NUMBER, 
    p_rate IN NUMBER, 
    p_period IN NUMBER
  ) RETURN BOOLEAN;

-- إنشاء عقد تمويل جديد
  PROCEDURE create_financing_contract(
    p_customer_id IN NUMBER,
    p_financing_type IN VARCHAR2,
    p_amount IN NUMBER,
    p_period_months IN NUMBER,
    p_profit_rate IN NUMBER,
    p_start_date IN DATE,
    p_contract_id OUT NUMBER,
    p_status OUT VARCHAR2
  );
  
  -- الحصول على معلومات العقد
  PROCEDURE get_contract_details(
    p_contract_id IN NUMBER,
    p_customer_id OUT NUMBER,
    p_financing_type OUT VARCHAR2,
    p_principal_amount OUT NUMBER,
    p_total_amount OUT NUMBER,
    p_period_months OUT NUMBER,
    p_profit_rate OUT NUMBER,
    p_remaining_amount OUT NUMBER,
    p_status OUT VARCHAR2
  );
  
  -- حساب المبلغ المتبقي للعقد
  FUNCTION calculate_remaining_amount(
    p_contract_id IN NUMBER
  ) RETURN NUMBER;
  
  -- الحصول على الأقساط المتأخرة
  FUNCTION get_overdue_installments(
    p_contract_id IN NUMBER
  ) RETURN SYS_REFCURSOR; 
 
END islamic_financing;
/


CREATE OR REPLACE PACKAGE                PKG_COLLATERALS AS
    -- إضافة ضمان جديد
    PROCEDURE ADD_COLLATERAL(
        p_customer_id IN NUMBER,
        p_collateral_type IN VARCHAR2,
        p_collateral_desc IN VARCHAR2,
        p_estimated_value IN NUMBER,
        p_ownership_document_no IN VARCHAR2,
        p_ownership_status IN VARCHAR2,
        p_notes IN VARCHAR2,
        p_created_by IN NUMBER,
        p_collateral_id OUT NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    -- تحديث بيانات الضمان
    PROCEDURE UPDATE_COLLATERAL(
        p_collateral_id IN NUMBER,
        p_collateral_type IN VARCHAR2,
        p_collateral_desc IN VARCHAR2,
        p_estimated_value IN NUMBER,
        p_ownership_document_no IN VARCHAR2,
        p_ownership_status IN VARCHAR2,
        p_status IN VARCHAR2,
        p_notes IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    -- ربط الضمان بطلب تمويل
    PROCEDURE LINK_COLLATERAL_TO_REQUEST(
        p_collateral_id IN NUMBER,
        p_request_id IN NUMBER,
        p_created_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    -- تقييم كفاية الضمانات لطلب تمويل
    FUNCTION EVALUATE_COLLATERAL_ADEQUACY(
        p_request_id IN NUMBER
    ) RETURN NUMBER;
    
    -- الحصول على قائمة الضمانات للعميل
    FUNCTION GET_CUSTOMER_COLLATERALS(
        p_customer_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- الحصول على تفاصيل ضمان معين
    FUNCTION GET_COLLATERAL_DETAILS(
        p_collateral_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- الحصول على الضمانات المرتبطة بطلب تمويل
    FUNCTION GET_REQUEST_COLLATERALS(
        p_request_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- تحديث قيمة الضمان (إضافة هذا الإجراء لتوافق مع الخطأ المذكور)
    PROCEDURE UPDATE_COLLATERAL_VALUE(
        p_collateral_id IN NUMBER,
        p_new_value IN NUMBER,
        p_valuation_date IN DATE,
        p_valuation_by IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    -- إضافة مستند للضمان (إضافة هذا الإجراء لتوافق مع الخطأ المذكور)
    PROCEDURE ADD_COLLATERAL_DOCUMENT(
        p_collateral_id IN NUMBER,
        p_document_type IN VARCHAR2,
        p_document_name IN VARCHAR2,
        p_document_path IN VARCHAR2,
        p_document_notes IN VARCHAR2,
        p_created_by IN NUMBER,
        p_document_id OUT NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    -- الحصول على مستندات الضمان (إضافة هذه الدالة لتوافق مع الخطأ المذكور)
    FUNCTION GET_COLLATERAL_DOCUMENTS(
        p_collateral_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- حساب نسبة القرض إلى القيمة (إضافة هذه الدالة لتوافق مع الخطأ المذكور)
    FUNCTION CALCULATE_LTV_RATIO(
        p_financing_amount IN NUMBER,
        p_collateral_value IN NUMBER
    ) RETURN NUMBER;
    
END PKG_COLLATERALS;
/


CREATE OR REPLACE PACKAGE PKG_COMMITTEES AS
    -- إنشاء لجنة جديدة
    PROCEDURE CREATE_COMMITTEE(
        p_committee_name IN VARCHAR2,
        p_committee_type IN VARCHAR2,
        p_description IN CLOB,
        p_approval_limit IN NUMBER,
        p_created_by IN NUMBER,
        p_committee_id OUT NUMBER
    );
    
    -- إضافة عضو للجنة
    PROCEDURE ADD_COMMITTEE_MEMBER(
        p_committee_id IN NUMBER,
        p_user_id IN NUMBER,
        p_member_position IN VARCHAR2,
        p_is_chairman IN NUMBER,
        p_created_by IN NUMBER
    );
    
    -- إرسال طلب للجنة
    PROCEDURE SUBMIT_REQUEST_TO_COMMITTEE(
        p_request_id IN NUMBER,
        p_committee_id IN NUMBER,
        p_notes IN CLOB,
        p_created_by IN NUMBER
    );
    
    -- تسجيل قرار اللجنة
    PROCEDURE RECORD_COMMITTEE_DECISION(
        p_request_id IN NUMBER,
        p_committee_id IN NUMBER,
        p_decision IN VARCHAR2,
        p_decision_notes IN CLOB,
        p_decision_date IN DATE,
        p_updated_by IN NUMBER
    );
    
    -- الحصول على اللجان
    FUNCTION GET_COMMITTEES RETURN SYS_REFCURSOR;
    
    -- الحصول على أعضاء اللجنة
    FUNCTION GET_COMMITTEE_MEMBERS(p_committee_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على طلبات اللجنة
    FUNCTION GET_COMMITTEE_REQUESTS(p_committee_id IN NUMBER) RETURN SYS_REFCURSOR;
END PKG_COMMITTEES;
/


CREATE OR REPLACE PACKAGE                PKG_CREDIT_RATING AS
    -- إجراءات ودوال من الإصدار السابق
    -- إضافة معيار تصنيف ائتماني
    PROCEDURE ADD_CREDIT_CRITERIA(
        p_criteria_name IN VARCHAR2,
        p_criteria_type IN VARCHAR2,
        p_max_score IN NUMBER,
        p_weight IN NUMBER,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_criteria_id OUT NUMBER
    );
    
    -- تقييم العميل حسب معيار
    PROCEDURE RATE_CUSTOMER(
        p_customer_id IN NUMBER,
        p_criteria_id IN NUMBER,
        p_score_value IN NUMBER,
        p_created_by IN VARCHAR2,
        p_score_id OUT NUMBER
    );
    
    -- حساب التصنيف الائتماني الإجمالي للعميل
    FUNCTION CALCULATE_CUSTOMER_RATING(
        p_customer_id IN NUMBER
    ) RETURN NUMBER;
    
    -- الحصول على معايير التصنيف
    FUNCTION GET_CREDIT_CRITERIA RETURN SYS_REFCURSOR;
    
    -- الحصول على تقييم العميل
    FUNCTION GET_CUSTOMER_SCORES(
        p_customer_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- إجراءات ودوال من الإصدار الجديد
    -- إجراء لتحديث تصنيف العميل الائتماني
    PROCEDURE UPDATE_CUSTOMER_RATING(
        p_customer_id IN NUMBER,
        p_rating_value IN VARCHAR2 DEFAULT NULL,
        p_rating_score IN NUMBER DEFAULT NULL,
        p_rating_source IN VARCHAR2 DEFAULT 'SYSTEM',
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_created_by IN NUMBER DEFAULT 1
    );
    
    -- إجراء لتهيئة تصنيف العميل الائتماني
    PROCEDURE INITIALIZE_CUSTOMER_RATING(
        p_customer_id IN NUMBER,
        p_created_by IN NUMBER DEFAULT 1
    );
    
    -- دالة للحصول على تصنيف العميل الحالي
    FUNCTION GET_CUSTOMER_RATING(
        p_customer_id IN NUMBER
    ) RETURN VARCHAR2;
    
    -- دالة للحصول على درجة تصنيف العميل الحالية
    FUNCTION GET_CUSTOMER_RATING_SCORE(
        p_customer_id IN NUMBER
    ) RETURN NUMBER;
    
    -- دالة للتحقق من أهلية العميل للتمويل
    FUNCTION IS_CUSTOMER_ELIGIBLE(
        p_customer_id IN NUMBER,
        p_product_id IN NUMBER,
        p_amount IN NUMBER
    ) RETURN BOOLEAN;
    
    -- دالة للحصول على سجل تصنيفات العميل
    FUNCTION GET_CUSTOMER_RATING_HISTORY(
        p_customer_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- إجراء لتحديث تصنيفات العملاء آليًا
    PROCEDURE AUTO_UPDATE_CUSTOMER_RATINGS;
END PKG_CREDIT_RATING;
/


CREATE OR REPLACE PACKAGE PKG_CUSTOMERS AS
    /*
    * حزمة إدارة العملاء
    * تتضمن وظائف وإجراءات لإدارة بيانات العملاء وعمليات الاستعلام والتحديث
    */
    
    -- إضافة عميل جديد
    PROCEDURE ADD_CUSTOMER(
        p_full_name IN VARCHAR2,
        p_national_id IN VARCHAR2,
        p_birth_date IN DATE,
        p_gender IN CHAR,
        p_marital_status IN VARCHAR2,
        p_address IN VARCHAR2,
        p_city IN VARCHAR2,
        p_postal_code IN VARCHAR2,
        p_email IN VARCHAR2,
        p_phone IN VARCHAR2,
        p_mobile IN VARCHAR2,
        p_employer_name IN VARCHAR2,
        p_job_title IN VARCHAR2,
        p_employment_date IN DATE,
        p_monthly_income IN NUMBER,
        p_other_income IN NUMBER,
        p_customer_id OUT NUMBER
    );
    
    -- تحديث بيانات العميل
    PROCEDURE UPDATE_CUSTOMER(
        p_customer_id IN NUMBER,
        p_full_name IN VARCHAR2 DEFAULT NULL,
        p_address IN VARCHAR2 DEFAULT NULL,
        p_city IN VARCHAR2 DEFAULT NULL,
        p_postal_code IN VARCHAR2 DEFAULT NULL,
        p_email IN VARCHAR2 DEFAULT NULL,
        p_phone IN VARCHAR2 DEFAULT NULL,
        p_mobile IN VARCHAR2 DEFAULT NULL,
        p_employer_name IN VARCHAR2 DEFAULT NULL,
        p_job_title IN VARCHAR2 DEFAULT NULL,
        p_employment_date IN DATE DEFAULT NULL,
        p_monthly_income IN NUMBER DEFAULT NULL,
        p_other_income IN NUMBER DEFAULT NULL,
        p_marital_status IN VARCHAR2 DEFAULT NULL
    );
    
    -- الحصول على بيانات العميل
    FUNCTION GET_CUSTOMER(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- البحث عن العملاء
    FUNCTION SEARCH_CUSTOMERS(
        p_name IN VARCHAR2 DEFAULT NULL,
        p_national_id IN VARCHAR2 DEFAULT NULL,
        p_city IN VARCHAR2 DEFAULT NULL,
        p_phone IN VARCHAR2 DEFAULT NULL,
        p_email IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    
    -- إضافة معلومات الدخل للعميل
    PROCEDURE ADD_INCOME_INFO(
        p_customer_id IN NUMBER,
        p_income_source IN VARCHAR2,
        p_income_amount IN NUMBER,
        p_income_frequency IN VARCHAR2,
        p_start_date IN DATE,
        p_end_date IN DATE DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_income_id OUT NUMBER
    );
    
    -- تحديث معلومات الدخل للعميل
    PROCEDURE UPDATE_INCOME_INFO(
        p_income_id IN NUMBER,
        p_income_amount IN NUMBER DEFAULT NULL,
        p_income_frequency IN VARCHAR2 DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL
    );
    
    -- إضافة معلومات الالتزامات المالية للعميل
    PROCEDURE ADD_FINANCIAL_OBLIGATION(
        p_customer_id IN NUMBER,
        p_obligation_type IN VARCHAR2,
        p_creditor_name IN VARCHAR2,
        p_obligation_amount IN NUMBER,
        p_monthly_payment IN NUMBER,
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_obligation_id OUT NUMBER
    );
    
    -- تحديث معلومات الالتزامات المالية للعميل
    PROCEDURE UPDATE_FINANCIAL_OBLIGATION(
        p_obligation_id IN NUMBER,
        p_obligation_amount IN NUMBER DEFAULT NULL,
        p_monthly_payment IN NUMBER DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL
    );
    
    -- الحصول على ملخص التمويلات للعميل
    FUNCTION GET_CUSTOMER_FINANCING_SUMMARY(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على تاريخ المدفوعات للعميل
    FUNCTION GET_CUSTOMER_PAYMENT_HISTORY(
        p_customer_id IN NUMBER,
        p_start_date IN DATE DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    
    -- حساب نسبة الالتزامات إلى الدخل (DTI)
    FUNCTION CALCULATE_DTI_RATIO(p_customer_id IN NUMBER) RETURN NUMBER;
    /*
    -- إضافة معلومات الحساب البنكي للعميل
    PROCEDURE ADD_BANK_ACCOUNT(
        p_customer_id IN NUMBER,
        p_bank_name IN VARCHAR2,
        p_account_number IN VARCHAR2,
        p_iban IN VARCHAR2,
        p_account_type IN VARCHAR2,
        p_branch_name IN VARCHAR2 DEFAULT NULL,
        p_swift_code IN VARCHAR2 DEFAULT NULL,
        p_is_primary IN CHAR DEFAULT 'N',
        p_account_id OUT NUMBER
    );
    */
    /*
    -- تحديث معلومات الحساب البنكي للعميل
    PROCEDURE UPDATE_BANK_ACCOUNT(
        p_account_id IN NUMBER,
        p_bank_name IN VARCHAR2 DEFAULT NULL,
        p_account_number IN VARCHAR2 DEFAULT NULL,
        p_iban IN VARCHAR2 DEFAULT NULL,
        p_account_type IN VARCHAR2 DEFAULT NULL,
        p_branch_name IN VARCHAR2 DEFAULT NULL,
        p_swift_code IN VARCHAR2 DEFAULT NULL,
        p_is_primary IN CHAR DEFAULT NULL
    );
    */
    -- إضافة جهة اتصال للطوارئ
    PROCEDURE ADD_EMERGENCY_CONTACT(
        p_customer_id IN NUMBER,
        p_contact_name IN VARCHAR2,
        p_relationship IN VARCHAR2,
        p_phone IN VARCHAR2,
        p_mobile IN VARCHAR2,
        p_email IN VARCHAR2 DEFAULT NULL,
        p_address IN VARCHAR2 DEFAULT NULL,
        p_contact_id OUT NUMBER
    );
    
    -- تحديث جهة اتصال للطوارئ
    PROCEDURE UPDATE_EMERGENCY_CONTACT(
        p_contact_id IN NUMBER,
        p_contact_name IN VARCHAR2 DEFAULT NULL,
        p_relationship IN VARCHAR2 DEFAULT NULL,
        p_phone IN VARCHAR2 DEFAULT NULL,
        p_mobile IN VARCHAR2 DEFAULT NULL,
        p_email IN VARCHAR2 DEFAULT NULL,
        p_address IN VARCHAR2 DEFAULT NULL
    );
    
    -- تحديث حالة العميل
    PROCEDURE UPDATE_CUSTOMER_STATUS(
        p_customer_id IN NUMBER,
        p_status IN VARCHAR2,
        p_reason IN VARCHAR2 DEFAULT NULL
    );
    
    -- الحصول على تقرير ائتماني للعميل
    FUNCTION GET_CUSTOMER_CREDIT_REPORT(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- إضافة ملاحظة للعميل
    PROCEDURE ADD_CUSTOMER_NOTE(
        p_customer_id IN NUMBER,
        p_note_text IN VARCHAR2,
        p_created_by IN NUMBER,
        p_note_id OUT NUMBER
    );
    
    -- الحصول على ملاحظات العميل
    FUNCTION GET_CUSTOMER_NOTES(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- تحديث تفضيلات الاتصال للعميل
    PROCEDURE UPDATE_CONTACT_PREFERENCES(
        p_customer_id IN NUMBER,
        p_preferred_contact_method IN VARCHAR2,
        p_allow_sms IN CHAR DEFAULT 'Y',
        p_allow_email IN CHAR DEFAULT 'Y',
        p_allow_phone IN CHAR DEFAULT 'Y'
    );
    
    -- الحصول على تفضيلات الاتصال للعميل
    FUNCTION GET_CONTACT_PREFERENCES(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- التحقق من وجود العميل
    FUNCTION CUSTOMER_EXISTS(
        p_national_id IN VARCHAR2
    ) RETURN BOOLEAN;
    
    -- الحصول على عدد العملاء حسب المدينة
    FUNCTION GET_CUSTOMERS_BY_CITY RETURN SYS_REFCURSOR;
    
    -- الحصول على عدد العملاء حسب الفئة العمرية
    FUNCTION GET_CUSTOMERS_BY_AGE_GROUP RETURN SYS_REFCURSOR;
    
    -- الحصول على عدد العملاء حسب فئة الدخل
    FUNCTION GET_CUSTOMERS_BY_INCOME_RANGE RETURN SYS_REFCURSOR;
    
END PKG_CUSTOMERS;
/


CREATE OR REPLACE PACKAGE PKG_DEBT_CLASSIFICATION AS
    -- إضافة تصنيف دين جديد
    PROCEDURE ADD_DEBT_CLASSIFICATION(
        p_classification_name IN VARCHAR2,
        p_min_days_past_due IN NUMBER,
        p_max_days_past_due IN NUMBER,
        p_provision_percentage IN NUMBER,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_classification_id OUT NUMBER
    );
    
    -- حساب المخصصات للطلب
    PROCEDURE CALCULATE_PROVISIONS(
        p_request_id IN NUMBER,
        p_calculation_date IN DATE,
        p_created_by IN VARCHAR2
    );
    
    -- حساب المخصصات لجميع الطلبات
    PROCEDURE CALCULATE_ALL_PROVISIONS(
        p_calculation_date IN DATE,
        p_created_by IN VARCHAR2
    );
    
    -- الحصول على تصنيفات الديون
    FUNCTION GET_DEBT_CLASSIFICATIONS RETURN SYS_REFCURSOR;
    
    -- الحصول على مخصصات الطلب
    FUNCTION GET_REQUEST_PROVISIONS(p_request_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على تقرير المخصصات
    FUNCTION GET_PROVISIONS_REPORT RETURN SYS_REFCURSOR;
END PKG_DEBT_CLASSIFICATION;
/


CREATE OR REPLACE PACKAGE PKG_DOCUMENTS AS
    -- إضافة مستند للعميل
    PROCEDURE ADD_CUSTOMER_DOCUMENT(
        p_customer_id IN NUMBER,
        p_document_type IN VARCHAR2,
        p_document_number IN VARCHAR2,
        p_issue_date IN DATE,
        p_expiry_date IN DATE,
        p_document_path IN VARCHAR2,
        p_created_by IN VARCHAR2,
        p_document_id OUT NUMBER
    );
    
    -- إضافة مستند للطلب
    PROCEDURE ADD_REQUEST_DOCUMENT(
        p_request_id IN NUMBER,
        p_document_type IN VARCHAR2,
        p_document_number IN VARCHAR2,
        p_issue_date IN DATE,
        p_expiry_date IN DATE,
        p_document_path IN VARCHAR2,
        p_created_by IN VARCHAR2,
        p_document_id OUT NUMBER
    );
    
    -- تحديث حالة المستند
    PROCEDURE UPDATE_DOCUMENT_STATUS(
        p_document_id IN NUMBER,
        p_document_status IN VARCHAR2,
        p_notes IN CLOB,
        p_updated_by IN VARCHAR2
    );
    
    -- الحصول على مستندات العميل
    FUNCTION GET_CUSTOMER_DOCUMENTS(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على مستندات الطلب
    FUNCTION GET_REQUEST_DOCUMENTS(p_request_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- التحقق من اكتمال المستندات المطلوبة للطلب
    FUNCTION CHECK_REQUIRED_DOCUMENTS(p_request_id IN NUMBER) RETURN BOOLEAN;
    
    -- الحصول على المستندات المنتهية الصلاحية
    FUNCTION GET_EXPIRED_DOCUMENTS RETURN SYS_REFCURSOR;
END PKG_DOCUMENTS;
/


CREATE OR REPLACE PACKAGE                PKG_FINANCING AS
    /*
    * حزمة إدارة التمويل
    * تتضمن وظائف وإجراءات لإدارة عقود التمويل وعمليات الاستعلام والتحديث
    */
    
    -- إنشاء عقد تمويل جديد
    PROCEDURE CREATE_FINANCING_CONTRACT(
        p_customer_id IN NUMBER,
        p_product_id IN NUMBER,
        p_financing_amount IN NUMBER,
        p_profit_rate IN NUMBER,
        p_installment_count IN NUMBER,
        p_start_date IN DATE,
        p_collateral_ids IN VARCHAR2 DEFAULT NULL, -- قائمة معرفات الضمانات مفصولة بفواصل
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_created_by IN NUMBER,
        p_financing_id OUT NUMBER
    );
    
    -- تحديث عقد التمويل
    PROCEDURE UPDATE_FINANCING_CONTRACT(
        p_financing_id IN NUMBER,
        p_profit_rate IN NUMBER DEFAULT NULL,
        p_installment_count IN NUMBER DEFAULT NULL,
        p_start_date IN DATE DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_updated_by IN NUMBER
    );
    
    -- الحصول على تفاصيل عقد التمويل
    FUNCTION GET_FINANCING_CONTRACT(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على جدول الأقساط لعقد التمويل
    FUNCTION GET_INSTALLMENT_SCHEDULE(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- تغيير حالة عقد التمويل
    PROCEDURE CHANGE_CONTRACT_STATUS(
        p_financing_id IN NUMBER,
        p_new_status IN VARCHAR2,
        p_reason IN VARCHAR2,
        p_updated_by IN NUMBER
    );
    
    -- تسجيل دفعة جديدة
    PROCEDURE REGISTER_PAYMENT(
        p_financing_id IN NUMBER,
        p_installment_id IN NUMBER,
        p_amount IN NUMBER,
        p_payment_method IN VARCHAR2,
        p_payment_date IN DATE,
        p_reference_number IN VARCHAR2 DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_created_by IN NUMBER,
        p_payment_id OUT NUMBER
    );
    
    -- إلغاء دفعة
    PROCEDURE CANCEL_PAYMENT(
        p_payment_id IN NUMBER,
        p_reason IN VARCHAR2,
        p_cancelled_by IN NUMBER
    );
    
    -- إعادة جدولة التمويل
    PROCEDURE RESCHEDULE_FINANCING(
        p_financing_id IN NUMBER,
        p_new_installment_count IN NUMBER,
        p_new_profit_rate IN NUMBER DEFAULT NULL,
        p_grace_period_months IN NUMBER DEFAULT 0,
        p_reason IN VARCHAR2,
        p_approved_by IN NUMBER,
        p_new_financing_id OUT NUMBER
    );
    
    -- تسوية التمويل مبكراً
    PROCEDURE EARLY_SETTLEMENT(
        p_financing_id IN NUMBER,
        p_settlement_date IN DATE,
        p_settlement_amount IN NUMBER,
        p_discount_amount IN NUMBER,
        p_settlement_reason IN VARCHAR2,
        p_payment_method IN VARCHAR2,
        p_payment_reference IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    /*
    -- إضافة ضمان لعقد التمويل
    PROCEDURE ADD_COLLATERAL_TO_CONTRACT(
        p_financing_id IN NUMBER,
        p_collateral_id IN NUMBER,
        p_added_by IN NUMBER
    );
    */
    -- إزالة ضمان من عقد التمويل
    /*
    PROCEDURE REMOVE_COLLATERAL_FROM_CONTRACT(
        p_financing_id IN NUMBER,
        p_collateral_id IN NUMBER,
        p_reason IN VARCHAR2,
        p_removed_by IN NUMBER
    );
    */
    /*
    -- حساب مبلغ التسوية المبكرة
    FUNCTION CALCULATE_EARLY_SETTLEMENT(
        p_financing_id IN NUMBER,
        p_settlement_date IN DATE
    ) RETURN NUMBER;
    */
    -- الحصول على تاريخ المدفوعات لعقد التمويل
   --- FUNCTION GET_PAYMENT_HISTORY(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على تاريخ تغييرات حالة عقد التمويل
    FUNCTION GET_STATUS_HISTORY(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- البحث عن عقود التمويل
    /*
    FUNCTION SEARCH_FINANCING_CONTRACTS(
        p_customer_id IN NUMBER DEFAULT NULL,
        p_product_id IN NUMBER DEFAULT NULL,
        p_status IN VARCHAR2 DEFAULT NULL,
        p_start_date_from IN DATE DEFAULT NULL,
        p_start_date_to IN DATE DEFAULT NULL,
        p_amount_from IN NUMBER DEFAULT NULL,
        p_amount_to IN NUMBER DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    */
    -- الحصول على إحصائيات التمويل
    FUNCTION GET_FINANCING_STATISTICS(
        p_start_date IN DATE DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    
    -- تحديث جدول الأقساط
    PROCEDURE UPDATE_INSTALLMENT_SCHEDULE(
        p_financing_id IN NUMBER,
        p_regenerate_schedule IN BOOLEAN DEFAULT FALSE
    );
    
    -- إنشاء جدول الأقساط
    PROCEDURE GENERATE_INSTALLMENT_SCHEDULE(
        p_financing_id IN NUMBER,
        p_regenerate IN BOOLEAN DEFAULT FALSE
    );
    /*
    -- الحصول على الأقساط المستحقة
    FUNCTION GET_DUE_INSTALLMENTS(
        p_days_ahead IN NUMBER DEFAULT 30
    ) RETURN SYS_REFCURSOR;
    */
    -- الحصول على الأقساط المتأخرة
    /*
    FUNCTION GET_OVERDUE_INSTALLMENTS(
        p_days_overdue IN NUMBER DEFAULT 0
    ) RETURN SYS_REFCURSOR;
    */
    -- تحديث حالة الأقساط المتأخرة
    PROCEDURE UPDATE_OVERDUE_INSTALLMENTS;
    
    -- حساب الغرامات على الأقساط المتأخرة
    ---PROCEDURE CALCULATE_LATE_PAYMENT_PENALTIES;
    /*
    -- إضافة ملاحظة لعقد التمويل
    PROCEDURE ADD_FINANCING_NOTE(
        p_financing_id IN NUMBER,
        p_note_text IN VARCHAR2,
        p_created_by IN NUMBER,
        p_note_id OUT NUMBER
    );
    */
    -- الحصول على ملاحظات عقد التمويل
    FUNCTION GET_FINANCING_NOTES(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- حساب الربح المتوقع من عقد التمويل
   --- FUNCTION CALCULATE_EXPECTED_PROFIT(p_financing_id IN NUMBER) RETURN NUMBER;
    
    -- حساب الربح المحقق من عقد التمويل
   --- FUNCTION CALCULATE_REALIZED_PROFIT(p_financing_id IN NUMBER) RETURN NUMBER;
    /*
    -- الحصول على تقرير الأرباح
    FUNCTION GET_PROFIT_REPORT(
        p_start_date IN DATE DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL,
        p_product_id IN NUMBER DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    */
    -- الحصول على تقرير التمويلات حسب المنتج
    ---FUNCTION GET_FINANCING_BY_PRODUCT RETURN SYS_REFCURSOR;
    
    -- الحصول على تقرير التمويلات حسب الحالة
   --- FUNCTION GET_FINANCING_BY_STATUS RETURN SYS_REFCURSOR;
    /*
    -- الحصول على تقرير التمويلات الشهرية
    FUNCTION GET_MONTHLY_FINANCING_REPORT(
        p_year IN NUMBER DEFAULT EXTRACT(YEAR FROM SYSDATE)
    ) RETURN SYS_REFCURSOR;
    */
    -- تحديث المبلغ المتبقي لعقد التمويل
    PROCEDURE UPDATE_REMAINING_AMOUNT(p_financing_id IN NUMBER);
    /*
    -- الحصول على تقرير التحصيل
    FUNCTION GET_COLLECTION_REPORT(
        p_start_date IN DATE DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    */
    /*
    -- الحصول على تقرير الأقساط المستحقة
    FUNCTION GET_DUE_INSTALLMENTS_REPORT(
        p_days_ahead IN NUMBER DEFAULT 30,
        p_product_id IN NUMBER DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    */
    
END PKG_FINANCING;
/


CREATE OR REPLACE PACKAGE                PKG_FINANCING_REQUESTS AS
    -- إنشاء طلب تمويل جديد
    PROCEDURE CREATE_REQUEST(
        p_customer_id IN NUMBER,
        p_product_id IN NUMBER,
        p_requested_amount IN NUMBER,
        p_financing_period IN NUMBER,
        p_created_by IN VARCHAR2,
        p_request_id OUT NUMBER
    );
    
    -- تحديث حالة الطلب
    PROCEDURE UPDATE_REQUEST_STATUS(
        p_request_id IN NUMBER,
        p_request_status IN VARCHAR2,
        p_approved_amount IN NUMBER,
        p_profit_rate IN NUMBER,
        p_updated_by IN VARCHAR2
    );
    
    -- إضافة ضمان للطلب
    PROCEDURE ADD_REQUEST_COLLATERAL(
        p_request_id IN NUMBER,
        p_collateral_id IN NUMBER,
        p_coverage_ratio IN NUMBER,
        p_created_by IN VARCHAR2,
        p_request_collateral_id OUT NUMBER
    );
    
    -- تحديث مرحلة الطلب
    PROCEDURE UPDATE_REQUEST_STAGE(
        p_request_id IN NUMBER,
        p_stage_id IN NUMBER,
        p_updated_by IN VARCHAR2
    );
    
    -- صرف التمويل
    PROCEDURE DISBURSE_FINANCING(
        p_request_id IN NUMBER,
        p_disbursement_date IN DATE,
        p_updated_by IN VARCHAR2
    );
    
    -- الحصول على معلومات الطلب
    FUNCTION GET_REQUEST_INFO(p_request_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على ضمانات الطلب
    FUNCTION GET_REQUEST_COLLATERALS(p_request_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على طلبات العميل
    FUNCTION GET_CUSTOMER_REQUESTS(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على طلبات المنتج
    FUNCTION GET_PRODUCT_REQUESTS(p_product_id IN NUMBER) RETURN SYS_REFCURSOR;
END PKG_FINANCING_REQUESTS;
/


CREATE OR REPLACE PACKAGE PKG_INSTALLMENT_SCHEDULE AS
    -- إنشاء جدول الأقساط
    PROCEDURE CREATE_SCHEDULE(
        p_request_id IN NUMBER,
        p_start_date IN DATE,
        p_created_by IN VARCHAR2
    );
    
    -- تحديث حالة القسط
    PROCEDURE UPDATE_INSTALLMENT_STATUS(
        p_installment_id IN NUMBER,
        p_installment_status IN VARCHAR2,
        p_paid_amount IN NUMBER,
        p_payment_date IN DATE,
        p_updated_by IN VARCHAR2
    );
    
    -- إعادة جدولة الأقساط
    PROCEDURE RESCHEDULE_INSTALLMENTS(
        p_request_id IN NUMBER,
        p_start_date IN DATE,
        p_new_period IN NUMBER,
        p_new_profit_rate IN NUMBER,
        p_updated_by IN VARCHAR2
    );
    
    -- تأجيل القسط
    PROCEDURE POSTPONE_INSTALLMENT(
        p_installment_id IN NUMBER,
        p_new_due_date IN DATE,
        p_updated_by IN VARCHAR2
    );
    
    -- السداد المبكر
    PROCEDURE EARLY_SETTLEMENT(
        p_request_id IN NUMBER,
        p_settlement_date IN DATE,
        p_settlement_amount IN NUMBER,
        p_updated_by IN VARCHAR2
    );
    
    -- الحصول على جدول الأقساط للطلب
    FUNCTION GET_REQUEST_SCHEDULE(p_request_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على الأقساط المستحقة
    FUNCTION GET_DUE_INSTALLMENTS(p_due_date IN DATE) RETURN SYS_REFCURSOR;
    
    -- الحصول على الأقساط المتأخرة
    FUNCTION GET_OVERDUE_INSTALLMENTS RETURN SYS_REFCURSOR;
END PKG_INSTALLMENT_SCHEDULE;
/


CREATE OR REPLACE PACKAGE                PKG_ISLAMIC_PRODUCTS AS
    -- إضافة منتج إسلامي جديد
    PROCEDURE ADD_PRODUCT(
        p_product_name IN VARCHAR2,
        p_product_type IN VARCHAR2,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_product_id OUT NUMBER
    );
    
    -- تعديل منتج إسلامي
    PROCEDURE UPDATE_PRODUCT(
        p_product_id IN NUMBER,
        p_product_name IN VARCHAR2,
        p_product_type IN VARCHAR2,
        p_description IN CLOB,
        p_is_active IN NUMBER,
        p_updated_by IN VARCHAR2
    );
    
    -- إضافة شرط للمنتج
    PROCEDURE ADD_PRODUCT_CONDITION(
        p_product_id IN NUMBER,
        p_condition_name IN VARCHAR2,
        p_condition_description IN CLOB,
        p_is_mandatory IN NUMBER,
        p_created_by IN VARCHAR2,
        p_condition_id OUT NUMBER
    );
    
    -- إضافة مرحلة للمنتج
    PROCEDURE ADD_PRODUCT_STAGE(
        p_product_id IN NUMBER,
        p_stage_name IN VARCHAR2,
        p_stage_order IN NUMBER,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_stage_id OUT NUMBER
    );
    
    -- إضافة معادلة محاسبية
    PROCEDURE ADD_ACCOUNTING_FORMULA(
        p_product_id IN NUMBER,
        p_stage_id IN NUMBER,
        p_formula_name IN VARCHAR2,
        p_formula_expression IN CLOB,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_formula_id OUT NUMBER
    );
    
    -- إضافة رسوم أو عمولة
    PROCEDURE ADD_FEE(
        p_product_id IN NUMBER,
        p_stage_id IN NUMBER,
        p_fee_name IN VARCHAR2,
        p_fee_type IN VARCHAR2,
        p_fee_value IN NUMBER,
        p_min_value IN NUMBER,
        p_max_value IN NUMBER,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_fee_id OUT NUMBER
    );
    
    -- الحصول على معلومات المنتج
    FUNCTION GET_PRODUCT_INFO(p_product_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على شروط المنتج
    FUNCTION GET_PRODUCT_CONDITIONS(p_product_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على مراحل المنتج
    FUNCTION GET_PRODUCT_STAGES(p_product_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على المعادلات المحاسبية للمنتج
    FUNCTION GET_PRODUCT_FORMULAS(p_product_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على الرسوم والعمولات للمنتج
    FUNCTION GET_PRODUCT_FEES(p_product_id IN NUMBER) RETURN SYS_REFCURSOR;
END PKG_ISLAMIC_PRODUCTS;
/


CREATE OR REPLACE PACKAGE                PKG_NOTIFICATIONS AS
    -- الإجراءات والدوال الموجودة حاليًا
    PROCEDURE SEND_USER_NOTIFICATION(
        p_user_id IN NUMBER,
        p_notification_type IN VARCHAR2,
        p_notification_title IN VARCHAR2,
        p_notification_text IN VARCHAR2,
        p_related_entity IN VARCHAR2,
        p_related_entity_id IN NUMBER,
        p_notification_id OUT NUMBER
    );
    
    PROCEDURE SEND_CUSTOMER_NOTIFICATION(
        p_customer_id IN NUMBER,
        p_notification_type IN VARCHAR2,
        p_notification_title IN VARCHAR2,
        p_notification_text IN VARCHAR2,
        p_related_entity IN VARCHAR2,
        p_related_entity_id IN NUMBER,
        p_notification_id OUT NUMBER
    );
    
    PROCEDURE UPDATE_NOTIFICATION_STATUS(
        p_notification_id IN NUMBER,
        p_is_read IN NUMBER
    );
    
    FUNCTION GET_USER_NOTIFICATIONS(
        p_user_id IN NUMBER,
        p_is_read IN NUMBER DEFAULT NULL,
        p_days_back IN NUMBER DEFAULT 30
    ) RETURN SYS_REFCURSOR;
    
    FUNCTION GET_CUSTOMER_NOTIFICATIONS(
        p_customer_id IN NUMBER,
        p_is_read IN NUMBER DEFAULT NULL,
        p_days_back IN NUMBER DEFAULT 30
    ) RETURN SYS_REFCURSOR;
    
    PROCEDURE NOTIFY_OVERDUE_REQUESTS;
    
    PROCEDURE NOTIFY_DUE_INSTALLMENTS(
        p_days_before_due IN NUMBER DEFAULT 5
    );
    
    PROCEDURE NOTIFY_EXPIRING_DOCUMENTS(
        p_days_before_expiry IN NUMBER DEFAULT 30
    );
    
    -- إضافة الإجراء الجديد
    PROCEDURE SEND_SYSTEM_NOTIFICATION(
        p_notification_type IN VARCHAR2,
        p_notification_title IN VARCHAR2,
        p_notification_message IN VARCHAR2,
        p_start_date IN DATE DEFAULT SYSDATE,
        p_end_date IN DATE DEFAULT NULL,
        p_target_users IN VARCHAR2 DEFAULT NULL,
        p_target_roles IN VARCHAR2 DEFAULT NULL,
        p_created_by IN NUMBER DEFAULT 1,
        p_notification_id OUT NUMBER
    );
    
    -- دالة للحصول على إشعارات النظام النشطة
    FUNCTION GET_ACTIVE_SYSTEM_NOTIFICATIONS(
        p_user_id IN NUMBER,
        p_user_roles IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
END PKG_NOTIFICATIONS;
/


CREATE OR REPLACE PACKAGE                PKG_PERMISSIONS AS
    -- إنشاء دور جديد
    PROCEDURE CREATE_ROLE(
        p_role_name IN VARCHAR2,
        p_role_description IN VARCHAR2,
        p_created_by IN VARCHAR2,
        p_role_id OUT NUMBER
    );
    
    -- تحديث بيانات الدور
    PROCEDURE UPDATE_ROLE(
        p_role_id IN NUMBER,
        p_role_name IN VARCHAR2,
        p_role_description IN VARCHAR2,
        p_updated_by IN VARCHAR2
    );
    
    -- إضافة صلاحية للدور
    PROCEDURE ADD_PERMISSION_TO_ROLE(
        p_role_id IN NUMBER,
        p_permission_id IN NUMBER,
        p_granted_by IN VARCHAR2
    );
    
    -- حذف صلاحية من الدور
    PROCEDURE REMOVE_PERMISSION_FROM_ROLE(
        p_role_id IN NUMBER,
        p_permission_id IN NUMBER
    );
    
    -- إضافة صلاحية للمستخدم
    PROCEDURE ADD_PERMISSION_TO_USER(
        p_user_id IN NUMBER,
        p_permission_id IN NUMBER,
        p_granted_by IN VARCHAR2
    );
    
    -- حذف صلاحية من المستخدم
    PROCEDURE REMOVE_PERMISSION_FROM_USER(
        p_user_id IN NUMBER,
        p_permission_id IN NUMBER
    );
    
    -- الحصول على صلاحيات الدور
    FUNCTION GET_ROLE_PERMISSIONS(p_role_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على صلاحيات المستخدم
    FUNCTION GET_USER_PERMISSIONS(p_user_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- التحقق من وجود صلاحية للمستخدم
    FUNCTION CHECK_USER_PERMISSION(
        p_user_id IN NUMBER,
        p_permission_code IN VARCHAR2
    ) RETURN BOOLEAN;
    
    -- الحصول على قائمة الأدوار
    FUNCTION GET_ROLES_LIST RETURN SYS_REFCURSOR;
    
    -- الحصول على قائمة الصلاحيات
    FUNCTION GET_PERMISSIONS_LIST RETURN SYS_REFCURSOR;
END PKG_PERMISSIONS;
/


CREATE OR REPLACE PACKAGE                PKG_REMINDER_MESSAGES AS
    -- إرسال رسالة تذكير
    PROCEDURE SEND_REMINDER(
        p_customer_id IN NUMBER,
        p_request_id IN NUMBER,
        p_installment_id IN NUMBER,
        p_message_type IN VARCHAR2,
        p_message_content IN CLOB,
        p_created_by IN VARCHAR2,
        p_message_id OUT NUMBER
    );
    
    -- إرسال تذكيرات للأقساط المستحقة
    PROCEDURE SEND_DUE_INSTALLMENTS_REMINDERS(
        p_days_before_due IN NUMBER,
        p_message_type IN VARCHAR2,
        p_created_by IN VARCHAR2
    );
    
    -- إرسال تذكيرات للأقساط المتأخرة
    PROCEDURE SEND_OVERDUE_INSTALLMENTS_REMINDERS(
        p_message_type IN VARCHAR2,
        p_created_by IN VARCHAR2
    );
    
    -- الحصول على رسائل العميل
    FUNCTION GET_CUSTOMER_MESSAGES(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على رسائل الطلب
    FUNCTION GET_REQUEST_MESSAGES(p_request_id IN NUMBER) RETURN SYS_REFCURSOR;
END PKG_REMINDER_MESSAGES;
/


CREATE OR REPLACE PACKAGE                PKG_REPORTS AS
    -- تقرير ملخص الطلبات حسب المنتج
    FUNCTION REPORT_REQUESTS_BY_PRODUCT(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR;
    
    -- تقرير ملخص الطلبات حسب الحالة
    FUNCTION REPORT_REQUESTS_BY_STATUS(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR;
    
    -- تقرير الأقساط المستحقة
    FUNCTION REPORT_DUE_INSTALLMENTS(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR;
    
    -- تقرير الأقساط المتأخرة
   --- FUNCTION REPORT_OVERDUE_INSTALLMENTS RETURN SYS_REFCURSOR;
   
   
    -- تقرير الأقساط المتأخرة
    FUNCTION REPORT_OVERDUE_INSTALLMENTS(
        p_days_overdue IN NUMBER DEFAULT 0
    ) RETURN SYS_REFCURSOR;
    
    -- تقرير المخصصات
    FUNCTION REPORT_PROVISIONS RETURN SYS_REFCURSOR;
    
    -- تقرير محفظة التمويل
    FUNCTION REPORT_FINANCING_PORTFOLIO RETURN SYS_REFCURSOR;
    
    -- تقرير أداء المنتجات
    FUNCTION REPORT_PRODUCT_PERFORMANCE(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR;
    
    -- تقرير تصنيف العملاء
    FUNCTION REPORT_CUSTOMER_RATINGS RETURN SYS_REFCURSOR;
    
        -- إنشاء تقرير الأقساط المتأخرة
    PROCEDURE GENERATE_OVERDUE_INSTALLMENTS_REPORT(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_report_id OUT NUMBER
    );
 PROCEDURE GENERATE_PORTFOLIO_ANALYSIS_REPORT(
        p_as_of_date IN DATE,
        p_report_id OUT NUMBER
    );
    
    
END PKG_REPORTS;
/


CREATE OR REPLACE PACKAGE                PKG_SCHEDULED_JOBS AS
    -- تشغيل الوظائف اليومية
    PROCEDURE RUN_DAILY_JOBS;
    
    -- تشغيل الوظائف الأسبوعية
    PROCEDURE RUN_WEEKLY_JOBS;
    
    -- تشغيل الوظائف الشهرية
    PROCEDURE RUN_MONTHLY_JOBS;
    
    -- تحديث حالة الأقساط
    PROCEDURE UPDATE_INSTALLMENT_STATUSES;
    
    -- إنشاء مهام المتابعة
    PROCEDURE CREATE_FOLLOW_UP_TASKS;
    
    -- إرسال الإشعارات المجدولة
    PROCEDURE SEND_SCHEDULED_NOTIFICATIONS;
    
    -- تحديث مؤشرات الأداء
    PROCEDURE UPDATE_PERFORMANCE_METRICS;
    
    -- تنظيف البيانات المؤقتة
    PROCEDURE CLEANUP_TEMPORARY_DATA;
END PKG_SCHEDULED_JOBS;
/


CREATE OR REPLACE PACKAGE                PKG_SYSTEM_ADMIN AS
    -- مراقبة حالة الوظائف المجدولة
    PROCEDURE MONITOR_SCHEDULED_JOBS;
    
    -- إيقاف جميع الوظائف المجدولة
    PROCEDURE STOP_ALL_SCHEDULED_JOBS;
    
    -- تشغيل جميع الوظائف المجدولة
    PROCEDURE START_ALL_SCHEDULED_JOBS;
    
    -- إعادة تشغيل وظيفة مجدولة محددة
    PROCEDURE RESTART_SCHEDULED_JOB(p_job_name IN VARCHAR2);
    
    -- تغيير جدول تنفيذ وظيفة مجدولة
    PROCEDURE CHANGE_JOB_SCHEDULE(
        p_job_name IN VARCHAR2,
        p_start_date IN TIMESTAMP WITH TIME ZONE,
        p_repeat_interval IN VARCHAR2
    );
END PKG_SYSTEM_ADMIN;
/


CREATE OR REPLACE PACKAGE                PKG_TASKS AS
    -- إنشاء مهمة جديدة
    PROCEDURE CREATE_TASK(
        p_task_title IN VARCHAR2,
        p_task_description IN VARCHAR2,
        p_assigned_to IN NUMBER,
        p_due_date IN DATE,
        p_priority IN VARCHAR2,
        p_related_entity IN VARCHAR2,
        p_related_entity_id IN NUMBER,
        p_created_by IN NUMBER,
        p_task_id OUT NUMBER
    );
    
    -- تحديث حالة المهمة
    PROCEDURE UPDATE_TASK_STATUS(
        p_task_id IN NUMBER,
        p_task_status IN VARCHAR2,
        p_completion_notes IN VARCHAR2 DEFAULT NULL,
        p_updated_by IN NUMBER
    );
    
    -- إعادة تعيين المهمة
    PROCEDURE REASSIGN_TASK(
        p_task_id IN NUMBER,
        p_assigned_to IN NUMBER,
        p_reassignment_reason IN VARCHAR2,
        p_updated_by IN NUMBER
    );
    
    -- الحصول على المهام المسندة للمستخدم
    FUNCTION GET_USER_TASKS(
        p_user_id IN NUMBER,
        p_task_status IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    
    -- الحصول على المهام المتعلقة بكيان معين
    FUNCTION GET_ENTITY_TASKS(
        p_related_entity IN VARCHAR2,
        p_related_entity_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- إنشاء مهام آلية للطلب الجديد
    PROCEDURE CREATE_REQUEST_TASKS(
        p_request_id IN NUMBER,
        p_created_by IN NUMBER
    );
    
    -- إنشاء مهام المتابعة للأقساط المتأخرة
    PROCEDURE CREATE_OVERDUE_INSTALLMENT_TASKS;
    
    -- إنشاء مهام تجديد المستندات
    PROCEDURE CREATE_DOCUMENT_RENEWAL_TASKS(p_days_before_expiry IN NUMBER DEFAULT 30);
END PKG_TASKS;
/


CREATE OR REPLACE PACKAGE                PKG_USERS AS
    -- إنشاء مستخدم جديد
    PROCEDURE CREATE_USER(
        p_username IN VARCHAR2,
        p_password IN VARCHAR2,
        p_full_name IN VARCHAR2,
        p_email IN VARCHAR2,
        p_mobile_number IN VARCHAR2,
        p_department IN VARCHAR2,
        p_job_title IN VARCHAR2,
        p_user_role IN VARCHAR2,
        p_created_by IN VARCHAR2,
        p_user_id OUT NUMBER
    );
    
    -- تحديث بيانات المستخدم
    PROCEDURE UPDATE_USER(
        p_user_id IN NUMBER,
        p_full_name IN VARCHAR2,
        p_email IN VARCHAR2,
        p_mobile_number IN VARCHAR2,
        p_department IN VARCHAR2,
        p_job_title IN VARCHAR2,
        p_user_role IN VARCHAR2,
        p_updated_by IN VARCHAR2
    );
    
    -- تغيير كلمة المرور
    PROCEDURE CHANGE_PASSWORD(
        p_user_id IN NUMBER,
        p_old_password IN VARCHAR2,
        p_new_password IN VARCHAR2,
        p_updated_by IN VARCHAR2
    );
    
    -- تعطيل/تفعيل المستخدم
    PROCEDURE TOGGLE_USER_STATUS(
        p_user_id IN NUMBER,
        p_is_active IN NUMBER,
        p_updated_by IN VARCHAR2
    );
    
    -- التحقق من صحة بيانات الدخول
    FUNCTION VALIDATE_LOGIN(
        p_username IN VARCHAR2,
        p_password IN VARCHAR2
    ) RETURN NUMBER;
    
    -- الحصول على بيانات المستخدم
    FUNCTION GET_USER_INFO(p_user_id IN NUMBER) RETURN SYS_REFCURSOR;
    
    -- الحصول على قائمة المستخدمين
    FUNCTION GET_USERS_LIST(
        p_department IN VARCHAR2 DEFAULT NULL,
        p_user_role IN VARCHAR2 DEFAULT NULL,
        p_is_active IN NUMBER DEFAULT NULL
    ) RETURN SYS_REFCURSOR;
    
    -- الحصول على قائمة المستخدمين حسب الصلاحية
    FUNCTION GET_USERS_BY_PERMISSION(
        p_permission_code IN VARCHAR2
    ) RETURN SYS_REFCURSOR;
    
    -- تسجيل دخول المستخدم
    PROCEDURE LOG_USER_LOGIN(
        p_user_id IN NUMBER,
        p_login_ip IN VARCHAR2,
        p_user_agent IN VARCHAR2,
        p_login_status IN VARCHAR2,
        p_login_id OUT NUMBER
    );
    
    -- تسجيل خروج المستخدم
    PROCEDURE LOG_USER_LOGOUT(
        p_login_id IN NUMBER
    );
END PKG_USERS;
/


CREATE OR REPLACE PACKAGE                PKG_WORKFLOW AS
    -- ثوابت لتعريف أنواع الإجراءات
    TASK_TYPE_REVIEW CONSTANT VARCHAR2(30) := 'REVIEW';
    TASK_TYPE_APPROVAL CONSTANT VARCHAR2(30) := 'APPROVAL';
    TASK_TYPE_DOCUMENT CONSTANT VARCHAR2(30) := 'DOCUMENT';
    TASK_TYPE_NOTIFICATION CONSTANT VARCHAR2(30) := 'NOTIFICATION';
    
    -- ثوابت لتعريف حالات المهام
    TASK_STATUS_PENDING CONSTANT VARCHAR2(30) := 'PENDING';
    TASK_STATUS_IN_PROGRESS CONSTANT VARCHAR2(30) := 'IN_PROGRESS';
    TASK_STATUS_COMPLETED CONSTANT VARCHAR2(30) := 'COMPLETED';
    TASK_STATUS_REJECTED CONSTANT VARCHAR2(30) := 'REJECTED';
    TASK_STATUS_CANCELLED CONSTANT VARCHAR2(30) := 'CANCELLED';
    
    -- إنشاء سير عمل جديد
    PROCEDURE CREATE_WORKFLOW(
        p_workflow_type IN VARCHAR2,
        p_reference_type IN VARCHAR2,
        p_reference_id IN NUMBER,
        p_priority IN VARCHAR2,
        p_created_by IN NUMBER,
        p_workflow_id OUT NUMBER
    );
    
    -- إضافة مهمة إلى سير العمل
    PROCEDURE ADD_WORKFLOW_TASK(
        p_workflow_id IN NUMBER,
        p_task_type IN VARCHAR2,
        p_task_name IN VARCHAR2,
        p_task_description IN VARCHAR2,
        p_assigned_to IN NUMBER,
        p_due_date IN DATE,
        p_sequence_number IN NUMBER,
        p_created_by IN NUMBER,
        p_task_id OUT NUMBER
    );
    
    -- تحديث حالة المهمة
    PROCEDURE UPDATE_TASK_STATUS(
        p_task_id IN NUMBER,
        p_task_status IN VARCHAR2,
        p_comments IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    -- تحديث حالة سير العمل
    PROCEDURE UPDATE_WORKFLOW_STATUS(
        p_workflow_id IN NUMBER,
        p_workflow_status IN VARCHAR2,
        p_comments IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    -- إعادة تعيين المهمة لمستخدم آخر
    PROCEDURE REASSIGN_TASK(
        p_task_id IN NUMBER,
        p_new_assignee IN NUMBER,
        p_reassign_reason IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    );
    
    -- الحصول على المهام المعلقة للمستخدم
    FUNCTION GET_USER_PENDING_TASKS(
        p_user_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- الحصول على تفاصيل سير العمل
    FUNCTION GET_WORKFLOW_DETAILS(
        p_workflow_id IN NUMBER
    ) RETURN SYS_REFCURSOR;
    
    -- إنشاء سير عمل لطلب تمويل جديد
    PROCEDURE CREATE_FINANCING_REQUEST_WORKFLOW(
        p_request_id IN NUMBER,
        p_created_by IN NUMBER,
        p_workflow_id OUT NUMBER
    );
    
    -- إنشاء سير عمل لإعادة جدولة التمويل
    PROCEDURE CREATE_RESCHEDULE_WORKFLOW(
        p_financing_id IN NUMBER,
        p_reschedule_reason IN VARCHAR2,
        p_created_by IN NUMBER,
        p_workflow_id OUT NUMBER
    );
    
    -- إنشاء سير عمل للتسوية المبكرة
    PROCEDURE CREATE_EARLY_SETTLEMENT_WORKFLOW(
        p_financing_id IN NUMBER,
        p_settlement_reason IN VARCHAR2,
        p_created_by IN NUMBER,
        p_workflow_id OUT NUMBER
    );
    
    -- التحقق من اكتمال جميع المهام في سير العمل
    FUNCTION ARE_ALL_TASKS_COMPLETED(
        p_workflow_id IN NUMBER
    ) RETURN BOOLEAN;
    
    -- الحصول على المهمة التالية في سير العمل
    FUNCTION GET_NEXT_TASK(
        p_workflow_id IN NUMBER,
        p_current_task_id IN NUMBER
    ) RETURN NUMBER;
END PKG_WORKFLOW;
/


CREATE OR REPLACE PACKAGE                system_management AS
    -- تسجيل حدث نظام
    PROCEDURE log_system_event(
        p_event_type IN VARCHAR2,
        p_event_description IN VARCHAR2,
        p_source IN VARCHAR2,
        p_user_id IN NUMBER DEFAULT NULL,
        p_reference_id IN NUMBER DEFAULT NULL,
        p_reference_type IN VARCHAR2 DEFAULT NULL
    );
    
    -- تسجيل خطأ نظام
    PROCEDURE log_system_error(
        p_error_code IN VARCHAR2,
        p_error_message IN VARCHAR2,
        p_source IN VARCHAR2,
        p_stack_trace IN VARCHAR2 DEFAULT NULL,
        p_user_id IN NUMBER DEFAULT NULL,
        p_reference_id IN NUMBER DEFAULT NULL,
        p_reference_type IN VARCHAR2 DEFAULT NULL
    );
    
    -- تسجيل نشاط مستخدم
    PROCEDURE log_user_activity(
        p_user_id IN NUMBER,
        p_activity_type IN VARCHAR2,
        p_activity_description IN VARCHAR2,
        p_ip_address IN VARCHAR2 DEFAULT NULL,
        p_reference_id IN NUMBER DEFAULT NULL,
        p_reference_type IN VARCHAR2 DEFAULT NULL
    );
    
    -- تسجيل دخول مستخدم
    PROCEDURE log_user_login(
        p_user_id IN NUMBER,
        p_ip_address IN VARCHAR2,
        p_user_agent IN VARCHAR2,
        p_status IN VARCHAR2,
        p_failure_reason IN VARCHAR2 DEFAULT NULL
    );
/*    
    -- الحصول على إحصائيات النظام
    PROCEDURE get_system_statistics(
        p_result OUT SYS_REFCURSOR
    );
    */
    -- تنظيف السجلات القديمة
    PROCEDURE cleanup_old_logs(
        p_days_to_keep IN NUMBER DEFAULT 90
    );
    
    -- تحديث إعدادات النظام
    PROCEDURE update_system_setting(
        p_setting_name IN VARCHAR2,
        p_setting_value IN VARCHAR2,
        p_updated_by IN VARCHAR2
    );
    
    -- الحصول على قيمة إعداد النظام
    FUNCTION get_system_setting(
        p_setting_name IN VARCHAR2,
        p_default_value IN VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2;
END system_management;
/

CREATE OR REPLACE PACKAGE BODY                email_management AS
    -- إرسال بريد إلكتروني
    PROCEDURE send_email(
        p_to IN VARCHAR2,
        p_subject IN VARCHAR2,
        p_body IN CLOB,
        p_cc IN VARCHAR2 DEFAULT NULL,
        p_bcc IN VARCHAR2 DEFAULT NULL,
        p_attachment_path IN VARCHAR2 DEFAULT NULL,
        p_email_id OUT NUMBER
    ) IS
        v_smtp_host VARCHAR2(100);
        v_smtp_port NUMBER;
        v_smtp_username VARCHAR2(100);
        v_smtp_password VARCHAR2(100);
        v_from_email VARCHAR2(100);
        v_from_name VARCHAR2(100);
        v_status VARCHAR2(20) := 'PENDING';
        v_error_message VARCHAR2(4000);
    BEGIN
        -- الحصول على إعدادات SMTP من إعدادات النظام
        v_smtp_host := system_management.get_system_setting('SMTP_HOST', 'smtp.example.com');
        v_smtp_port := TO_NUMBER(system_management.get_system_setting('SMTP_PORT', '587'));
        v_smtp_username := system_management.get_system_setting('SMTP_USERNAME', 'user@example.com');
        v_smtp_password := system_management.get_system_setting('SMTP_PASSWORD', 'password');
        v_from_email := system_management.get_system_setting('EMAIL_FROM_ADDRESS', 'noreply@example.com');
        v_from_name := system_management.get_system_setting('EMAIL_FROM_NAME', 'نظام التمويل');
        
        -- إدراج سجل البريد الإلكتروني
        INSERT INTO email_logs (
            email_to,
            email_cc,
            email_bcc,
            email_from,
            subject,
            email_body,
            attachment_path,
            status,
            created_date
        ) VALUES (
            p_to,
            p_cc,
            p_bcc,
            v_from_email,
            p_subject,
            p_body,
            p_attachment_path,
            v_status,
            SYSTIMESTAMP
        ) RETURNING email_id INTO p_email_id;
        
        -- محاولة إرسال البريد الإلكتروني باستخدام UTL_SMTP أو UTL_MAIL
        -- ملاحظة: هذا مثال فقط، يجب تنفيذ الكود الفعلي لإرسال البريد الإلكتروني
        BEGIN
            -- هنا يتم تنفيذ الكود الفعلي لإرسال البريد الإلكتروني
            -- على سبيل المثال:
            /*
            UTL_MAIL.SEND(
                sender => v_from_email,
                recipients => p_to,
                cc => p_cc,
                bcc => p_bcc,
                subject => p_subject,
                message => p_body,
                mime_type => 'text/html; charset=utf-8'
            );
            */
            
            -- تحديث حالة البريد الإلكتروني إلى "تم الإرسال"
            UPDATE email_logs
            SET status = 'SENT',
                sent_date = SYSTIMESTAMP
            WHERE email_id = p_email_id;
            
            -- تسجيل حدث نظام
            system_management.log_system_event(
                'EMAIL',
                'تم إرسال بريد إلكتروني بنجاح إلى: ' || p_to,
                'email_management.send_email',
                NULL,
                p_email_id,
                'EMAIL'
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_error_message := SQLERRM;
                
                -- تحديث حالة البريد الإلكتروني إلى "فشل"
                UPDATE email_logs
                SET status = 'FAILED',
                    error_message = v_error_message
                WHERE email_id = p_email_id;
                
                -- تسجيل خطأ نظام
                system_management.log_system_error(
                    SQLCODE,
                    v_error_message,
                    'email_management.send_email',
                    NULL,
                    NULL,
                    p_email_id,
                    'EMAIL'
                );
        END;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.send_email',
                NULL,
                NULL,
                NULL,
                'EMAIL'
            );
            RAISE;
    END send_email;
    
    -- إرسال بريد إلكتروني للعميل
    PROCEDURE send_customer_email(
        p_customer_id IN NUMBER,
        p_subject IN VARCHAR2,
        p_body IN CLOB,
        p_attachment_path IN VARCHAR2 DEFAULT NULL,
        p_email_id OUT NUMBER
    ) IS
        v_customer_email VARCHAR2(255);
        v_customer_name VARCHAR2(255);
    BEGIN
        -- الحصول على بريد العميل واسمه
        SELECT email, full_name INTO v_customer_email, v_customer_name
        FROM customers
        WHERE customer_id = p_customer_id
        AND customer_status = 'ACTIVE';
        
        -- التحقق من وجود بريد إلكتروني للعميل
        IF v_customer_email IS NULL OR v_customer_email = '' THEN
            RAISE_APPLICATION_ERROR(-20801, 'لا يوجد بريد إلكتروني مسجل للعميل');
        END IF;
        
        -- إرسال البريد الإلكتروني
        send_email(
            v_customer_email,
            p_subject,
            p_body,
            NULL,
            NULL,
            p_attachment_path,
            p_email_id
        );
        
        -- تحديث سجل البريد بمعلومات العميل
        UPDATE email_logs
        SET reference_id = p_customer_id,
            reference_type = 'CUSTOMER'
        WHERE email_id = p_email_id;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20802, 'العميل غير موجود أو غير نشط');
        WHEN OTHERS THEN
            ROLLBACK;
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.send_customer_email',
                NULL,
                NULL,
                p_customer_id,
                'CUSTOMER'
            );
            RAISE;
    END send_customer_email;
    
    -- إرسال بريد إلكتروني للمستخدم
    PROCEDURE send_user_email(
        p_user_id IN NUMBER,
        p_subject IN VARCHAR2,
        p_body IN CLOB,
        p_attachment_path IN VARCHAR2 DEFAULT NULL,
        p_email_id OUT NUMBER
    ) IS
        v_user_email VARCHAR2(255);
        v_user_name VARCHAR2(255);
    BEGIN
        -- الحصول على بريد المستخدم واسمه
        SELECT email, full_name INTO v_user_email, v_user_name
        FROM users
        WHERE user_id = p_user_id
        AND USER_STATUS = 'ACTIVE';
        
        -- التحقق من وجود بريد إلكتروني للمستخدم
        IF v_user_email IS NULL OR v_user_email = '' THEN
            RAISE_APPLICATION_ERROR(-20803, 'لا يوجد بريد إلكتروني مسجل للمستخدم');
        END IF;
        
        -- إرسال البريد الإلكتروني
        send_email(
            v_user_email,
            p_subject,
            p_body,
            NULL,
            NULL,
            p_attachment_path,
            p_email_id
        );
        
        -- تحديث سجل البريد بمعلومات المستخدم
        UPDATE email_logs
        SET reference_id = p_user_id,
            reference_type = 'USER'
        WHERE email_id = p_email_id;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20804, 'المستخدم غير موجود أو غير نشط');
        WHEN OTHERS THEN
            ROLLBACK;
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.send_user_email',
                NULL,
                NULL,
                p_user_id,
                'USER'
            );
            RAISE;
    END send_user_email;
    
    -- إرسال بريد إلكتروني للإشعار بالقسط المستحق
    PROCEDURE send_installment_due_notification(
        p_installment_id IN NUMBER,
        p_email_id OUT NUMBER
    ) IS
        v_customer_id NUMBER;
        v_customer_email VARCHAR2(255);
        v_customer_name VARCHAR2(255);
        v_account_number VARCHAR2(50);
        v_installment_number NUMBER;
        v_due_date DATE;
        v_amount NUMBER;
        v_subject VARCHAR2(200);
        v_body CLOB;
        v_template CLOB;
        v_days_until_due NUMBER;
    BEGIN
        -- الحصول على معلومات القسط والعميل
        SELECT 
            c.customer_id,
            c.email,
            c.full_name,
            fa.CONTRACT_NUMBER,
            i.installment_seq,
            i.due_date,
            i.total_amount,
            TRUNC(i.due_date) - TRUNC(SYSDATE) AS days_until_due
        INTO 
            v_customer_id,
            v_customer_email,
            v_customer_name,
            v_account_number,
            v_installment_number,
            v_due_date,
            v_amount,
            v_days_until_due
        FROM installment_schedule i
        JOIN FINANCING_CONTRACTS fa ON i.REQUEST_ID = fa.REQUEST_ID
        JOIN customers c ON fa.customer_id = c.customer_id
        WHERE i.installment_id = p_installment_id
        AND i.INSTALLMENT_STATUS = 'PENDING';
        
        -- التحقق من وجود بريد إلكتروني للعميل
        IF v_customer_email IS NULL OR v_customer_email = '' THEN
            RAISE_APPLICATION_ERROR(-20805, 'لا يوجد بريد إلكتروني مسجل للعميل');
        END IF;
        
        -- الحصول على قالب البريد الإلكتروني من إعدادات النظام
        v_template := system_management.get_system_setting('EMAIL_TEMPLATE_INSTALLMENT_DUE', '');
        
        -- إذا لم يتم العثور على قالب، استخدم قالب افتراضي
        IF v_template IS NULL OR v_template = '' THEN
            v_template := '
            <html dir="rtl">
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    .header { background-color: #f8f9fa; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .footer { background-color: #f8f9fa; padding: 10px; text-align: center; font-size: 12px; }
                    .important { color: #dc3545; font-weight: bold; }
                    .details { margin: 20px 0; padding: 15px; border: 1px solid #dee2e6; border-radius: 5px; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2>إشعار استحقاق قسط</h2>
                </div>
                <div class="content">
                    <p>عزيزي العميل {CUSTOMER_NAME}،</p>
                    <p>نود إعلامك بأن القسط رقم {INSTALLMENT_NUMBER} للحساب رقم {ACCOUNT_NUMBER} سيكون مستحق الدفع {DUE_TEXT}.</p>
                    <div class="details">
                        <p><strong>رقم الحساب:</strong> {ACCOUNT_NUMBER}</p>
                        <p><strong>رقم القسط:</strong> {INSTALLMENT_NUMBER}</p>
                        <p><strong>تاريخ الاستحقاق:</strong> {DUE_DATE}</p>
                        <p><strong>المبلغ المستحق:</strong> {AMOUNT} ريال</p>
                    </div>
                    <p>يرجى التأكد من توفر الرصيد الكافي في حسابك لتجنب أي رسوم تأخير.</p>
                    <p>يمكنك سداد القسط من خلال أي من قنوات الدفع التالية:</p>
                    <ul>
                        <li>الخدمات المصرفية عبر الإنترنت</li>
                        <li>تطبيق الهاتف المحمول</li>
                        <li>أجهزة الصراف الآلي</li>
                        <li>فروع البنك</li>
                    </ul>
                    <p>في حال وجود أي استفسارات، يرجى التواصل مع خدمة العملاء على الرقم: {SUPPORT_PHONE}</p>
                </div>
                <div class="footer">
                    <p>هذا البريد الإلكتروني تم إرساله تلقائياً، يرجى عدم الرد عليه.</p>
                    <p>© {CURRENT_YEAR} {COMPANY_NAME}. جميع الحقوق محفوظة.</p>
                </div>
            </body>
            </html>';
        END IF;
        
        -- تحديد نص تاريخ الاستحقاق
        DECLARE
            v_due_text VARCHAR2(100);
        BEGIN
            IF v_days_until_due = 0 THEN
                v_due_text := 'اليوم';
            ELSIF v_days_until_due = 1 THEN
                v_due_text := 'غداً';
            ELSE
                v_due_text := 'بعد ' || v_days_until_due || ' أيام';
            END IF;
            
            -- استبدال المتغيرات في القالب
            v_body := REPLACE(v_template, '{CUSTOMER_NAME}', v_customer_name);
            v_body := REPLACE(v_body, '{ACCOUNT_NUMBER}', v_account_number);
            v_body := REPLACE(v_body, '{INSTALLMENT_NUMBER}', v_installment_number);
            v_body := REPLACE(v_body, '{DUE_DATE}', TO_CHAR(v_due_date, 'DD/MM/YYYY'));
            v_body := REPLACE(v_body, '{AMOUNT}', TO_CHAR(v_amount, '999,999,999.99'));
            v_body := REPLACE(v_body, '{DUE_TEXT}', v_due_text);
            v_body := REPLACE(v_body, '{SUPPORT_PHONE}', system_management.get_system_setting('SUPPORT_PHONE', '920000000'));
            v_body := REPLACE(v_body, '{COMPANY_NAME}', system_management.get_system_setting('COMPANY_NAME', 'شركة التمويل'));
            v_body := REPLACE(v_body, '{CURRENT_YEAR}', TO_CHAR(SYSDATE, 'YYYY'));
        END;
        
        -- تحديد عنوان البريد الإلكتروني
        v_subject := 'إشعار استحقاق القسط رقم ' || v_installment_number || ' للحساب ' || v_account_number;
        
        -- إرسال البريد الإلكتروني
        send_email(
            v_customer_email,
            v_subject,
            v_body,
            NULL,
            NULL,
            NULL,
            p_email_id
        );
        
        -- تحديث سجل البريد بمعلومات القسط
        UPDATE email_logs
        SET reference_id = p_installment_id,
            reference_type = 'INSTALLMENT'
        WHERE email_id = p_email_id;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20806, 'القسط غير موجود أو تم دفعه بالفعل');
        WHEN OTHERS THEN
            ROLLBACK;
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.send_installment_due_notification',
                NULL,
                NULL,
                p_installment_id,
                'INSTALLMENT'
            );
            RAISE;
    END send_installment_due_notification;
    
    -- إرسال بريد إلكتروني للإشعار بالقسط المتأخر
    PROCEDURE send_installment_overdue_notification(
        p_installment_id IN NUMBER,
        p_email_id OUT NUMBER
    ) IS
        v_customer_id NUMBER;
        v_customer_email VARCHAR2(255);
        v_customer_name VARCHAR2(255);
        v_account_number VARCHAR2(50);
        v_installment_number NUMBER;
        v_due_date DATE;
        v_amount NUMBER;
        v_subject VARCHAR2(200);
        v_body CLOB;
        v_template CLOB;
        v_days_overdue NUMBER;
        v_late_fees NUMBER;
    BEGIN
        -- الحصول على معلومات القسط والعميل
        SELECT 
            c.customer_id,
            c.email,
            c.full_name,
            fa.CONTRACT_NUMBER,
            i.installment_seq,
            i.due_date,
            i.total_amount,
            TRUNC(SYSDATE) - TRUNC(i.due_date) AS days_overdue,
            i.late_fees
        INTO 
            v_customer_id,
            v_customer_email,
            v_customer_name,
            v_account_number,
            v_installment_number,
            v_due_date,
            v_amount,
            v_days_overdue,
            v_late_fees
        FROM installment_schedule i
        JOIN FINANCING_CONTRACTS fa ON i.REQUEST_ID = fa.REQUEST_ID
        JOIN customers c ON fa.customer_id = c.customer_id
        WHERE i.installment_id = p_installment_id
        AND i.INSTALLMENT_STATUS = 'OVERDUE';
        
        -- التحقق من وجود بريد إلكتروني للعميل
        IF v_customer_email IS NULL OR v_customer_email = '' THEN
            RAISE_APPLICATION_ERROR(-20807, 'لا يوجد بريد إلكتروني مسجل للعميل');
        END IF;
        
        -- الحصول على قالب البريد الإلكتروني من إعدادات النظام
        v_template := system_management.get_system_setting('EMAIL_TEMPLATE_INSTALLMENT_OVERDUE', '');
        
        -- إذا لم يتم العثور على قالب، استخدم قالب افتراضي
        IF v_template IS NULL OR v_template = '' THEN
            v_template := '
            <html dir="rtl">
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    .header { background-color: #f8f9fa; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .footer { background-color: #f8f9fa; padding: 10px; text-align: center; font-size: 12px; }
                    .important { color: #dc3545; font-weight: bold; }
                    .details { margin: 20px 0; padding: 15px; border: 1px solid #dee2e6; border-radius: 5px; }
                    .warning { background-color: #fff3cd; padding: 10px; border-radius: 5px; margin: 15px 0; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2>إشعار تأخر سداد قسط</h2>
                </div>
                <div class="content">
                    <p>عزيزي العميل {CUSTOMER_NAME}،</p>
                    <p class="important">نود إعلامك بأن القسط رقم {INSTALLMENT_NUMBER} للحساب رقم {ACCOUNT_NUMBER} متأخر عن السداد منذ {DAYS_OVERDUE} يوم.</p>
                    <div class="details">
                        <p><strong>رقم الحساب:</strong> {ACCOUNT_NUMBER}</p>
                        <p><strong>رقم القسط:</strong> {INSTALLMENT_NUMBER}</p>
                        <p><strong>تاريخ الاستحقاق:</strong> {DUE_DATE}</p>
                        <p><strong>المبلغ المستحق:</strong> {AMOUNT} ريال</p>
                        <p><strong>رسوم التأخير:</strong> {LATE_FEES} ريال</p>
                        <p><strong>إجمالي المبلغ المستحق:</strong> {TOTAL_AMOUNT} ريال</p>
                    </div>
                    <div class="warning">
                        <p>يرجى العلم أن استمرار التأخير في السداد قد يؤدي إلى:</p>
                        <ul>
                            <li>فرض رسوم تأخير إضافية</li>
                            <li>التأثير سلباً على سجلك الائتماني</li>
                            <li>اتخاذ إجراءات قانونية لتحصيل المبلغ المستحق</li>
                        </ul>
                    </div>
                    <p>يرجى المبادرة بسداد المبلغ المستحق في أقرب وقت ممكن من خلال أي من قنوات الدفع التالية:</p>
                    <ul>
                        <li>الخدمات المصرفية عبر الإنترنت</li>
                        <li>تطبيق الهاتف المحمول</li>
                        <li>أجهزة الصراف الآلي</li>
                        <li>فروع البنك</li>
                    </ul>
                    <p>في حال وجود أي استفسارات أو مواجهة صعوبات في السداد، يرجى التواصل مع خدمة العملاء على الرقم: {SUPPORT_PHONE}</p>
                </div>
                <div class="footer">
                    <p>هذا البريد الإلكتروني تم إرساله تلقائياً، يرجى عدم الرد عليه.</p>
                    <p>© {CURRENT_YEAR} {COMPANY_NAME}. جميع الحقوق محفوظة.</p>
                </div>
            </body>
            </html>';
        END IF;
        
        -- استبدال المتغيرات في القالب
        v_body := REPLACE(v_template, '{CUSTOMER_NAME}', v_customer_name);
        v_body := REPLACE(v_body, '{ACCOUNT_NUMBER}', v_account_number);
        v_body := REPLACE(v_body, '{INSTALLMENT_NUMBER}', v_installment_number);
        v_body := REPLACE(v_body, '{DUE_DATE}', TO_CHAR(v_due_date, 'DD/MM/YYYY'));
        v_body := REPLACE(v_body, '{AMOUNT}', TO_CHAR(v_amount, '999,999,999.99'));
        v_body := REPLACE(v_body, '{DAYS_OVERDUE}', v_days_overdue);
        v_body := REPLACE(v_body, '{LATE_FEES}', TO_CHAR(v_late_fees, '999,999,999.99'));
        v_body := REPLACE(v_body, '{TOTAL_AMOUNT}', TO_CHAR(v_amount + v_late_fees, '999,999,999.99'));
        v_body := REPLACE(v_body, '{SUPPORT_PHONE}', system_management.get_system_setting('SUPPORT_PHONE', '920000000'));
        v_body := REPLACE(v_body, '{COMPANY_NAME}', system_management.get_system_setting('COMPANY_NAME', 'شركة التمويل'));
        v_body := REPLACE(v_body, '{CURRENT_YEAR}', TO_CHAR(SYSDATE, 'YYYY'));
        
        -- تحديد عنوان البريد الإلكتروني
        v_subject := 'إشعار هام: تأخر سداد القسط رقم ' || v_installment_number || ' للحساب ' || v_account_number;
        
        -- إرسال البريد الإلكتروني
        send_email(
            v_customer_email,
            v_subject,
            v_body,
            NULL,
            NULL,
            NULL,
            p_email_id
        );
        
        -- تحديث سجل البريد بمعلومات القسط
        UPDATE email_logs
        SET reference_id = p_installment_id,
            reference_type = 'INSTALLMENT'
        WHERE email_id = p_email_id;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20808, 'القسط غير موجود أو ليس متأخراً');
        WHEN OTHERS THEN
            ROLLBACK;
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.send_installment_overdue_notification',
                NULL,
                NULL,
                p_installment_id,
                'INSTALLMENT'
            );
            RAISE;
    END send_installment_overdue_notification;
    
    -- إرسال بريد إلكتروني لتأكيد الدفع
    PROCEDURE send_payment_confirmation(
        p_payment_id IN NUMBER,
        p_email_id OUT NUMBER
    ) IS
        v_customer_id NUMBER;
        v_customer_email VARCHAR2(255);
        v_customer_name VARCHAR2(255);
        v_account_number VARCHAR2(50);
        v_payment_amount NUMBER;
        v_payment_date DATE;
        v_payment_method VARCHAR2(50);
        v_reference_number VARCHAR2(100);
        v_subject VARCHAR2(200);
        v_body CLOB;
        v_template CLOB;
        v_installment_id NUMBER;
        v_installment_number NUMBER;
    BEGIN
        -- الحصول على معلومات الدفع والعميل
        SELECT 
            c.customer_id,
            c.email,
            c.full_name,
            fa.CONTRACT_NUMBER,
            p.PAYMENT_AMOUNT,
            p.payment_date,
            p.payment_method,
            p.reference_number,
            p.installment_id
        INTO 
            v_customer_id,
            v_customer_email,
            v_customer_name,
            v_account_number,
            v_payment_amount,
            v_payment_date,
            v_payment_method,
            v_reference_number,
            v_installment_id
        FROM payments p
        JOIN FINANCING_CONTRACTS fa ON p.FINANCING_ID = fa.FINANCING_ID
        JOIN customers c ON fa.customer_id = c.customer_id
        WHERE p.PAYMENT_ID = p_payment_id;
        
        -- الحصول على رقم القسط إذا كان الدفع مرتبط بقسط
        IF v_installment_id IS NOT NULL THEN
            SELECT installment_seq INTO v_installment_number
            FROM installment_schedule
            WHERE installment_id = v_installment_id;
        END IF;
        
        -- التحقق من وجود بريد إلكتروني للعميل
        IF v_customer_email IS NULL OR v_customer_email = '' THEN
            RAISE_APPLICATION_ERROR(-20809, 'لا يوجد بريد إلكتروني مسجل للعميل');
        END IF;
        
        -- الحصول على قالب البريد الإلكتروني من إعدادات النظام
        v_template := system_management.get_system_setting('EMAIL_TEMPLATE_PAYMENT_CONFIRMATION', '');
        
        -- إذا لم يتم العثور على قالب، استخدم قالب افتراضي
        IF v_template IS NULL OR v_template = '' THEN
            v_template := '
            <html dir="rtl">
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    .header { background-color: #f8f9fa; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .footer { background-color: #f8f9fa; padding: 10px; text-align: center; font-size: 12px; }
                    .success { color: #28a745; font-weight: bold; }
                    .details { margin: 20px 0; padding: 15px; border: 1px solid #dee2e6; border-radius: 5px; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2>تأكيد عملية الدفع</h2>
                </div>
                <div class="content">
                    <p>عزيزي العميل {CUSTOMER_NAME}،</p>
                    <p class="success">نود إعلامك بأنه تم استلام دفعتك بنجاح.</p>
                    <div class="details">
                        <p><strong>رقم الحساب:</strong> {ACCOUNT_NUMBER}</p>
                        <p><strong>المبلغ المدفوع:</strong> {AMOUNT} ريال</p>
                        <p><strong>تاريخ الدفع:</strong> {PAYMENT_DATE}</p>
                        <p><strong>طريقة الدفع:</strong> {PAYMENT_METHOD}</p>
                        <p><strong>رقم المرجع:</strong> {REFERENCE_NUMBER}</p>
                        {INSTALLMENT_INFO}
                    </div>
                    <p>نشكرك على التزامك بالسداد في الوقت المحدد.</p>
                    <p>في حال وجود أي استفسارات، يرجى التواصل مع خدمة العملاء على الرقم: {SUPPORT_PHONE}</p>
                </div>
                <div class="footer">
                    <p>هذا البريد الإلكتروني تم إرساله تلقائياً، يرجى عدم الرد عليه.</p>
                    <p>© {CURRENT_YEAR} {COMPANY_NAME}. جميع الحقوق محفوظة.</p>
                </div>
            </body>
            </html>';
        END IF;
        
        -- إعداد معلومات القسط إذا كان الدفع مرتبط بقسط
        DECLARE
            v_installment_info VARCHAR2(500);
        BEGIN
            IF v_installment_id IS NOT NULL THEN
                v_installment_info := '<p><strong>رقم القسط:</strong> ' || v_installment_number || '</p>';
            ELSE
                v_installment_info := '';
            END IF;
            
            -- استبدال المتغيرات في القالب
            v_body := REPLACE(v_template, '{CUSTOMER_NAME}', v_customer_name);
            v_body := REPLACE(v_body, '{ACCOUNT_NUMBER}', v_account_number);
            v_body := REPLACE(v_body, '{AMOUNT}', TO_CHAR(v_payment_amount, '999,999,999.99'));
            v_body := REPLACE(v_body, '{PAYMENT_DATE}', TO_CHAR(v_payment_date, 'DD/MM/YYYY HH24:MI'));
            v_body := REPLACE(v_body, '{PAYMENT_METHOD}', v_payment_method);
            v_body := REPLACE(v_body, '{REFERENCE_NUMBER}', v_reference_number);
            v_body := REPLACE(v_body, '{INSTALLMENT_INFO}', v_installment_info);
            v_body := REPLACE(v_body, '{SUPPORT_PHONE}', system_management.get_system_setting('SUPPORT_PHONE', '920000000'));
            v_body := REPLACE(v_body, '{COMPANY_NAME}', system_management.get_system_setting('COMPANY_NAME', 'شركة التمويل'));
            v_body := REPLACE(v_body, '{CURRENT_YEAR}', TO_CHAR(SYSDATE, 'YYYY'));
        END;
        
        -- تحديد عنوان البريد الإلكتروني
        v_subject := 'تأكيد عملية الدفع للحساب ' || v_account_number;
        
        -- إرسال البريد الإلكتروني
        send_email(
            v_customer_email,
            v_subject,
            v_body,
            NULL,
            NULL,
            NULL,
            p_email_id
        );
        
        -- تحديث سجل البريد بمعلومات الدفع
        UPDATE email_logs
        SET reference_id = p_payment_id,
            reference_type = 'PAYMENT'
        WHERE email_id = p_email_id;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20810, 'الدفعة غير موجودة');
        WHEN OTHERS THEN
            ROLLBACK;
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.send_payment_confirmation',
                NULL,
                NULL,
                p_payment_id,
                'PAYMENT'
            );
            RAISE;
    END send_payment_confirmation;
    
    -- إرسال بريد إلكتروني لإشعار بحالة الطلب
    PROCEDURE send_application_status_notification(
        p_application_id IN NUMBER,
        p_email_id OUT NUMBER
    ) IS
        v_customer_id NUMBER;
        v_customer_email VARCHAR2(255);
        v_customer_name VARCHAR2(255);
        v_application_number VARCHAR2(50);
        v_product_name VARCHAR2(100);
        v_status VARCHAR2(50);
        v_status_date DATE;
        v_amount NUMBER;
        v_subject VARCHAR2(200);
        v_body CLOB;
        v_template CLOB;
        v_rejection_reason VARCHAR2(4000);
        v_next_steps VARCHAR2(4000);
    BEGIN
        -- الحصول على معلومات الطلب والعميل
        SELECT 
            c.customer_id,
            c.email,
            c.full_name,
            fa.REQUEST_NUMBER,
            p.product_name,
            fa.REQUEST_STATUS,
            fa.UPDATED_DATE,
            fa.REQUESTED_AMOUNT,
            fa.REJECT_REASONS
        INTO 
            v_customer_id,
            v_customer_email,
            v_customer_name,
            v_application_number,
            v_product_name,
            v_status,
            v_status_date,
            v_amount,
            v_rejection_reason
        FROM FINANCING_REQUESTS fa
        JOIN customers c ON fa.customer_id = c.customer_id
        JOIN ISLAMIC_PRODUCTS p ON fa.PRODUCT_ID = p.PRODUCT_ID
        WHERE fa.REQUEST_ID = p_application_id;
        
        -- التحقق من وجود بريد إلكتروني للعميل
        IF v_customer_email IS NULL OR v_customer_email = '' THEN
            RAISE_APPLICATION_ERROR(-20811, 'لا يوجد بريد إلكتروني مسجل للعميل');
        END IF;
        
        -- تحديد الخطوات التالية بناءً على حالة الطلب
        CASE v_status
            WHEN 'SUBMITTED' THEN
                v_next_steps := 'سيتم مراجعة طلبك من قبل فريقنا المختص. سنقوم بإعلامك بأي تطورات.';
            WHEN 'UNDER_REVIEW' THEN
                v_next_steps := 'طلبك قيد المراجعة حالياً. قد نتواصل معك لطلب معلومات إضافية إذا لزم الأمر.';
            WHEN 'PENDING_DOCUMENTS' THEN
                v_next_steps := 'يرجى تقديم المستندات المطلوبة لاستكمال طلبك. يمكنك تحميل المستندات من خلال حسابك على موقعنا الإلكتروني.';
            WHEN 'APPROVED' THEN
                v_next_steps := 'تهانينا! تمت الموافقة على طلبك. سيتم التواصل معك قريباً لاستكمال إجراءات التمويل.';
            WHEN 'REJECTED' THEN
                v_next_steps := 'يمكنك التقدم بطلب جديد بعد معالجة أسباب الرفض. للمزيد من المعلومات، يرجى التواصل مع خدمة العملاء.';
            WHEN 'CANCELLED' THEN
                v_next_steps := 'تم إلغاء طلبك بناءً على طلبك. يمكنك التقدم بطلب جديد في أي وقت.';
            WHEN 'COMPLETED' THEN
                v_next_steps := 'تم استكمال طلبك بنجاح وتم إنشاء حساب التمويل الخاص بك.';
            ELSE
                v_next_steps := 'للمزيد من المعلومات حول طلبك، يرجى التواصل مع خدمة العملاء.';
        END CASE;
        
        -- الحصول على قالب البريد الإلكتروني من إعدادات النظام
        v_template := system_management.get_system_setting('EMAIL_TEMPLATE_APPLICATION_STATUS_' || v_status, '');
        
        -- إذا لم يتم العثور على قالب، استخدم قالب افتراضي
        IF v_template IS NULL OR v_template = '' THEN
            v_template := '
            <html dir="rtl">
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    .header { background-color: #f8f9fa; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .footer { background-color: #f8f9fa; padding: 10px; text-align: center; font-size: 12px; }
                    .status { font-weight: bold; }
                    .details { margin: 20px 0; padding: 15px; border: 1px solid #dee2e6; border-radius: 5px; }
                    .approved { color: #28a745; }
                    .rejected { color: #dc3545; }
                    .pending { color: #ffc107; }
                    .cancelled { color: #6c757d; }
                    .completed { color: #17a2b8; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2>تحديث حالة طلب التمويل</h2>
                </div>
                <div class="content">
                    <p>عزيزي العميل {CUSTOMER_NAME}،</p>
                    <p>نود إعلامك بأن حالة طلب التمويل الخاص بك قد تم تحديثها.</p>
                    <div class="details">
                        <p><strong>رقم الطلب:</strong> {APPLICATION_NUMBER}</p>
                        <p><strong>المنتج:</strong> {PRODUCT_NAME}</p>
                        <p><strong>المبلغ المطلوب:</strong> {AMOUNT} ريال</p>
                        <p><strong>الحالة الحالية:</strong> <span class="{STATUS_CLASS}">{STATUS}</span></p>
                        <p><strong>تاريخ التحديث:</strong> {STATUS_DATE}</p>
                        {REJECTION_REASON}
                    </div>
                    <p><strong>الخطوات التالية:</strong></p>
                    <p>{NEXT_STEPS}</p>
                    <p>في حال وجود أي استفسارات، يرجى التواصل مع خدمة العملاء على الرقم: {SUPPORT_PHONE}</p>
                </div>
                <div class="footer">
                    <p>هذا البريد الإلكتروني تم إرساله تلقائياً، يرجى عدم الرد عليه.</p>
                    <p>© {CURRENT_YEAR} {COMPANY_NAME}. جميع الحقوق محفوظة.</p>
                </div>
            </body>
            </html>';
        END IF;
        
        -- تحديد فئة CSS للحالة
        DECLARE
            v_status_class VARCHAR2(20);
            v_status_arabic VARCHAR2(100);
            v_rejection_reason_html VARCHAR2(4000) := '';
        BEGIN
            -- تحديد فئة CSS للحالة
            CASE v_status
                WHEN 'SUBMITTED' THEN v_status_class := 'pending';
                WHEN 'UNDER_REVIEW' THEN v_status_class := 'pending';
                WHEN 'PENDING_DOCUMENTS' THEN v_status_class := 'pending';
                WHEN 'APPROVED' THEN v_status_class := 'approved';
                WHEN 'REJECTED' THEN v_status_class := 'rejected';
                WHEN 'CANCELLED' THEN v_status_class := 'cancelled';
                WHEN 'COMPLETED' THEN v_status_class := 'completed';
                ELSE v_status_class := '';
            END CASE;
            
            -- تحديد الترجمة العربية للحالة
            CASE v_status
                WHEN 'SUBMITTED' THEN v_status_arabic := 'تم تقديم الطلب';
                WHEN 'UNDER_REVIEW' THEN v_status_arabic := 'قيد المراجعة';
                WHEN 'PENDING_DOCUMENTS' THEN v_status_arabic := 'في انتظار المستندات';
                WHEN 'APPROVED' THEN v_status_arabic := 'تمت الموافقة';
                WHEN 'REJECTED' THEN v_status_arabic := 'مرفوض';
                WHEN 'CANCELLED' THEN v_status_arabic := 'ملغي';
                WHEN 'COMPLETED' THEN v_status_arabic := 'مكتمل';
                ELSE v_status_arabic := v_status;
            END CASE;
            
            -- إضافة سبب الرفض إذا كانت الحالة مرفوضة
            IF v_status = 'REJECTED' AND v_rejection_reason IS NOT NULL THEN
                v_rejection_reason_html := '<p><strong>سبب الرفض:</strong> ' || v_rejection_reason || '</p>';
            ELSE
                v_rejection_reason_html := '';
            END IF;
            
            -- استبدال المتغيرات في القالب
            v_body := REPLACE(v_template, '{CUSTOMER_NAME}', v_customer_name);
            v_body := REPLACE(v_body, '{APPLICATION_NUMBER}', v_application_number);
            v_body := REPLACE(v_body, '{PRODUCT_NAME}', v_product_name);
            v_body := REPLACE(v_body, '{AMOUNT}', TO_CHAR(v_amount, '999,999,999.99'));
            v_body := REPLACE(v_body, '{STATUS}', v_status_arabic);
            v_body := REPLACE(v_body, '{STATUS_CLASS}', v_status_class);
            v_body := REPLACE(v_body, '{STATUS_DATE}', TO_CHAR(v_status_date, 'DD/MM/YYYY HH24:MI'));
            v_body := REPLACE(v_body, '{REJECTION_REASON}', v_rejection_reason_html);
            v_body := REPLACE(v_body, '{NEXT_STEPS}', v_next_steps);
            v_body := REPLACE(v_body, '{SUPPORT_PHONE}', system_management.get_system_setting('SUPPORT_PHONE', '920000000'));
            v_body := REPLACE(v_body, '{COMPANY_NAME}', system_management.get_system_setting('COMPANY_NAME', 'شركة التمويل'));
            v_body := REPLACE(v_body, '{CURRENT_YEAR}', TO_CHAR(SYSDATE, 'YYYY'));
        END;
        
        -- تحديد عنوان البريد الإلكتروني
        v_subject := 'تحديث حالة طلب التمويل رقم ' || v_application_number;
        
        -- إرسال البريد الإلكتروني
        send_email(
            v_customer_email,
            v_subject,
            v_body,
            NULL,
            NULL,
            NULL,
            p_email_id
        );
        
        -- تحديث سجل البريد بمعلومات الطلب
        UPDATE email_logs
        SET reference_id = p_application_id,
            reference_type = 'APPLICATION'
        WHERE email_id = p_email_id;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20812, 'الطلب غير موجود');
        WHEN OTHERS THEN
            ROLLBACK;
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.send_application_status_notification',
                NULL,
                NULL,
                p_application_id,
                'APPLICATION'
            );
            RAISE;
    END send_application_status_notification;
    
    -- إرسال بريد إلكتروني لإعادة تعيين كلمة المرور
    PROCEDURE send_password_reset_email(
        p_user_id IN NUMBER,
        p_reset_token IN VARCHAR2,
        p_email_id OUT NUMBER
    ) IS
        v_user_email VARCHAR2(255);
        v_user_name VARCHAR2(255);
        v_reset_link VARCHAR2(500);
        v_subject VARCHAR2(200);
        v_body CLOB;
        v_template CLOB;
        v_base_url VARCHAR2(255);
        v_expiry_hours NUMBER;
    BEGIN
        -- الحصول على معلومات المستخدم
        SELECT email, full_name INTO v_user_email, v_user_name
        FROM users
        WHERE user_id = p_user_id
        AND USER_STATUS = 'ACTIVE';
        
        -- التحقق من وجود بريد إلكتروني للمستخدم
        IF v_user_email IS NULL OR v_user_email = '' THEN
            RAISE_APPLICATION_ERROR(-20813, 'لا يوجد بريد إلكتروني مسجل للمستخدم');
        END IF;
        
        -- الحصول على إعدادات إعادة تعيين كلمة المرور
        v_base_url := system_management.get_system_setting('BASE_URL', 'https://finance-system.example.com');
        v_expiry_hours := TO_NUMBER(system_management.get_system_setting('PASSWORD_RESET_EXPIRY_HOURS', '24'));
        
        -- إنشاء رابط إعادة تعيين كلمة المرور
        v_reset_link := v_base_url || '/reset-password?token=' || p_reset_token;
        
        -- الحصول على قالب البريد الإلكتروني من إعدادات النظام
        v_template := system_management.get_system_setting('EMAIL_TEMPLATE_PASSWORD_RESET', '');
        
        -- إذا لم يتم العثور على قالب، استخدم قالب افتراضي
        IF v_template IS NULL OR v_template = '' THEN
            v_template := '
            <html dir="rtl">
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    .header { background-color: #f8f9fa; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .footer { background-color: #f8f9fa; padding: 10px; text-align: center; font-size: 12px; }
                    .button { display: inline-block; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px; margin: 20px 0; }
                    .warning { color: #dc3545; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2>إعادة تعيين كلمة المرور</h2>
                </div>
                <div class="content">
                    <p>عزيزي {USER_NAME}،</p>
                    <p>لقد تلقينا طلباً لإعادة تعيين كلمة المرور الخاصة بحسابك. إذا لم تقم بطلب إعادة تعيين كلمة المرور، يرجى تجاهل هذا البريد الإلكتروني.</p>
                    <p>لإعادة تعيين كلمة المرور، يرجى النقر على الرابط أدناه:</p>
                    <p style="text-align: center;">
                        <a href="{RESET_LINK}" class="button">إعادة تعيين كلمة المرور</a>
                    </p>
                    <p>أو يمكنك نسخ ولصق الرابط التالي في متصفحك:</p>
                    <p>{RESET_LINK}</p>
                    <p class="warning">ملاحظة: هذا الرابط صالح لمدة {EXPIRY_HOURS} ساعة فقط.</p>
                    <p>إذا لم تقم بطلب إعادة تعيين كلمة المرور، يرجى تجاهل هذا البريد الإلكتروني أو التواصل مع الدعم الفني على الفور.</p>
                    <p>في حال وجود أي استفسارات، يرجى التواصل مع خدمة العملاء على الرقم: {SUPPORT_PHONE}</p>
                </div>
                <div class="footer">
                    <p>هذا البريد الإلكتروني تم إرساله تلقائياً، يرجى عدم الرد عليه.</p>
                    <p>© {CURRENT_YEAR} {COMPANY_NAME}. جميع الحقوق محفوظة.</p>
                </div>
            </body>
            </html>';
        END IF;
        
        -- استبدال المتغيرات في القالب
        v_body := REPLACE(v_template, '{USER_NAME}', v_user_name);
        v_body := REPLACE(v_body, '{RESET_LINK}', v_reset_link);
        v_body := REPLACE(v_body, '{EXPIRY_HOURS}', v_expiry_hours);
        v_body := REPLACE(v_body, '{SUPPORT_PHONE}', system_management.get_system_setting('SUPPORT_PHONE', '920000000'));
        v_body := REPLACE(v_body, '{COMPANY_NAME}', system_management.get_system_setting('COMPANY_NAME', 'شركة التمويل'));
        v_body := REPLACE(v_body, '{CURRENT_YEAR}', TO_CHAR(SYSDATE, 'YYYY'));
        
        -- تحديد عنوان البريد الإلكتروني
        v_subject := 'إعادة تعيين كلمة المرور - ' || system_management.get_system_setting('COMPANY_NAME', 'شركة التمويل');
        
        -- إرسال البريد الإلكتروني
        send_email(
            v_user_email,
            v_subject,
            v_body,
            NULL,
            NULL,
            NULL,
            p_email_id
        );
        
        -- تحديث سجل البريد بمعلومات المستخدم
        UPDATE email_logs
        SET reference_id = p_user_id,
            reference_type = 'USER'
        WHERE email_id = p_email_id;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20814, 'المستخدم غير موجود أو غير نشط');
        WHEN OTHERS THEN
            ROLLBACK;
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.send_password_reset_email',
                NULL,
                NULL,
                p_user_id,
                'USER'
            );
            RAISE;
    END send_password_reset_email;
    
    -- الحصول على سجل البريد الإلكتروني
    PROCEDURE get_email_log(
        p_email_id IN NUMBER,
        p_result OUT SYS_REFCURSOR
    ) IS
    BEGIN
        OPEN p_result FOR
            SELECT 
                el.email_id,
                el.email_to,
                el.email_cc,
                el.email_bcc,
                el.email_from,
                el.subject,
                el.email_body,
                el.attachment_path,
                el.status,
                el.error_message,
                el.created_date,
                el.SENT_DATE,
                el.reference_id,
                el.reference_type,
                CASE 
                    WHEN el.reference_type = 'CUSTOMER' THEN c.full_name
                    WHEN el.reference_type = 'USER' THEN u.full_name
                    ELSE NULL
                END AS reference_name
            FROM email_logs el
            LEFT JOIN customers c ON el.reference_type = 'CUSTOMER' AND el.reference_id = c.customer_id
            LEFT JOIN users u ON el.reference_type = 'USER' AND el.reference_id = u.user_id
            WHERE el.email_id = p_email_id;
    EXCEPTION
        WHEN OTHERS THEN
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.get_email_log',
                NULL,
                NULL,
                p_email_id,
                'EMAIL'
            );
            RAISE;
    END get_email_log;
    
    -- الحصول على سجلات البريد الإلكتروني للعميل
    PROCEDURE get_customer_email_logs(
        p_customer_id IN NUMBER,
        p_result OUT SYS_REFCURSOR
    ) IS
    BEGIN
        OPEN p_result FOR
            SELECT 
                email_id,
                email_to,
                subject,
                status,
                created_date,
                sent_date,
                reference_type
            FROM email_logs
            WHERE (reference_type = 'CUSTOMER' AND reference_id = p_customer_id)
               OR (reference_type = 'APPLICATION' AND reference_id IN (
                   SELECT REQUEST_NUMBER FROM FINANCING_REQUESTS WHERE customer_id = p_customer_id
               ))
               OR (reference_type = 'INSTALLMENT' AND reference_id IN (
                   SELECT i.installment_id 
                   FROM installment_schedule i
                   JOIN FINANCING_CONTRACTS fa ON i.REQUEST_ID = fa.REQUEST_ID
                   WHERE fa.customer_id = p_customer_id
               ))
               OR (reference_type = 'PAYMENT' AND reference_id IN (
                   SELECT p.payment_id 
                   FROM payments p
                   JOIN FINANCING_CONTRACTS fa ON p.FINANCING_ID = fa.FINANCING_ID
                   WHERE fa.customer_id = p_customer_id
               ))
            ORDER BY created_date DESC;
    EXCEPTION
        WHEN OTHERS THEN
            system_management.log_system_error(
                SQLCODE,
                SQLERRM,
                'email_management.get_customer_email_logs',
                NULL,
                NULL,
                p_customer_id,
                'CUSTOMER'
            );
            RAISE;
    END get_customer_email_logs;
END email_management;
/


CREATE OR REPLACE PACKAGE BODY                islamic_financing AS
  
  -- التحقق من صحة المدخلات
  FUNCTION validate_financing_input(
    p_amount IN NUMBER, 
    p_rate IN NUMBER, 
    p_period IN NUMBER
  ) RETURN BOOLEAN IS
  BEGIN
    -- التحقق من المبلغ
    IF p_amount IS NULL OR p_amount <= 0 THEN
      RETURN FALSE;
    END IF;
    
    -- التحقق من النسبة
    IF p_rate IS NULL OR p_rate < 0 OR p_rate > 100 THEN
      RETURN FALSE;
    END IF;
    
    -- التحقق من المدة
    IF p_period IS NULL OR p_period <= 0 THEN
      RETURN FALSE;
    END IF;
    
    RETURN TRUE;
  END validate_financing_input;
  
  -- حساب المرابحة
  FUNCTION calculate_murabaha(
    p_principal_amount IN NUMBER, 
    p_profit_rate IN NUMBER, 
    p_period_months IN NUMBER
  ) RETURN NUMBER IS
    v_total_amount NUMBER;
    v_profit_amount NUMBER;
  BEGIN
    -- التحقق من المدخلات
    IF NOT validate_financing_input(p_principal_amount, p_profit_rate, p_period_months) THEN
      RAISE_APPLICATION_ERROR(-20001, 'قيم غير صالحة لحساب المرابحة');
    END IF;
    
    -- حساب مبلغ الربح
    v_profit_amount := p_principal_amount * (p_profit_rate / 100) * (p_period_months / 12);
    
    -- حساب إجمالي المبلغ
    v_total_amount := p_principal_amount + v_profit_amount;
    
    RETURN v_total_amount;
  EXCEPTION
    WHEN OTHERS THEN
      -- تسجيل الخطأ
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        'SQLERRM', 
        'CALCULATE_MURABAHA', 
        SYSDATE
      );
      
      RAISE;
  END calculate_murabaha;
  
  -- حساب الإجارة
  FUNCTION calculate_ijara(
    p_asset_value IN NUMBER, 
    p_rental_rate IN NUMBER, 
    p_period_months IN NUMBER
  ) RETURN NUMBER IS
    v_total_rent NUMBER;
    v_monthly_rent NUMBER;
    v_total_amount NUMBER;
  BEGIN
    -- التحقق من المدخلات
    IF NOT validate_financing_input(p_asset_value, p_rental_rate, p_period_months) THEN
      RAISE_APPLICATION_ERROR(-20002, 'قيم غير صالحة لحساب الإجارة');
    END IF;
    
    -- حساب الإيجار الشهري
    v_monthly_rent := p_asset_value * (p_rental_rate / 100) / 12;
    
    -- حساب إجمالي الإيجار
    v_total_rent := v_monthly_rent * p_period_months;
    
    -- إجمالي المبلغ (الإيجار + قيمة الأصل)
    v_total_amount := v_total_rent + p_asset_value;
    
    RETURN v_total_amount;
  EXCEPTION
    WHEN OTHERS THEN
      -- تسجيل الخطأ
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        'SQLERRM', 
        'CALCULATE_IJARA', 
        SYSDATE
      );
      
      RAISE;
  END calculate_ijara;
  
  -- حساب المشاركة
  FUNCTION calculate_musharaka(
    p_project_value IN NUMBER, 
    p_bank_share_pct IN NUMBER, 
    p_expected_profit IN NUMBER
  ) RETURN NUMBER IS
    v_bank_contribution NUMBER;
    v_bank_profit NUMBER;
    v_total_return NUMBER;
  BEGIN
    -- التحقق من المدخلات
    IF p_project_value <= 0 OR p_bank_share_pct <= 0 OR 
       p_bank_share_pct > 100 OR p_expected_profit < 0 THEN
      RAISE_APPLICATION_ERROR(-20003, 'قيم غير صالحة لحساب المشاركة');
    END IF;
    
    -- حساب مساهمة البنك
    v_bank_contribution := p_project_value * (p_bank_share_pct / 100);
    
    -- حساب حصة البنك من الربح
    v_bank_profit := p_expected_profit * (p_bank_share_pct / 100);
    
    -- إجمالي العائد للبنك
    v_total_return := v_bank_contribution + v_bank_profit;
    
    RETURN v_total_return;
  EXCEPTION
    WHEN OTHERS THEN
      -- تسجيل الخطأ
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        'SQLERRM', 
        'CALCULATE_MUSHARAKA', 
        SYSDATE
      );
      
      RAISE;
  END calculate_musharaka;
  
  -- إنشاء جدول الأقساط
  PROCEDURE create_installment_schedule(
    p_contract_id IN NUMBER, 
    p_total_amount IN NUMBER, 
    p_period_months IN NUMBER, 
    p_start_date IN DATE
  ) IS
    v_monthly_installment NUMBER;
    v_due_date DATE;
    P_ERR_MSG VARCHAR2(3001);
  BEGIN
    -- التحقق من المدخلات
    IF p_contract_id IS NULL OR p_total_amount <= 0 OR p_period_months <= 0 THEN
      RAISE_APPLICATION_ERROR(-20004, 'قيم غير صالحة لإنشاء جدول الأقساط');
    END IF;
    
    -- حساب القسط الشهري
    v_monthly_installment := ROUND(p_total_amount / p_period_months, 2);
    
    -- حذف أي أقساط موجودة سابقاً لهذا العقد
    DELETE FROM INSTALLMENT_SCHEDULE WHERE contract_id = p_contract_id;
    
    -- إنشاء الأقساط
    FOR i IN 1..p_period_months LOOP
      v_due_date := ADD_MONTHS(p_start_date, i);
      
      INSERT INTO INSTALLMENT_SCHEDULE (
        contract_id,
        INSTALLMENT_ID,
        PRINCIPAL_AMOUNT,
        due_date,
        INSTALLMENT_STATUS
      ) VALUES (
        p_contract_id,
        i,
        v_monthly_installment,
        v_due_date,
        'PENDING'
      );
    END LOOP;
    
    -- تسجيل العملية
    INSERT INTO transaction_log (
      contract_id,
      transaction_type,
      description,
      transaction_date
    ) VALUES (
      p_contract_id,
      'SCHEDULE_CREATION',
      'تم إنشاء جدول أقساط بقيمة ' || TO_CHAR(v_monthly_installment) || ' ريال شهرياً',
      SYSDATE
    );
    
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      P_ERR_MSG:=''||SQLCODE||' '||SQLERRM;
      -- تسجيل الخطأ
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        P_ERR_MSG, 
        'CREATE_INSTALLMENT_SCHEDULE', 
        SYSDATE
      );
      
      RAISE;
  END create_installment_schedule;
  
  -- تسجيل دفعة
  PROCEDURE record_payment(
    p_installment_id IN NUMBER, 
    p_payment_amount IN NUMBER, 
    p_payment_date IN DATE
  ) IS
    v_installment_amount NUMBER;
    v_contract_id NUMBER;
    v_installment_number NUMBER;
    P_ERR_MSG VARCHAR2(3001);
  BEGIN
    -- التحقق من المدخلات
    IF p_installment_id IS NULL OR p_payment_amount <= 0 THEN
      RAISE_APPLICATION_ERROR(-20005, 'قيم غير صالحة لتسجيل الدفعة');
    END IF;
    
    -- الحصول على معلومات القسط
    SELECT TOTAL_AMOUNT, contract_id, installment_seq
    INTO v_installment_amount, v_contract_id, v_installment_number
    FROM INSTALLMENT_SCHEDULE
    WHERE installment_id = p_installment_id
    AND INSTALLMENT_STATUS = 'PENDING';
    
    -- التحقق من مبلغ الدفعة
    IF p_payment_amount < v_installment_amount THEN
      RAISE_APPLICATION_ERROR(-20006, 'مبلغ الدفعة أقل من قيمة القسط');
    END IF;
    
    -- تحديث حالة القسط
    UPDATE INSTALLMENT_SCHEDULE
    SET INSTALLMENT_STATUS = 'PAID',
        payment_date = p_payment_date,
        PAID_AMOUNT = p_payment_amount
    WHERE installment_id = p_installment_id;
    
    -- تسجيل العملية
    INSERT INTO transaction_log (
      contract_id,
      transaction_type,
      description,
      transaction_date
    ) VALUES (
      v_contract_id,
      'PAYMENT',
      'تم دفع القسط رقم ' || TO_CHAR(v_installment_number) || ' بمبلغ ' || TO_CHAR(p_payment_amount) || ' ريال',
      SYSDATE
    );
    
    COMMIT;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20007, 'القسط غير موجود أو تم دفعه مسبقاً');
    WHEN OTHERS THEN
      ROLLBACK;
      P_ERR_MSG:=''||SQLCODE||' '||SQLERRM;
      -- تسجيل الخطأ
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        P_ERR_MSG, 
        'RECORD_PAYMENT', 
        SYSDATE
      );
      
      RAISE;
  END record_payment;

  -- إنشاء عقد تمويل جديد
  PROCEDURE create_financing_contract(
    p_customer_id IN NUMBER,
    p_financing_type IN VARCHAR2,
    p_amount IN NUMBER,
    p_period_months IN NUMBER,
    p_profit_rate IN NUMBER,
    p_start_date IN DATE,
    p_contract_id OUT NUMBER,
    p_status OUT VARCHAR2
  ) IS
    v_total_amount NUMBER;
  BEGIN
    -- التحقق من المدخلات
    IF p_customer_id IS NULL OR p_amount <= 0 OR p_period_months <= 0 OR
       p_profit_rate < 0 OR p_profit_rate > 100 THEN
      RAISE_APPLICATION_ERROR(-20008, 'قيم غير صالحة لإنشاء عقد التمويل');
    END IF;
    
    -- التحقق من نوع التمويل وحساب المبلغ الإجمالي
    IF UPPER(p_financing_type) = 'MURABAHA' THEN
      v_total_amount := calculate_murabaha(p_amount, p_profit_rate, p_period_months);
    ELSIF UPPER(p_financing_type) = 'IJARA' THEN
      v_total_amount := calculate_ijara(p_amount, p_profit_rate, p_period_months);
    ELSIF UPPER(p_financing_type) = 'MUSHARAKA' THEN
      -- في حالة المشاركة، نفترض أن p_profit_rate هي نسبة مساهمة البنك
      -- وp_period_months هو الربح المتوقع
      v_total_amount := calculate_musharaka(p_amount, p_profit_rate, p_period_months);
    ELSE
      RAISE_APPLICATION_ERROR(-20009, 'نوع تمويل غير صالح');
    END IF;
    
    -- إدراج العقد في قاعدة البيانات
    INSERT INTO financing_contracts (
      customer_id,
      financing_type,
      FINANCING_AMOUNT,
      total_amount,
      FINANCING_PERIOD,
      profit_rate,
      start_date,
      CONTRACT_STATUS
    ) VALUES (
      p_customer_id,
      UPPER(p_financing_type),
      p_amount,
      v_total_amount,
      p_period_months,
      p_profit_rate,
      p_start_date,
      'ACTIVE'
    ) RETURNING FINANCING_ID INTO p_contract_id;
    
    -- إنشاء جدول الأقساط
    create_installment_schedule(p_contract_id, v_total_amount, p_period_months, p_start_date);
    
    -- تسجيل العملية
    INSERT INTO transaction_log (
      contract_id,
      transaction_type,
      description,
      transaction_date
    ) VALUES (
      p_contract_id,
      'CONTRACT_CREATION',
      'تم إنشاء عقد تمويل ' || UPPER(p_financing_type) || ' بمبلغ ' || TO_CHAR(p_amount) || ' ريال',
      SYSDATE
    );
    
    p_status := 'SUCCESS';
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      p_status := 'ERROR: ' || SQLERRM;
      ---P_ERR_MSG:=''||SQLCODE||' '||SQLERRM;
      -- تسجيل الخطأ
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        p_status, 
        'CREATE_FINANCING_CONTRACT', 
        SYSDATE
      );
      
      COMMIT; -- لتسجيل الخطأ
  END create_financing_contract;
  
  -- الحصول على معلومات العقد
  PROCEDURE get_contract_details(
    p_contract_id IN NUMBER,
    p_customer_id OUT NUMBER,
    p_financing_type OUT VARCHAR2,
    p_principal_amount OUT NUMBER,
    p_total_amount OUT NUMBER,
    p_period_months OUT NUMBER,
    p_profit_rate OUT NUMBER,
    p_remaining_amount OUT NUMBER,
    p_status OUT VARCHAR2
  ) IS
  ---
  P_ERR_MSG VARCHAR2(3001);
  ---
  BEGIN
    -- التحقق من وجود العقد
    SELECT customer_id, financing_type, FINANCING_AMOUNT, total_amount,
           FINANCING_PERIOD, profit_rate, CONTRACT_STATUS
    INTO p_customer_id, p_financing_type, p_principal_amount, p_total_amount,
         p_period_months, p_profit_rate, p_status
    FROM financing_contracts
    WHERE FINANCING_ID = p_contract_id;
    
    -- حساب المبلغ المتبقي
    p_remaining_amount := calculate_remaining_amount(p_contract_id);
    
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20010, 'العقد غير موجود');
    WHEN OTHERS THEN
      -- تسجيل الخطأ
      P_ERR_MSG:=''||SQLCODE||' '||SQLERRM;
      ---
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        P_ERR_MSG, 
        'GET_CONTRACT_DETAILS', 
        SYSDATE
      );
      
      RAISE;
  END get_contract_details;
  
  -- حساب المبلغ المتبقي للعقد
  FUNCTION calculate_remaining_amount(
    p_contract_id IN NUMBER
  ) RETURN NUMBER IS
    v_total_amount NUMBER;
    v_paid_amount NUMBER;
    v_remaining_amount NUMBER;
    P_ERR_MSG VARCHAR2(3001);
    ---
  BEGIN
    -- الحصول على إجمالي المبلغ
    SELECT total_amount
    INTO v_total_amount
    FROM financing_contracts
    WHERE FINANCING_ID = p_contract_id;
    
    -- حساب المبلغ المدفوع
    SELECT NVL(SUM(PAID_AMOUNT), 0)
    INTO v_paid_amount
    FROM INSTALLMENT_SCHEDULE
    WHERE contract_id = p_contract_id
    AND INSTALLMENT_STATUS = 'PAID';
    
    -- حساب المبلغ المتبقي
    v_remaining_amount := v_total_amount - v_paid_amount;
    
    RETURN v_remaining_amount;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN 0;
    WHEN OTHERS THEN
      -- تسجيل الخطأ
      P_ERR_MSG:=''||SQLCODE||' '||SQLERRM;
      ---
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        P_ERR_MSG, 
        'CALCULATE_REMAINING_AMOUNT', 
        SYSDATE
      );
      
      RAISE;
  END calculate_remaining_amount;
  
  -- الحصول على الأقساط المتأخرة
  FUNCTION get_overdue_installments(
    p_contract_id IN NUMBER
  ) RETURN SYS_REFCURSOR IS
    v_cursor SYS_REFCURSOR;
    P_ERR_MSG VARCHAR2(3001);
    ---
  BEGIN
    OPEN v_cursor FOR
      SELECT installment_id, CONTRACT_ID, TOTAL_AMOUNT, due_date,
             SYSDATE - due_date AS days_overdue
      FROM INSTALLMENT_SCHEDULE
      WHERE contract_id = p_contract_id
      AND INSTALLMENT_STATUS = 'PENDING'
      AND due_date < SYSDATE
      ORDER BY due_date;
      
    RETURN v_cursor;
  EXCEPTION
    WHEN OTHERS THEN
      -- تسجيل الخطأ
      P_ERR_MSG:=''||SQLCODE||' '||SQLERRM;
      ---
      INSERT INTO error_log (
        error_code, 
        error_message, 
        procedure_name, 
        error_date
      ) VALUES (
        'SQLCODE', 
        P_ERR_MSG, 
        'GET_OVERDUE_INSTALLMENTS', 
        SYSDATE
      );
      
      RAISE;
  END get_overdue_installments;
  
END islamic_financing;
/


CREATE OR REPLACE PACKAGE BODY                PKG_COLLATERALS AS
    -- إضافة ضمان جديد
    PROCEDURE ADD_COLLATERAL(
        p_customer_id IN NUMBER,
        p_collateral_type IN VARCHAR2,
        p_collateral_desc IN VARCHAR2,
        p_estimated_value IN NUMBER,
        p_ownership_document_no IN VARCHAR2,
        p_ownership_status IN VARCHAR2,
        p_notes IN VARCHAR2,
        p_created_by IN NUMBER,
        p_collateral_id OUT NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
    BEGIN
        p_success := FALSE;
        
        -- التحقق من وجود العميل
        DECLARE
            v_customer_exists NUMBER;
        BEGIN
            SELECT 1 INTO v_customer_exists
            FROM CUSTOMERS
            WHERE CUSTOMER_ID = p_customer_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_error_message := 'العميل غير موجود';
                RETURN;
        END;
        
        -- إدخال بيانات الضمان الجديد
        INSERT INTO COLLATERALS (
            COLLATERAL_ID, CUSTOMER_ID, COLLATERAL_TYPE, COLLATERAL_DESCRIPTION,
            ESTIMATED_VALUE, OWNERSHIP_DOCUMENT_NO, OWNERSHIP_STATUS,
            STATUS, NOTES, CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_COLLATERAL_ID.NEXTVAL, p_customer_id, p_collateral_type, p_collateral_desc,
            p_estimated_value, p_ownership_document_no, p_ownership_status,
            'ACTIVE', p_notes, p_created_by, SYSTIMESTAMP
        ) RETURNING COLLATERAL_ID INTO p_collateral_id;
        
        -- تسجيل حدث إضافة الضمان
        INSERT INTO SYSTEM_LOGS (
            LOG_ID, LOG_TYPE, LOG_MESSAGE, USER_ID, CREATION_DATE
        ) VALUES (
            SEQ_LOG_ID.NEXTVAL, 'COLLATERAL', 'تمت إضافة ضمان جديد برقم: ' || p_collateral_id, 
            p_created_by, SYSTIMESTAMP
        );
        
        p_success := TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            p_error_message := 'حدث خطأ: ' || SQLERRM;
    END ADD_COLLATERAL;
    
    -- تحديث بيانات الضمان
    PROCEDURE UPDATE_COLLATERAL(
        p_collateral_id IN NUMBER,
        p_collateral_type IN VARCHAR2,
        p_collateral_desc IN VARCHAR2,
        p_estimated_value IN NUMBER,
        p_ownership_document_no IN VARCHAR2,
        p_ownership_status IN VARCHAR2,
        p_status IN VARCHAR2,
        p_notes IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
    BEGIN
        p_success := FALSE;
        
        -- التحقق من وجود الضمان
        DECLARE
            v_collateral_exists NUMBER;
        BEGIN
            SELECT 1 INTO v_collateral_exists
            FROM COLLATERALS
            WHERE COLLATERAL_ID = p_collateral_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_error_message := 'الضمان غير موجود';
                RETURN;
        END;
        
        -- تحديث بيانات الضمان
        UPDATE COLLATERALS
        SET COLLATERAL_TYPE = p_collateral_type,
            COLLATERAL_DESCRIPTION = p_collateral_desc,
            ESTIMATED_VALUE = p_estimated_value,
            OWNERSHIP_DOCUMENT_NO = p_ownership_document_no,
            OWNERSHIP_STATUS = p_ownership_status,
            STATUS = p_status,
            NOTES = p_notes,
            UPDATED_BY = p_updated_by,
            UPDATE_DATE = SYSTIMESTAMP
        WHERE COLLATERAL_ID = p_collateral_id;
        
        -- تسجيل حدث تحديث الضمان
        INSERT INTO SYSTEM_LOGS (
            LOG_ID, LOG_TYPE, LOG_MESSAGE, USER_ID, CREATION_DATE
        ) VALUES (
            SEQ_LOG_ID.NEXTVAL, 'COLLATERAL', 'تم تحديث بيانات الضمان رقم: ' || p_collateral_id, 
            p_updated_by, SYSTIMESTAMP
        );
        
        p_success := TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            p_error_message := 'حدث خطأ: ' || SQLERRM;
    END UPDATE_COLLATERAL;
    
    -- ربط الضمان بطلب تمويل
    PROCEDURE LINK_COLLATERAL_TO_REQUEST(
        p_collateral_id IN NUMBER,
        p_request_id IN NUMBER,
        p_created_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
        v_customer_id NUMBER;
        v_collateral_customer_id NUMBER;
        v_request_customer_id NUMBER;
    BEGIN
        p_success := FALSE;
        
        -- التحقق من وجود الضمان
        BEGIN
            SELECT CUSTOMER_ID INTO v_collateral_customer_id
            FROM COLLATERALS
            WHERE COLLATERAL_ID = p_collateral_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_error_message := 'الضمان غير موجود';
                RETURN;
        END;
        
        -- التحقق من وجود طلب التمويل
        BEGIN
            SELECT CUSTOMER_ID INTO v_request_customer_id
            FROM FINANCING_REQUESTS
            WHERE REQUEST_ID = p_request_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_error_message := 'طلب التمويل غير موجود';
                RETURN;
        END;
        
        -- التحقق من أن الضمان وطلب التمويل ينتميان لنفس العميل
        IF v_collateral_customer_id != v_request_customer_id THEN
            p_error_message := 'الضمان وطلب التمويل لا ينتميان لنفس العميل';
            RETURN;
        END IF;
        
        -- ربط الضمان بطلب التمويل
        INSERT INTO FINANCING_COLLATERALS (
            FINANCING_COLLATERAL_ID, REQUEST_ID, COLLATERAL_ID, 
            CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_FINANCING_COLLATERAL_ID.NEXTVAL, p_request_id, p_collateral_id, 
            p_created_by, SYSTIMESTAMP
        );
        
        -- تسجيل حدث ربط الضمان
        INSERT INTO SYSTEM_LOGS (
            LOG_ID, LOG_TYPE, LOG_MESSAGE, USER_ID, CREATION_DATE
        ) VALUES (
            SEQ_LOG_ID.NEXTVAL, 'COLLATERAL', 'تم ربط الضمان رقم: ' || p_collateral_id || ' بطلب التمويل رقم: ' || p_request_id, 
            p_created_by, SYSTIMESTAMP
        );
        
        p_success := TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            p_error_message := 'حدث خطأ: ' || SQLERRM;
    END LINK_COLLATERAL_TO_REQUEST;
    
    -- تقييم كفاية الضمانات لطلب تمويل
    FUNCTION EVALUATE_COLLATERAL_ADEQUACY(
        p_request_id IN NUMBER
    ) RETURN NUMBER IS
        v_total_collateral_value NUMBER := 0;
        v_financing_amount NUMBER := 0;
        v_adequacy_ratio NUMBER := 0;
    BEGIN
        -- الحصول على إجمالي قيمة الضمانات المرتبطة بالطلب
        SELECT NVL(SUM(c.ESTIMATED_VALUE), 0)
        INTO v_total_collateral_value
        FROM COLLATERALS c
        JOIN FINANCING_COLLATERALS fc ON c.COLLATERAL_ID = fc.COLLATERAL_ID
        WHERE fc.REQUEST_ID = p_request_id
        AND c.STATUS = 'ACTIVE';
        
        -- الحصول على مبلغ التمويل المطلوب
        SELECT NVL(REQUESTED_AMOUNT, 0)
        INTO v_financing_amount
        FROM FINANCING_REQUESTS
        WHERE REQUEST_ID = p_request_id;
        
        -- حساب نسبة كفاية الضمانات (قيمة الضمانات / مبلغ التمويل)
        IF v_financing_amount > 0 THEN
            v_adequacy_ratio := (v_total_collateral_value / v_financing_amount) * 100;
        ELSE
            v_adequacy_ratio := 0;
        END IF;
        
        RETURN v_adequacy_ratio;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 0;
    END EVALUATE_COLLATERAL_ADEQUACY;
    
    -- الحصول على قائمة الضمانات للعميل
    FUNCTION GET_CUSTOMER_COLLATERALS(
        p_customer_id IN NUMBER
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                c.COLLATERAL_ID,
                c.CUSTOMER_ID,
                c.COLLATERAL_TYPE,
                c.COLLATERAL_DESCRIPTION,
                c.ESTIMATED_VALUE,
                c.OWNERSHIP_DOCUMENT_NO,
                c.OWNERSHIP_STATUS,
                c.STATUS,
                c.NOTES,
                c.CREATION_DATE,
                c.UPDATE_DATE,
                u1.FULL_NAME AS CREATED_BY_NAME,
                u2.FULL_NAME AS UPDATED_BY_NAME,
                (
                    SELECT COUNT(*)
                    FROM FINANCING_COLLATERALS fc
                    JOIN FINANCING_REQUESTS fr ON fc.REQUEST_ID = fr.REQUEST_ID
                    WHERE fc.COLLATERAL_ID = c.COLLATERAL_ID
                    AND fr.REQUEST_STATUS NOT IN ('REJECTED', 'CANCELLED', 'COMPLETED')
                ) AS ACTIVE_LINKS_COUNT
            FROM 
                COLLATERALS c
            LEFT JOIN 
                USERS u1 ON c.CREATED_BY = u1.USER_ID
            LEFT JOIN 
                USERS u2 ON c.UPDATED_BY = u2.USER_ID
            WHERE 
                c.CUSTOMER_ID = p_customer_id
            ORDER BY 
                c.CREATION_DATE DESC;
        
        RETURN v_cursor;
    END GET_CUSTOMER_COLLATERALS;
    
    -- الحصول على تفاصيل ضمان معين
    FUNCTION GET_COLLATERAL_DETAILS(
        p_collateral_id IN NUMBER
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                c.COLLATERAL_ID,
                c.CUSTOMER_ID,
                cu.FULL_NAME AS CUSTOMER_NAME,
                c.COLLATERAL_TYPE,
                c.COLLATERAL_DESCRIPTION,
                c.ESTIMATED_VALUE,
                c.OWNERSHIP_DOCUMENT_NO,
                c.OWNERSHIP_STATUS,
                c.STATUS,
                c.NOTES,
                c.CREATION_DATE,
                c.UPDATE_DATE,
                u1.FULL_NAME AS CREATED_BY_NAME,
                u2.FULL_NAME AS UPDATED_BY_NAME,
                (
                    SELECT JSON_ARRAYAGG(
                        JSON_OBJECT(
                            'request_id' VALUE fr.REQUEST_ID,
                            'request_date' VALUE TO_CHAR(fr.CREATED_DATE, 'YYYY-MM-DD'),
                            'financing_amount' VALUE fr.REQUESTED_AMOUNT,
                            'request_status' VALUE fr.REQUEST_STATUS
                        )
                    )
                    FROM FINANCING_COLLATERALS fc
                    JOIN FINANCING_REQUESTS fr ON fc.REQUEST_ID = fr.REQUEST_ID
                    WHERE fc.COLLATERAL_ID = c.COLLATERAL_ID
                ) AS LINKED_REQUESTS
            FROM 
                COLLATERALS c
            JOIN 
                CUSTOMERS cu ON c.CUSTOMER_ID = cu.CUSTOMER_ID
            LEFT JOIN 
                USERS u1 ON c.CREATED_BY = u1.USER_ID
            LEFT JOIN 
                USERS u2 ON c.UPDATED_BY = u2.USER_ID
            WHERE 
                c.COLLATERAL_ID = p_collateral_id;
        
        RETURN v_cursor;
    END GET_COLLATERAL_DETAILS;
    
    -- الحصول على الضمانات المرتبطة بطلب تمويل
    FUNCTION GET_REQUEST_COLLATERALS(
        p_request_id IN NUMBER
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                c.COLLATERAL_ID,
                c.CUSTOMER_ID,
                c.COLLATERAL_TYPE,
                c.COLLATERAL_DESCRIPTION,
                c.ESTIMATED_VALUE,
                c.OWNERSHIP_DOCUMENT_NO,
                c.OWNERSHIP_STATUS,
                c.STATUS,
                c.NOTES,
                fc.CREATION_DATE AS LINK_DATE,
                u.FULL_NAME AS LINKED_BY
            FROM 
                COLLATERALS c
            JOIN 
                FINANCING_COLLATERALS fc ON c.COLLATERAL_ID = fc.COLLATERAL_ID
            JOIN 
                USERS u ON fc.CREATED_BY = u.USER_ID
            WHERE 
                fc.REQUEST_ID = p_request_id
            ORDER BY 
                fc.CREATION_DATE;
        
        RETURN v_cursor;
    END GET_REQUEST_COLLATERALS;
    
    -- تحديث قيمة الضمان
    PROCEDURE UPDATE_COLLATERAL_VALUE(
        p_collateral_id IN NUMBER,
        p_new_value IN NUMBER,
        p_valuation_date IN DATE,
        p_valuation_by IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
        v_old_value NUMBER;
    BEGIN
        p_success := FALSE;
        
        -- التحقق من وجود الضمان
        BEGIN
            SELECT ESTIMATED_VALUE INTO v_old_value
            FROM COLLATERALS
            WHERE COLLATERAL_ID = p_collateral_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_error_message := 'الضمان غير موجود';
                RETURN;
        END;
        
        -- تحديث قيمة الضمان
        UPDATE COLLATERALS
        SET ESTIMATED_VALUE = p_new_value,
            UPDATED_BY = p_updated_by,
            UPDATE_DATE = SYSTIMESTAMP
        WHERE COLLATERAL_ID = p_collateral_id;
        
        -- إضافة سجل تقييم الضمان
        INSERT INTO COLLATERAL_VALUATIONS (
            VALUATION_ID, COLLATERAL_ID, OLD_VALUE, NEW_VALUE,
            VALUATION_DATE, VALUATION_BY, NOTES, CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_COLLATERAL_VALUATION_ID.NEXTVAL, p_collateral_id, v_old_value, p_new_value,
            p_valuation_date, p_valuation_by, 'تحديث قيمة الضمان', p_updated_by, SYSTIMESTAMP
        );
        
        -- تسجيل حدث تحديث قيمة الضمان
        INSERT INTO SYSTEM_LOGS (
            LOG_ID, LOG_TYPE, LOG_MESSAGE, USER_ID, CREATION_DATE
        ) VALUES (
            SEQ_LOG_ID.NEXTVAL, 'COLLATERAL', 'تم تحديث قيمة الضمان رقم: ' || p_collateral_id || 
            ' من ' || v_old_value || ' إلى ' || p_new_value, 
            p_updated_by, SYSTIMESTAMP
        );
        
        p_success := TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            p_error_message := 'حدث خطأ: ' || SQLERRM;
    END UPDATE_COLLATERAL_VALUE;
    
    -- إضافة مستند للضمان
    PROCEDURE ADD_COLLATERAL_DOCUMENT(
        p_collateral_id IN NUMBER,
        p_document_type IN VARCHAR2,
        p_document_name IN VARCHAR2,
        p_document_path IN VARCHAR2,
        p_document_notes IN VARCHAR2,
        p_created_by IN NUMBER,
        p_document_id OUT NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
    BEGIN
        p_success := FALSE;
        
        -- التحقق من وجود الضمان
        DECLARE
            v_collateral_exists NUMBER;
        BEGIN
            SELECT 1 INTO v_collateral_exists
            FROM COLLATERALS
            WHERE COLLATERAL_ID = p_collateral_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_error_message := 'الضمان غير موجود';
                RETURN;
        END;
        
        -- إدخال بيانات المستند الجديد
        INSERT INTO COLLATERAL_DOCUMENTS (
            DOCUMENT_ID, COLLATERAL_ID, DOCUMENT_TYPE, DOCUMENT_NAME,
            DOCUMENT_PATH, DOCUMENT_NOTES, STATUS, CREATED_BY, CREATED_DATE
        ) VALUES (
            SEQ_COLLATERAL_DOCUMENT_ID.NEXTVAL, p_collateral_id, p_document_type, p_document_name,
            p_document_path, p_document_notes, 'ACTIVE', p_created_by, SYSTIMESTAMP
        ) RETURNING DOCUMENT_ID INTO p_document_id;
        
        -- تسجيل حدث إضافة المستند
        INSERT INTO SYSTEM_LOGS (
            LOG_ID, LOG_TYPE, LOG_MESSAGE, USER_ID, CREATION_DATE
        ) VALUES (
            SEQ_LOG_ID.NEXTVAL, 'DOCUMENT', 'تمت إضافة مستند جديد للضمان رقم: ' || p_collateral_id, 
            p_created_by, SYSTIMESTAMP
        );
        
        p_success := TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            p_error_message := 'حدث خطأ: ' || SQLERRM;
    END ADD_COLLATERAL_DOCUMENT;
    
    -- الحصول على مستندات الضمان
    FUNCTION GET_COLLATERAL_DOCUMENTS(
        p_collateral_id IN NUMBER
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                cd.DOCUMENT_ID,
                cd.COLLATERAL_ID,
                cd.DOCUMENT_TYPE,
                cd.DOCUMENT_NAME,
                cd.DOCUMENT_PATH,
                cd.DOCUMENT_NOTES,
                cd.STATUS,
                cd.CREATED_DATE,
                cd.UPDATED_DATE,
                u1.FULL_NAME AS CREATED_BY_NAME,
                u2.FULL_NAME AS UPDATED_BY_NAME
            FROM 
                COLLATERAL_DOCUMENTS cd
            LEFT JOIN 
                USERS u1 ON cd.CREATED_BY = u1.USER_ID
            LEFT JOIN 
                USERS u2 ON cd.UPDATED_BY = u2.USER_ID
            WHERE 
                cd.COLLATERAL_ID = p_collateral_id
            ORDER BY 
                cd.CREATED_DATE DESC;
        
        RETURN v_cursor;
    END GET_COLLATERAL_DOCUMENTS;
    
    -- حساب نسبة القرض إلى القيمة
    FUNCTION CALCULATE_LTV_RATIO(
        p_financing_amount IN NUMBER,
        p_collateral_value IN NUMBER
    ) RETURN NUMBER IS
        v_ltv_ratio NUMBER := 0;
    BEGIN
        IF p_collateral_value > 0 THEN
            v_ltv_ratio := (p_financing_amount / p_collateral_value) * 100;
        END IF;
        
        RETURN v_ltv_ratio;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 0;
    END CALCULATE_LTV_RATIO;
    
END PKG_COLLATERALS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_COMMITTEES AS
    -- إنشاء لجنة جديدة
    PROCEDURE CREATE_COMMITTEE(
        p_committee_name IN VARCHAR2,
        p_committee_type IN VARCHAR2,
        p_description IN CLOB,
        p_approval_limit IN NUMBER,
        p_created_by IN NUMBER,
        p_committee_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_COMMITTEE_ID.NEXTVAL INTO p_committee_id FROM DUAL;
        
        INSERT INTO COMMITTEES (
            COMMITTEE_ID, COMMITTEE_NAME, COMMITTEE_TYPE, DESCRIPTION,
            APPROVAL_LIMIT, CREATION_DATE, CREATED_BY
        ) VALUES (
            p_committee_id, p_committee_name, p_committee_type, p_description,
            p_approval_limit, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_COMMITTEE;
    
    -- إضافة عضو للجنة
    PROCEDURE ADD_COMMITTEE_MEMBER(
        p_committee_id IN NUMBER,
        p_user_id IN NUMBER,
        p_member_position IN VARCHAR2,
        p_is_chairman IN NUMBER,
        p_created_by IN NUMBER
    ) IS
        v_member_id NUMBER;
    BEGIN
        SELECT SEQ_COMMITTEE_MEMBER_ID.NEXTVAL INTO v_member_id FROM DUAL;
        
        INSERT INTO COMMITTEE_MEMBERS (
            MEMBER_ID, COMMITTEE_ID, USER_ID, MEMBER_POSITION,
            IS_CHAIRMAN, CREATION_DATE, CREATED_BY
        ) VALUES (
            v_member_id, p_committee_id, p_user_id, p_member_position,
            p_is_chairman, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_COMMITTEE_MEMBER;
    
    -- إرسال طلب للجنة
    PROCEDURE SUBMIT_REQUEST_TO_COMMITTEE(
        p_request_id IN NUMBER,
        p_committee_id IN NUMBER,
        p_notes IN CLOB,
        p_created_by IN NUMBER
    ) IS
    BEGIN
        INSERT INTO COMMITTEE_REQUESTS (
            REQUEST_ID, COMMITTEE_ID, SUBMISSION_DATE,
            NOTES, DECISION_STATUS, CREATION_DATE, CREATED_BY
        ) VALUES (
            p_request_id, p_committee_id, SYSDATE,
            p_notes, 'PENDING', SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END SUBMIT_REQUEST_TO_COMMITTEE;
    
    -- تسجيل قرار اللجنة
    PROCEDURE RECORD_COMMITTEE_DECISION(
        p_request_id IN NUMBER,
        p_committee_id IN NUMBER,
        p_decision IN VARCHAR2,
        p_decision_notes IN CLOB,
        p_decision_date IN DATE,
        p_updated_by IN NUMBER
    ) IS
    BEGIN
        UPDATE COMMITTEE_REQUESTS
        SET DECISION_STATUS = p_decision,
            DECISION_NOTES = p_decision_notes,
            DECISION_DATE = p_decision_date,
            UPDATE_DATE = SYSDATE,
            UPDATED_BY = p_updated_by
        WHERE REQUEST_ID = p_request_id
        AND COMMITTEE_ID = p_committee_id;
        
        -- تحديث حالة الطلب بناءً على قرار اللجنة
        IF p_decision = 'APPROVED' THEN
            UPDATE FINANCING_REQUESTS
            SET REQUEST_STATUS = 'APPROVED',
                UPDATED_DATE = SYSTIMESTAMP,
                UPDATED_BY = p_updated_by
            WHERE REQUEST_ID = p_request_id;
        ELSIF p_decision = 'REJECTED' THEN
            UPDATE FINANCING_REQUESTS
            SET REQUEST_STATUS = 'REJECTED',
                UPDATED_DATE = SYSTIMESTAMP,
                UPDATED_BY = p_updated_by
            WHERE REQUEST_ID = p_request_id;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END RECORD_COMMITTEE_DECISION;
    
    -- الحصول على اللجان
    FUNCTION GET_COMMITTEES RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT *
            FROM COMMITTEES
            ORDER BY COMMITTEE_TYPE, COMMITTEE_NAME;
        RETURN v_cursor;
    END GET_COMMITTEES;
    
    -- الحصول على أعضاء اللجنة
    FUNCTION GET_COMMITTEE_MEMBERS(p_committee_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT cm.*, u.FULL_NAME
            FROM COMMITTEE_MEMBERS cm
            JOIN USERS u ON cm.USER_ID = u.USER_ID
            WHERE cm.COMMITTEE_ID = p_committee_id
            ORDER BY cm.IS_CHAIRMAN DESC, u.FULL_NAME;
        RETURN v_cursor;
    END GET_COMMITTEE_MEMBERS;
    
    -- الحصول على طلبات اللجنة
    FUNCTION GET_COMMITTEE_REQUESTS(p_committee_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT cr.*, r.CUSTOMER_ID, c.FULL_NAME AS CUSTOMER_NAME,
                   r.PRODUCT_ID, p.PRODUCT_NAME, r.REQUESTED_AMOUNT AS REQUESTED_AMOUNT
            FROM COMMITTEE_REQUESTS cr
            JOIN FINANCING_REQUESTS r ON cr.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            WHERE cr.COMMITTEE_ID = p_committee_id
            ORDER BY cr.SUBMISSION_DATE DESC;
        RETURN v_cursor;
    END GET_COMMITTEE_REQUESTS;
END PKG_COMMITTEES;
/


CREATE OR REPLACE PACKAGE BODY                PKG_CREDIT_RATING AS
    -- إجراءات ودوال من الإصدار السابق
    -- إضافة معيار تصنيف ائتماني
    PROCEDURE ADD_CREDIT_CRITERIA(
        p_criteria_name IN VARCHAR2,
        p_criteria_type IN VARCHAR2,
        p_max_score IN NUMBER,
        p_weight IN NUMBER,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_criteria_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_CRITERIA_ID.NEXTVAL INTO p_criteria_id FROM DUAL;
        
        INSERT INTO CREDIT_CRITERIA (
            CRITERIA_ID, CRITERIA_NAME, CRITERIA_TYPE, MAX_SCORE,
            WEIGHT, DESCRIPTION, CREATED_DATE, CREATED_BY
        ) VALUES (
            p_criteria_id, p_criteria_name, p_criteria_type, p_max_score,
            p_weight, p_description, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_CREDIT_CRITERIA;
    
    -- تقييم العميل حسب معيار
    PROCEDURE RATE_CUSTOMER(
        p_customer_id IN NUMBER,
        p_criteria_id IN NUMBER,
        p_score_value IN NUMBER,
        p_created_by IN VARCHAR2,
        p_score_id OUT NUMBER
    ) IS
        v_max_score NUMBER;
    BEGIN
        -- التحقق من أن القيمة لا تتجاوز الحد الأقصى للمعيار
        SELECT MAX_SCORE INTO v_max_score
        FROM CREDIT_CRITERIA
        WHERE CRITERIA_ID = p_criteria_id;
        
        IF p_score_value > v_max_score THEN
            RAISE_APPLICATION_ERROR(-20001, 'Score value exceeds maximum allowed score for this criteria');
        END IF;
        
        -- حذف التقييم السابق إن وجد
        DELETE FROM CUSTOMER_CREDIT_SCORES
        WHERE CUSTOMER_ID = p_customer_id
        AND CRITERIA_ID = p_criteria_id;
        
        -- إضافة التقييم الجديد
        SELECT SEQ_SCORE_ID.NEXTVAL INTO p_score_id FROM DUAL;
        
        INSERT INTO CUSTOMER_CREDIT_SCORES (
            SCORE_ID, CUSTOMER_ID, CRITERIA_ID, SCORE_VALUE,
            EVALUATION_DATE, CREATED_DATE, CREATED_BY
        ) VALUES (
            p_score_id, p_customer_id, p_criteria_id, p_score_value,
            SYSDATE, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END RATE_CUSTOMER;
    
    -- حساب التصنيف الائتماني الإجمالي للعميل
    FUNCTION CALCULATE_CUSTOMER_RATING(p_customer_id IN NUMBER) RETURN NUMBER IS
        v_total_weighted_score NUMBER := 0;
        v_total_weight NUMBER := 0;
        v_final_rating NUMBER := 0;
    BEGIN
        -- حساب مجموع النقاط المرجحة ومجموع الأوزان
        SELECT NVL(SUM(cs.SCORE_VALUE * c.WEIGHT), 0), NVL(SUM(c.WEIGHT), 0)
        INTO v_total_weighted_score, v_total_weight
        FROM CUSTOMER_CREDIT_SCORES cs
        JOIN CREDIT_CRITERIA c ON cs.CRITERIA_ID = c.CRITERIA_ID
        WHERE cs.CUSTOMER_ID = p_customer_id;
        
        -- حساب التصنيف النهائي
        IF v_total_weight > 0 THEN
            v_final_rating := v_total_weighted_score / v_total_weight;
        END IF;
        
        RETURN v_final_rating;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 0;
    END CALCULATE_CUSTOMER_RATING;
    
    -- الحصول على معايير التصنيف
    FUNCTION GET_CREDIT_CRITERIA RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT *
            FROM CREDIT_CRITERIA
            ORDER BY CRITERIA_TYPE, CRITERIA_NAME;
        RETURN v_cursor;
    END GET_CREDIT_CRITERIA;
    
    -- الحصول على تقييم العميل
    FUNCTION GET_CUSTOMER_SCORES(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT cs.*, c.CRITERIA_NAME, c.CRITERIA_TYPE, c.MAX_SCORE, c.WEIGHT
            FROM CUSTOMER_CREDIT_SCORES cs
            JOIN CREDIT_CRITERIA c ON cs.CRITERIA_ID = c.CRITERIA_ID
            WHERE cs.CUSTOMER_ID = p_customer_id
            ORDER BY c.CRITERIA_TYPE, c.CRITERIA_NAME;
        RETURN v_cursor;
    END GET_CUSTOMER_SCORES;
    
    -- إجراءات ودوال من الإصدار الجديد
    -- إجراء لتحديث تصنيف العميل الائتماني
    PROCEDURE UPDATE_CUSTOMER_RATING(
        p_customer_id IN NUMBER,
        p_rating_value IN VARCHAR2 DEFAULT NULL,
        p_rating_score IN NUMBER DEFAULT NULL,
        p_rating_source IN VARCHAR2 DEFAULT 'SYSTEM',
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_created_by IN NUMBER DEFAULT 1
    ) IS
        v_rating_value VARCHAR2(20);
        v_rating_score NUMBER;
        v_rating_id NUMBER;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- تحديد قيمة التصنيف ودرجة التصنيف
        IF p_rating_value IS NOT NULL THEN
            v_rating_value := p_rating_value;
        ELSE
            -- حساب التصنيف بناءً على البيانات المالية والسلوكية للعميل
            -- هذا مجرد مثال بسيط، يمكن تعديله حسب قواعد العمل الخاصة بك
            SELECT 
                CASE 
                    WHEN COUNT(*) = 0 THEN 'C' -- عميل جديد
                    WHEN SUM(CASE WHEN fc.CONTRACT_STATUS = 'COMPLETED' THEN 1 ELSE 0 END) > 2 THEN 'A' -- أكثر من عقدين مكتملين
                    WHEN SUM(CASE WHEN fc.CONTRACT_STATUS = 'DEFAULTED' THEN 1 ELSE 0 END) > 0 THEN 'D' -- لديه عقود متعثرة
                    WHEN SUM(CASE WHEN fc.CONTRACT_STATUS = 'ACTIVE' THEN 1 ELSE 0 END) > 0 THEN 'B' -- لديه عقود نشطة
                    ELSE 'C' -- الحالة الافتراضية
                END INTO v_rating_value
            FROM FINANCING_CONTRACTS fc
            WHERE fc.CUSTOMER_ID = p_customer_id;
        END IF;
        
        IF p_rating_score IS NOT NULL THEN
            v_rating_score := p_rating_score;
        ELSE
            -- تحويل التصنيف إلى درجة رقمية
            v_rating_score := 
                CASE v_rating_value
                    WHEN 'A+' THEN 95
                    WHEN 'A' THEN 85
                    WHEN 'B+' THEN 75
                    WHEN 'B' THEN 65
                    WHEN 'C+' THEN 55
                    WHEN 'C' THEN 45
                    WHEN 'D' THEN 35
                    WHEN 'E' THEN 25
                    WHEN 'F' THEN 15
                    ELSE 50
                END;
        END IF;
        
        -- الحصول على معرف جديد للتصنيف
        SELECT SEQ_RATING_ID.NEXTVAL INTO v_rating_id FROM DUAL;
        
        -- إدخال تصنيف جديد
        INSERT INTO CUSTOMER_CREDIT_RATINGS (
            RATING_ID, CUSTOMER_ID, RATING_VALUE, RATING_SCORE,
            RATING_SOURCE, RATING_DATE, EXPIRY_DATE, NOTES,
            CREATED_BY, CREATION_DATE
        ) VALUES (
            v_rating_id, p_customer_id, v_rating_value, v_rating_score,
            p_rating_source, SYSDATE, ADD_MONTHS(SYSDATE, 12), p_notes,
            p_created_by, SYSTIMESTAMP
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_CUSTOMER_RATING;
    
    -- إجراء لتهيئة تصنيف العميل الائتماني
    PROCEDURE INITIALIZE_CUSTOMER_RATING(
        p_customer_id IN NUMBER,
        p_created_by IN NUMBER DEFAULT 1
    ) IS
        v_customer_exists NUMBER;
        v_rating_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- التحقق مما إذا كان العميل لديه تصنيف بالفعل
        SELECT COUNT(*) INTO v_rating_exists 
        FROM CUSTOMER_CREDIT_RATINGS 
        WHERE CUSTOMER_ID = p_customer_id;
        
        -- إذا لم يكن لديه تصنيف، قم بإنشاء تصنيف افتراضي
        IF v_rating_exists = 0 THEN
            UPDATE_CUSTOMER_RATING(
                p_customer_id => p_customer_id,
                p_rating_value => 'C', -- تصنيف افتراضي للعملاء الجدد
                p_rating_score => 45,
                p_rating_source => 'SYSTEM_INIT',
                p_notes => 'تصنيف أولي للعميل الجديد',
                p_created_by => p_created_by
            );
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END     INITIALIZE_CUSTOMER_RATING;
    
    -- دالة للحصول على تصنيف العميل الحالي
    FUNCTION GET_CUSTOMER_RATING(
        p_customer_id IN NUMBER
    ) RETURN VARCHAR2 IS
        v_rating VARCHAR2(20);
    BEGIN
        SELECT RATING_VALUE INTO v_rating
        FROM CUSTOMER_CREDIT_RATINGS
        WHERE CUSTOMER_ID = p_customer_id
        AND RATING_DATE = (
            SELECT MAX(RATING_DATE)
            FROM CUSTOMER_CREDIT_RATINGS
            WHERE CUSTOMER_ID = p_customer_id
        );
        
        RETURN v_rating;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END GET_CUSTOMER_RATING;
    
    -- دالة للحصول على درجة تصنيف العميل الحالية
    FUNCTION GET_CUSTOMER_RATING_SCORE(
        p_customer_id IN NUMBER
    ) RETURN NUMBER IS
        v_score NUMBER;
    BEGIN
        SELECT RATING_SCORE INTO v_score
        FROM CUSTOMER_CREDIT_RATINGS
        WHERE CUSTOMER_ID = p_customer_id
        AND RATING_DATE = (
            SELECT MAX(RATING_DATE)
            FROM CUSTOMER_CREDIT_RATINGS
            WHERE CUSTOMER_ID = p_customer_id
        );
        
        RETURN v_score;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END GET_CUSTOMER_RATING_SCORE;
    
    -- دالة للتحقق من أهلية العميل للتمويل
    -- تحديث دالة IS_CUSTOMER_ELIGIBLE لتتوافق مع هيكل جدول ISLAMIC_PRODUCTS
FUNCTION IS_CUSTOMER_ELIGIBLE(
    p_customer_id IN NUMBER,
    p_product_id IN NUMBER,
    p_amount IN NUMBER
) RETURN BOOLEAN IS
    v_rating VARCHAR2(20);
    v_score NUMBER;
    v_max_amount NUMBER;
    v_eligibility_criteria VARCHAR2(4000);
    v_total_active_financing NUMBER := 0;
    v_min_score NUMBER := 0; -- قيمة افتراضية
BEGIN
    -- الحصول على تصنيف العميل الحالي
    v_rating := GET_CUSTOMER_RATING(p_customer_id);
    v_score := GET_CUSTOMER_RATING_SCORE(p_customer_id);
    
    -- إذا لم يكن للعميل تصنيف، قم بإنشاء تصنيف افتراضي
    IF v_rating IS NULL THEN
        INITIALIZE_CUSTOMER_RATING(p_customer_id);
        v_rating := GET_CUSTOMER_RATING(p_customer_id);
        v_score := GET_CUSTOMER_RATING_SCORE(p_customer_id);
    END IF;
    
    -- الحصول على معلومات المنتج
    SELECT MAX_FINANCING_AMOUNT, ELIGIBILITY_CRITERIA
    INTO v_max_amount, v_eligibility_criteria
    FROM ISLAMIC_PRODUCTS
    WHERE PRODUCT_ID = p_product_id;
    
    -- استخراج الحد الأدنى للتصنيف من معايير الأهلية (إذا كانت متاحة)
    -- هذا مجرد مثال، قد تحتاج إلى تعديله حسب كيفية تخزين معايير الأهلية
    IF v_eligibility_criteria LIKE '%MIN_CREDIT_SCORE%' THEN
        -- استخراج الحد الأدنى للتصنيف من النص
        -- هذا مثال بسيط، قد تحتاج إلى منطق أكثر تعقيدًا حسب تنسيق البيانات
        BEGIN
            v_min_score := TO_NUMBER(
                REGEXP_SUBSTR(v_eligibility_criteria, 'MIN_CREDIT_SCORE[:=]\s*(\d+)', 1, 1, 'i', 1)
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_min_score := 50; -- قيمة افتراضية إذا لم يتم العثور على قيمة
        END;
    ELSE
        -- تعيين قيمة افتراضية إذا لم يتم تحديد الحد الأدنى للتصنيف
        v_min_score := 50;
    END IF;
    
    -- الحصول على إجمالي التمويل النشط للعميل
    SELECT NVL(SUM(REMAINING_AMOUNT), 0)
    INTO v_total_active_financing
    FROM FINANCING_CONTRACTS
    WHERE CUSTOMER_ID = p_customer_id
    AND CONTRACT_STATUS = 'ACTIVE';
    
    -- التحقق من أهلية العميل
    RETURN (
        (v_score >= v_min_score) AND
        (p_amount <= v_max_amount) AND
        (v_total_active_financing + p_amount <= v_max_amount * 2) -- مثال على قاعدة: إجمالي التمويل لا يتجاوز ضعف الحد الأقصى للمنتج
    );
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN FALSE;
END IS_CUSTOMER_ELIGIBLE;

    -- دالة للحصول على سجل تصنيفات العميل
    FUNCTION GET_CUSTOMER_RATING_HISTORY(
        p_customer_id IN NUMBER
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                RATING_ID, CUSTOMER_ID, RATING_VALUE, RATING_SCORE,
                RATING_SOURCE, RATING_DATE, EXPIRY_DATE, NOTES,
                CREATED_BY, CREATION_DATE, LAST_UPDATED_BY, LAST_UPDATE_DATE
            FROM CUSTOMER_CREDIT_RATINGS
            WHERE CUSTOMER_ID = p_customer_id
            ORDER BY RATING_DATE DESC;
            
        RETURN v_cursor;
    END GET_CUSTOMER_RATING_HISTORY;
    
    -- إجراء لتحديث تصنيفات العملاء آليًا
    PROCEDURE AUTO_UPDATE_CUSTOMER_RATINGS IS
        CURSOR c_customers IS
            SELECT DISTINCT c.CUSTOMER_ID
            FROM CUSTOMERS c
            JOIN FINANCING_CONTRACTS fc ON c.CUSTOMER_ID = fc.CUSTOMER_ID
            WHERE fc.CONTRACT_STATUS IN ('ACTIVE', 'COMPLETED', 'DEFAULTED')
            AND (
                -- العملاء الذين ليس لديهم تصنيف
                NOT EXISTS (
                    SELECT 1 FROM CUSTOMER_CREDIT_RATINGS ccr
                    WHERE ccr.CUSTOMER_ID = c.CUSTOMER_ID
                )
                OR
                -- العملاء الذين مر على تصنيفهم أكثر من 6 أشهر
                EXISTS (
                    SELECT 1 FROM CUSTOMER_CREDIT_RATINGS ccr
                    WHERE ccr.CUSTOMER_ID = c.CUSTOMER_ID
                    AND ccr.RATING_DATE = (
                        SELECT MAX(RATING_DATE)
                        FROM CUSTOMER_CREDIT_RATINGS
                        WHERE CUSTOMER_ID = c.CUSTOMER_ID
                    )
                    AND ccr.RATING_DATE < ADD_MONTHS(SYSDATE, -6)
                )
            );
    BEGIN
        FOR r_customer IN c_customers LOOP
            BEGIN
                UPDATE_CUSTOMER_RATING(r_customer.CUSTOMER_ID);
            EXCEPTION
                WHEN OTHERS THEN
                    -- تسجيل الخطأ والاستمرار مع العميل التالي
                    NULL;
            END;
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END AUTO_UPDATE_CUSTOMER_RATINGS;
END PKG_CREDIT_RATING;
/


CREATE OR REPLACE PACKAGE BODY                PKG_CUSTOMERS AS
    
    -- إضافة عميل جديد
    PROCEDURE ADD_CUSTOMER(
        p_full_name IN VARCHAR2,
        p_national_id IN VARCHAR2,
        p_birth_date IN DATE,
        p_gender IN CHAR,
        p_marital_status IN VARCHAR2,
        p_address IN VARCHAR2,
        p_city IN VARCHAR2,
        p_postal_code IN VARCHAR2,
        p_email IN VARCHAR2,
        p_phone IN VARCHAR2,
        p_mobile IN VARCHAR2,
        p_employer_name IN VARCHAR2,
        p_job_title IN VARCHAR2,
        p_employment_date IN DATE,
        p_monthly_income IN NUMBER,
        p_other_income IN NUMBER,
        p_customer_id OUT NUMBER
    ) IS
        v_customer_exists NUMBER;
        v_notification_id NUMBER;
    BEGIN
        -- التحقق من عدم وجود العميل مسبقاً
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE NATIONAL_ID = p_national_id;
        
        IF v_customer_exists > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'العميل موجود مسبقاً برقم الهوية: ' || p_national_id);
        END IF;
        
        -- إنشاء معرف جديد للعميل
        SELECT SEQ_CUSTOMER_ID.NEXTVAL INTO p_customer_id FROM DUAL;
        
        -- إدراج بيانات العميل الجديد
        INSERT INTO CUSTOMERS (
            CUSTOMER_ID, FULL_NAME, NATIONAL_ID, DATE_OF_BIRTH, GENDER,
            MARITAL_STATUS, HOME_ADDRESS, CITY, POSTAL_CODE, EMAIL,
            PHONE, MOBILE_NUMBER, EMPLOYER_NAME, JOB_TITLE, EMPLOYMENT_DATE,
            MONTHLY_INCOME, ADDITIONAL_INCOME, CREATION_DATE, CUSTOMER_STATUS
        ) VALUES (
            p_customer_id, p_full_name, p_national_id, p_birth_date, p_gender,
            p_marital_status, p_address, p_city, p_postal_code, p_email,
            p_phone, p_mobile, p_employer_name, p_job_title, p_employment_date,
            p_monthly_income, p_other_income, SYSDATE, 'ACTIVE'
        );
        
        -- إنشاء سجل في جدول تفضيلات الاتصال
        INSERT INTO CUSTOMER_CONTACT_PREFERENCES (
            CUSTOMER_ID, CONTACT_METHOD, ALLOW_SMS, ALLOW_EMAIL, ALLOW_PHONE
        ) VALUES (
            p_customer_id, 'MOBILE', 'Y', 'Y', 'Y'
        );
        
        -- إضافة ملاحظة تلقائية
        INSERT INTO CUSTOMER_NOTES (
            NOTE_ID, CUSTOMER_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_NOTE_ID.NEXTVAL, p_customer_id, 'تم تسجيل العميل في النظام', 1, SYSDATE
        );
        
        -- استدعاء حزمة التصنيف الائتماني لإنشاء تصنيف أولي للعميل
        PKG_CREDIT_RATING.INITIALIZE_CUSTOMER_RATING(p_customer_id);
        
        COMMIT;
        
        -- إرسال إشعار بإضافة عميل جديد
        PKG_NOTIFICATIONS.SEND_SYSTEM_NOTIFICATION(
            p_notification_title => 'تم إضافة عميل جديد',
            p_notification_message => 'تم إضافة العميل ' || p_full_name || ' برقم ' || p_customer_id,
            p_notification_type => 'CUSTOMER',
          ---  p_related_id => p_customer_id,
            p_start_date => SYSDATE,
                p_end_date => ADD_MONTHS(SYSDATE, 1),
        p_target_users => NULL, -- لجميع المستخدمين
        p_target_roles => NULL, -- لجميع الأدوار
        p_created_by => 1,
        p_notification_id => v_notification_id
        );
        
        
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_CUSTOMER;
    
    -- تحديث بيانات العميل
    PROCEDURE UPDATE_CUSTOMER(
        p_customer_id IN NUMBER,
        p_full_name IN VARCHAR2 DEFAULT NULL,
        p_address IN VARCHAR2 DEFAULT NULL,
        p_city IN VARCHAR2 DEFAULT NULL,
        p_postal_code IN VARCHAR2 DEFAULT NULL,
        p_email IN VARCHAR2 DEFAULT NULL,
        p_phone IN VARCHAR2 DEFAULT NULL,
        p_mobile IN VARCHAR2 DEFAULT NULL,
        p_employer_name IN VARCHAR2 DEFAULT NULL,
        p_job_title IN VARCHAR2 DEFAULT NULL,
        p_employment_date IN DATE DEFAULT NULL,
        p_monthly_income IN NUMBER DEFAULT NULL,
        p_other_income IN NUMBER DEFAULT NULL,
        p_marital_status IN VARCHAR2 DEFAULT NULL
    ) IS
        v_customer_exists NUMBER;
        v_old_monthly_income NUMBER;
        v_income_changed BOOLEAN := FALSE;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- الحصول على الدخل الشهري الحالي للعميل
        IF p_monthly_income IS NOT NULL THEN
            SELECT MONTHLY_INCOME INTO v_old_monthly_income
            FROM CUSTOMERS
            WHERE CUSTOMER_ID = p_customer_id;
            
            IF v_old_monthly_income != p_monthly_income THEN
                v_income_changed := TRUE;
            END IF;
        END IF;
        
        -- تحديث بيانات العميل
        UPDATE CUSTOMERS
        SET
            FULL_NAME = COALESCE(p_full_name, FULL_NAME),
            HOME_ADDRESS = COALESCE(p_address, HOME_ADDRESS),
            CITY = COALESCE(p_city, CITY),
            POSTAL_CODE = COALESCE(p_postal_code, POSTAL_CODE),
            EMAIL = COALESCE(p_email, EMAIL),
            PHONE = COALESCE(p_phone, PHONE),
            MOBILE_NUMBER = COALESCE(p_mobile, MOBILE_NUMBER),
            EMPLOYER_NAME = COALESCE(p_employer_name, EMPLOYER_NAME),
            JOB_TITLE = COALESCE(p_job_title, JOB_TITLE),
            EMPLOYMENT_DATE = COALESCE(p_employment_date, EMPLOYMENT_DATE),
            MONTHLY_INCOME = COALESCE(p_monthly_income, MONTHLY_INCOME),
            ADDITIONAL_INCOME = COALESCE(p_other_income, ADDITIONAL_INCOME),
            MARITAL_STATUS = COALESCE(p_marital_status, MARITAL_STATUS),
            LAST_UPDATE_DATE = SYSDATE
        WHERE CUSTOMER_ID = p_customer_id;
        
        -- إذا تغير الدخل الشهري، قم بتحديث التصنيف الائتماني
        IF v_income_changed THEN
            PKG_CREDIT_RATING.UPDATE_CUSTOMER_RATING(p_customer_id);
        END IF;
        
        COMMIT;
        
        -- إضافة ملاحظة بالتحديث
        INSERT INTO CUSTOMER_NOTES (
            NOTE_ID, CUSTOMER_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_NOTE_ID.NEXTVAL, p_customer_id, 'تم تحديث بيانات العميل', 1, SYSDATE
        );
        
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_CUSTOMER;
    
    -- الحصول على بيانات العميل
    FUNCTION GET_CUSTOMER(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                c.*,
                TRUNC(MONTHS_BETWEEN(SYSDATE, c.DATE_OF_BIRTH) / 12) AS AGE,
                cr.RATING_SCORE,
                cr.RATING_VALUE,
                cr.RATING_DATE,
                (SELECT COUNT(*) FROM FINANCING_CONTRACTS fc WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID) AS FINANCING_COUNT,
                (SELECT SUM(FINANCING_AMOUNT) FROM FINANCING_CONTRACTS fc WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID) AS TOTAL_FINANCING_AMOUNT,
                (SELECT SUM(REMAINING_AMOUNT) FROM FINANCING_CONTRACTS fc WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID) AS TOTAL_REMAINING_AMOUNT,
                PKG_CUSTOMERS.CALCULATE_DTI_RATIO(c.CUSTOMER_ID) AS DTI_RATIO
            FROM 
                CUSTOMERS c
                LEFT JOIN CUSTOMER_CREDIT_RATINGS cr ON c.CUSTOMER_ID = cr.CUSTOMER_ID
            WHERE 
                c.CUSTOMER_ID = p_customer_id;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMER;
    
    -- البحث عن العملاء
    FUNCTION SEARCH_CUSTOMERS(
        p_name IN VARCHAR2 DEFAULT NULL,
        p_national_id IN VARCHAR2 DEFAULT NULL,
        p_city IN VARCHAR2 DEFAULT NULL,
        p_phone IN VARCHAR2 DEFAULT NULL,
        p_email IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                c.*,
                TRUNC(MONTHS_BETWEEN(SYSDATE, c.DATE_OF_BIRTH) / 12) AS AGE,
                cr.RATING_SCORE,
                cr.RATING_VALUE
            FROM 
                CUSTOMERS c
                LEFT JOIN CUSTOMER_CREDIT_RATINGS cr ON c.CUSTOMER_ID = cr.CUSTOMER_ID
            WHERE 
                (p_name IS NULL OR UPPER(c.FULL_NAME) LIKE UPPER('%' || p_name || '%'))
                AND (p_national_id IS NULL OR c.NATIONAL_ID LIKE '%' || p_national_id || '%')
                AND (p_city IS NULL OR UPPER(c.CITY) LIKE UPPER('%' || p_city || '%'))
                AND (p_phone IS NULL OR c.PHONE LIKE '%' || p_phone || '%' OR c.MOBILE_NUMBER LIKE '%' || p_phone || '%')
                AND (p_email IS NULL OR UPPER(c.EMAIL) LIKE UPPER('%' || p_email || '%'))
            ORDER BY 
                c.FULL_NAME;
        
        RETURN v_cursor;
    END SEARCH_CUSTOMERS;
    
    -- إضافة معلومات الدخل للعميل
    PROCEDURE ADD_INCOME_INFO(
        p_customer_id IN NUMBER,
        p_income_source IN VARCHAR2,
        p_income_amount IN NUMBER,
        p_income_frequency IN VARCHAR2,
        p_start_date IN DATE,
        p_end_date IN DATE DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_income_id OUT NUMBER
    ) IS
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- إنشاء معرف جديد للدخل
        SELECT SEQ_INCOME_ID.NEXTVAL INTO p_income_id FROM DUAL;
        
        -- إدراج بيانات الدخل
        INSERT INTO CUSTOMER_INCOME (
            INCOME_ID, CUSTOMER_ID, INCOME_SOURCE, INCOME_AMOUNT, INCOME_FREQUENCY,
            START_DATE, END_DATE, NOTES, CREATION_DATE
        ) VALUES (
            p_income_id, p_customer_id, p_income_source, p_income_amount, p_income_frequency,
            p_start_date, p_end_date, p_notes, SYSDATE
        );
        
        -- تحديث التصنيف الائتماني للعميل
        PKG_CREDIT_RATING.UPDATE_CUSTOMER_RATING(p_customer_id);
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_INCOME_INFO;
    
    -- تحديث معلومات الدخل للعميل
    PROCEDURE UPDATE_INCOME_INFO(
        p_income_id IN NUMBER,
        p_income_amount IN NUMBER DEFAULT NULL,
        p_income_frequency IN VARCHAR2 DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL
    ) IS
        v_customer_id NUMBER;
    BEGIN
        -- الحصول على معرف العميل
        SELECT CUSTOMER_ID INTO v_customer_id
        FROM CUSTOMER_INCOME
        WHERE INCOME_ID = p_income_id;
        
        -- تحديث بيانات الدخل
        UPDATE CUSTOMER_INCOME
        SET
            INCOME_AMOUNT = COALESCE(p_income_amount, INCOME_AMOUNT),
            INCOME_FREQUENCY = COALESCE(p_income_frequency, INCOME_FREQUENCY),
            END_DATE = COALESCE(p_end_date, END_DATE),
            NOTES = COALESCE(p_notes, NOTES),
            LAST_UPDATE_DATE = SYSDATE
        WHERE INCOME_ID = p_income_id;
        
        -- تحديث التصنيف الائتماني للعميل
        PKG_CREDIT_RATING.UPDATE_CUSTOMER_RATING(v_customer_id);
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20003, 'معلومات الدخل غير موجودة برقم: ' || p_income_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_INCOME_INFO;
    
    -- إضافة معلومات الالتزامات المالية للعميل
    PROCEDURE ADD_FINANCIAL_OBLIGATION(
        p_customer_id IN NUMBER,
        p_obligation_type IN VARCHAR2,
        p_creditor_name IN VARCHAR2,
        p_obligation_amount IN NUMBER,
        p_monthly_payment IN NUMBER,
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_obligation_id OUT NUMBER
    ) IS
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- إنشاء معرف جديد للالتزام المالي
        SELECT SEQ_OBLIGATION_ID.NEXTVAL INTO p_obligation_id FROM DUAL;
        
        -- إدراج بيانات الالتزام المالي
        INSERT INTO CUSTOMER_FINANCIAL_OBLIGATIONS (
            OBLIGATION_ID, CUSTOMER_ID, OBLIGATION_TYPE, CREDITOR_NAME,
            ORIGINAL_AMOUNT, MONTHLY_PAYMENT, START_DATE, END_DATE,
            NOTES, CREATION_DATE
        ) VALUES (
            p_obligation_id, p_customer_id, p_obligation_type, p_creditor_name,
            p_obligation_amount, p_monthly_payment, p_start_date, p_end_date,
            p_notes, SYSDATE
        );
        
        -- تحديث التصنيف الائتماني للعميل
        PKG_CREDIT_RATING.UPDATE_CUSTOMER_RATING(p_customer_id);
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_FINANCIAL_OBLIGATION;
    
    -- تحديث معلومات الالتزامات المالية للعميل
    PROCEDURE UPDATE_FINANCIAL_OBLIGATION(
        p_obligation_id IN NUMBER,
        p_obligation_amount IN NUMBER DEFAULT NULL,
        p_monthly_payment IN NUMBER DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL
    ) IS
        v_customer_id NUMBER;
    BEGIN
        -- الحصول على معرف العميل
        SELECT CUSTOMER_ID INTO v_customer_id
        FROM CUSTOMER_FINANCIAL_OBLIGATIONS
        WHERE OBLIGATION_ID = p_obligation_id;
        
        -- تحديث بيانات الالتزام المالي
        UPDATE CUSTOMER_FINANCIAL_OBLIGATIONS
        SET
            ORIGINAL_AMOUNT = COALESCE(p_obligation_amount, ORIGINAL_AMOUNT),
            MONTHLY_PAYMENT = COALESCE(p_monthly_payment, MONTHLY_PAYMENT),
            END_DATE = COALESCE(p_end_date, END_DATE),
            NOTES = COALESCE(p_notes, NOTES),
            LAST_UPDATE_DATE = SYSDATE
        WHERE OBLIGATION_ID = p_obligation_id;
        
        -- تحديث التصنيف الائتماني للعميل
        PKG_CREDIT_RATING.UPDATE_CUSTOMER_RATING(v_customer_id);
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20004, 'معلومات الالتزام المالي غير موجودة برقم: ' || p_obligation_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_FINANCIAL_OBLIGATION;
    
    -- الحصول على ملخص التمويلات للعميل
    FUNCTION GET_CUSTOMER_FINANCING_SUMMARY(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                fc.FINANCING_ID,
                fc.FINANCING_AMOUNT,
                fc.REMAINING_AMOUNT,
                fc.PROFIT_AMOUNT,
                fc.TOTAL_AMOUNT,
                fc.INSTALLMENT_COUNT,
                fc.INSTALLMENT_AMOUNT,
                fc.START_DATE,
                fc.END_DATE,
                fc.CONTRACT_STATUS,
                ip.PRODUCT_NAME,
                ip.PRODUCT_TYPE,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.REQUEST_ID = fc.REQUEST_ID AND ins.INSTALLMENT_STATUS = 'PAID') AS PAID_INSTALLMENTS,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.REQUEST_ID = fc.REQUEST_ID AND ins.INSTALLMENT_STATUS = 'OVERDUE') AS OVERDUE_INSTALLMENTS,
                (SELECT SUM(PAYMENT_AMOUNT) FROM PAYMENTS p WHERE p.FINANCING_ID = fc.FINANCING_ID) AS TOTAL_PAID_AMOUNT,
                (SELECT MAX(DUE_DATE) FROM INSTALLMENT_SCHEDULE ins WHERE ins.REQUEST_ID = fc.REQUEST_ID AND ins.INSTALLMENT_STATUS = 'UNPAID') AS NEXT_PAYMENT_DATE,
                (SELECT INSTALLMENT_AMOUNT FROM INSTALLMENT_SCHEDULE ins WHERE ins.REQUEST_ID = fc.REQUEST_ID AND ins.INSTALLMENT_STATUS = 'UNPAID' AND ROWNUM = 1) AS NEXT_PAYMENT_AMOUNT
            FROM 
                FINANCING_CONTRACTS fc
                JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
            WHERE 
                fc.CUSTOMER_ID = p_customer_id
            ORDER BY 
                fc.START_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMER_FINANCING_SUMMARY;
    
    -- الحصول على تاريخ المدفوعات للعميل
    FUNCTION GET_CUSTOMER_PAYMENT_HISTORY(
        p_customer_id IN NUMBER,
        p_start_date IN DATE DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_customer_exists NUMBER;
        v_start_date DATE := COALESCE(p_start_date, ADD_MONTHS(SYSDATE, -12));
        v_end_date DATE := COALESCE(p_end_date, SYSDATE);
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                p.PAYMENT_ID,
                p.FINANCING_ID,
                fc.FINANCING_AMOUNT,
                ip.PRODUCT_NAME,
                p.INSTALLMENT_ID,
                ins.CONTRACT_ID,
                p.PAYMENT_AMOUNT,
                p.PAYMENT_DATE,
                p.PAYMENT_METHOD,
                p.PAYMENT_STATUS,
                p.REFERENCE_NUMBER,
                ins.DUE_DATE,
                CASE 
                    WHEN p.PAYMENT_DATE <= ins.DUE_DATE THEN 'في الموعد'
                    ELSE 'متأخر'
                END AS PAYMENT_TIMING,
                CASE 
                    WHEN p.PAYMENT_DATE > ins.DUE_DATE THEN TRUNC(p.PAYMENT_DATE) - TRUNC(ins.DUE_DATE)
                    ELSE 0
                END AS DAYS_LATE
            FROM 
                PAYMENTS p
                JOIN FINANCING_CONTRACTS fc ON p.FINANCING_ID = fc.FINANCING_ID
                JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
                JOIN INSTALLMENT_SCHEDULE ins ON p.INSTALLMENT_ID = ins.INSTALLMENT_ID
            WHERE 
                fc.CUSTOMER_ID = p_customer_id
                AND p.PAYMENT_DATE BETWEEN v_start_date AND v_end_date
            ORDER BY 
                p.PAYMENT_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMER_PAYMENT_HISTORY;
    
    -- حساب نسبة الالتزامات إلى الدخل (DTI)
    FUNCTION CALCULATE_DTI_RATIO(p_customer_id IN NUMBER) RETURN NUMBER IS
        v_monthly_income NUMBER := 0;
        v_monthly_obligations NUMBER := 0;
        v_dti_ratio NUMBER := 0;
    BEGIN
        -- الحصول على الدخل الشهري للعميل
        SELECT NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0) INTO v_monthly_income
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        -- الحصول على مجموع الالتزامات الشهرية للعميل
        SELECT NVL(SUM(MONTHLY_PAYMENT), 0) INTO v_monthly_obligations
        FROM CUSTOMER_FINANCIAL_OBLIGATIONS
        WHERE CUSTOMER_ID = p_customer_id
        AND (END_DATE IS NULL OR END_DATE > SYSDATE);
        
        -- إضافة الأقساط الشهرية للتمويلات النشطة
        SELECT NVL(v_monthly_obligations, 0) + NVL(SUM(INSTALLMENT_AMOUNT), 0) INTO v_monthly_obligations
        FROM FINANCING_CONTRACTS
        WHERE CUSTOMER_ID = p_customer_id
        AND CONTRACT_STATUS = 'ACTIVE';
        
        -- حساب نسبة الالتزامات إلى الدخل
        IF v_monthly_income > 0 THEN
            v_dti_ratio := (v_monthly_obligations / v_monthly_income) * 100;
        ELSE
            v_dti_ratio := 0;
        END IF;
        
        RETURN ROUND(v_dti_ratio, 2);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
        WHEN OTHERS THEN
            RAISE;
    END CALCULATE_DTI_RATIO;
    
    /*
    -- إضافة معلومات الحساب البنكي للعميل
    PROCEDURE ADD_BANK_ACCOUNT(
        p_customer_id IN NUMBER,
        p_bank_name IN VARCHAR2,
        p_account_number IN VARCHAR2,
        p_iban IN VARCHAR2,
        p_account_type IN VARCHAR2,
        p_branch_name IN VARCHAR2 DEFAULT NULL,
        p_swift_code IN VARCHAR2 DEFAULT NULL,
        p_is_primary IN CHAR DEFAULT 'N',
        p_account_id OUT NUMBER
    ) IS
        v_customer_exists NUMBER;
        v_account_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- التحقق من عدم وجود حساب بنفس الرقم أو IBAN
        SELECT COUNT(*) INTO v_account_exists
        FROM CUSTOMER_BANK_ACCOUNTS
        WHERE (ACCOUNT_NUMBER = p_account_number OR IBAN = p_iban)
        AND CUSTOMER_ID = p_customer_id;
        
        IF v_account_exists > 0 THEN
            RAISE_APPLICATION_ERROR(-20005, 'الحساب البنكي موجود مسبقاً لهذا العميل');
        END IF;
        
        -- إنشاء معرف جديد للحساب البنكي
        SELECT SEQ_ACCOUNT_ID.NEXTVAL INTO p_account_id FROM DUAL;
        
        -- إذا كان الحساب الجديد هو الحساب الرئيسي، قم بإلغاء تعيين الحساب الرئيسي السابق
        IF p_is_primary = 'Y' THEN
            UPDATE CUSTOMER_BANK_ACCOUNTS
            SET IS_PRIMARY = 'N'
            WHERE CUSTOMER_ID = p_customer_id
            AND IS_PRIMARY = 'Y';
        END IF;
        
        -- إدراج بيانات الحساب البنكي
        INSERT INTO CUSTOMER_BANK_ACCOUNTS (
            ACCOUNT_ID, CUSTOMER_ID, BANK_NAME, ACCOUNT_NUMBER, IBAN,
            ACCOUNT_TYPE, BRANCH_NAME, SWIFT_CODE, IS_PRIMARY, CREATION_DATE
        ) VALUES (
            p_account_id, p_customer_id, p_bank_name, p_account_number, p_iban,
            p_account_type, p_branch_name, p_swift_code, p_is_primary, SYSDATE
        );
        
        -- إذا لم يكن هناك حساب رئيسي وهذا هو الحساب الأول، اجعله الحساب الرئيسي
        IF p_is_primary = 'N' THEN
            DECLARE
                v_primary_count NUMBER;
            BEGIN
                SELECT COUNT(*) INTO v_primary_count
                FROM CUSTOMER_BANK_ACCOUNTS
                WHERE CUSTOMER_ID = p_customer_id
                AND IS_PRIMARY = 'Y';
                
                IF v_primary_count = 0 THEN
                    UPDATE CUSTOMER_BANK_ACCOUNTS
                    SET IS_PRIMARY = 'Y'
                    WHERE ACCOUNT_ID = p_account_id;
                END IF;
            END;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_BANK_ACCOUNT;
    */
    /*
    -- تحديث معلومات الحساب البنكي للعميل
    PROCEDURE UPDATE_BANK_ACCOUNT(
        p_account_id IN NUMBER,
        p_bank_name IN VARCHAR2 DEFAULT NULL,
        p_account_number IN VARCHAR2 DEFAULT NULL,
        p_iban IN VARCHAR2 DEFAULT NULL,
        p_account_type IN VARCHAR2 DEFAULT NULL,
        p_branch_name IN VARCHAR2 DEFAULT NULL,
        p_swift_code IN VARCHAR2 DEFAULT NULL,
        p_is_primary IN CHAR DEFAULT NULL
    ) IS
        v_customer_id NUMBER;
        v_account_exists NUMBER;
        v_current_is_primary CHAR(1);
    BEGIN
        -- الحصول على معرف العميل والحالة الحالية للحساب الرئيسي
        SELECT CUSTOMER_ID, IS_PRIMARY INTO v_customer_id, v_current_is_primary
        FROM CUSTOMER_BANK_ACCOUNTS
        WHERE ACCOUNT_ID = p_account_id;
        
        -- التحقق من عدم وجود حساب آخر بنفس الرقم أو IBAN
        IF p_account_number IS NOT NULL OR p_iban IS NOT NULL THEN
            SELECT COUNT(*) INTO v_account_exists
            FROM CUSTOMER_BANK_ACCOUNTS
            WHERE (
                (p_account_number IS NOT NULL AND ACCOUNT_NUMBER = p_account_number) OR
                (p_iban IS NOT NULL AND IBAN = p_iban)
            )
            AND CUSTOMER_ID = v_customer_id
            AND ACCOUNT_ID != p_account_id;
            
            IF v_account_exists > 0 THEN
                RAISE_APPLICATION_ERROR(-20005, 'الحساب البنكي موجود مسبقاً لهذا العميل');
            END IF;
        END IF;
        
        -- إذا كان الحساب سيصبح الحساب الرئيسي، قم بإلغاء تعيين الحساب الرئيسي السابق
        IF p_is_primary = 'Y' AND v_current_is_primary = 'N' THEN
            UPDATE CUSTOMER_BANK_ACCOUNTS
            SET IS_PRIMARY = 'N'
            WHERE CUSTOMER_ID = v_customer_id
            AND IS_PRIMARY = 'Y';
        END IF;
        
        -- تحديث بيانات الحساب البنكي
        UPDATE CUSTOMER_BANK_ACCOUNTS
        SET
            BANK_NAME = COALESCE(p_bank_name, BANK_NAME),
            ACCOUNT_NUMBER = COALESCE(p_account_number, ACCOUNT_NUMBER),
            IBAN = COALESCE(p_iban, IBAN),
            ACCOUNT_TYPE = COALESCE(p_account_type, ACCOUNT_TYPE),
            BRANCH_NAME = COALESCE(p_branch_name, BRANCH_NAME),
            SWIFT_CODE = COALESCE(p_swift_code, SWIFT_CODE),
            IS_PRIMARY = COALESCE(p_is_primary, IS_PRIMARY),
            LAST_UPDATE_DATE = SYSDATE
        WHERE ACCOUNT_ID = p_account_id;
        
        -- إذا تم إلغاء تعيين الحساب الرئيسي، تأكد من وجود حساب رئيسي آخر
        IF p_is_primary = 'N' AND v_current_is_primary = 'Y' THEN
            DECLARE
                v_primary_count NUMBER;
                v_other_account_id NUMBER;
            BEGIN
                SELECT COUNT(*) INTO v_primary_count
                FROM CUSTOMER_BANK_ACCOUNTS
                WHERE CUSTOMER_ID = v_customer_id
                AND IS_PRIMARY = 'Y';
                
                IF v_primary_count = 0 THEN
                    -- اختر حساب آخر ليكون الحساب الرئيسي
                    SELECT MIN(ACCOUNT_ID) INTO v_other_account_id
                    FROM CUSTOMER_BANK_ACCOUNTS
                    WHERE CUSTOMER_ID = v_customer_id
                    AND ACCOUNT_ID != p_account_id;
                    
                    IF v_other_account_id IS NOT NULL THEN
                        UPDATE CUSTOMER_BANK_ACCOUNTS
                        SET IS_PRIMARY = 'Y'
                        WHERE ACCOUNT_ID = v_other_account_id;
                    END IF;
                END IF;
            END;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20006, 'الحساب البنكي غير موجود برقم: ' || p_account_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_BANK_ACCOUNT;
    */
    -- إضافة جهة اتصال للطوارئ
    PROCEDURE ADD_EMERGENCY_CONTACT(
        p_customer_id IN NUMBER,
        p_contact_name IN VARCHAR2,
        p_relationship IN VARCHAR2,
        p_phone IN VARCHAR2,
        p_mobile IN VARCHAR2,
        p_email IN VARCHAR2 DEFAULT NULL,
        p_address IN VARCHAR2 DEFAULT NULL,
        p_contact_id OUT NUMBER
    ) IS
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- إنشاء معرف جديد لجهة الاتصال
        SELECT SEQ_CONTACT_ID.NEXTVAL INTO p_contact_id FROM DUAL;
        
        -- إدراج بيانات جهة الاتصال
        INSERT INTO CUSTOMER_EMERGENCY_CONTACTS (
            CONTACT_ID, CUSTOMER_ID, CONTACT_NAME, RELATIONSHIP,
            PHONE, MOBILE, EMAIL, ADDRESS, CREATION_DATE
        ) VALUES (
            p_contact_id, p_customer_id, p_contact_name, p_relationship,
            p_phone, p_mobile, p_email, p_address, SYSDATE
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_EMERGENCY_CONTACT;
    
    -- تحديث جهة اتصال للطوارئ
    PROCEDURE UPDATE_EMERGENCY_CONTACT(
        p_contact_id IN NUMBER,
        p_contact_name IN VARCHAR2 DEFAULT NULL,
        p_relationship IN VARCHAR2 DEFAULT NULL,
        p_phone IN VARCHAR2 DEFAULT NULL,
        p_mobile IN VARCHAR2 DEFAULT NULL,
        p_email IN VARCHAR2 DEFAULT NULL,
        p_address IN VARCHAR2 DEFAULT NULL
    ) IS
    BEGIN
        -- تحديث بيانات جهة الاتصال
        UPDATE CUSTOMER_EMERGENCY_CONTACTS
        SET
            CONTACT_NAME = COALESCE(p_contact_name, CONTACT_NAME),
            RELATIONSHIP = COALESCE(p_relationship, RELATIONSHIP),
            PHONE = COALESCE(p_phone, PHONE),
            MOBILE = COALESCE(p_mobile, MOBILE),
            EMAIL = COALESCE(p_email, EMAIL),
            ADDRESS = COALESCE(p_address, ADDRESS),
            LAST_UPDATED_DATE = SYSDATE
        WHERE CONTACT_ID = p_contact_id;
        
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20007, 'جهة الاتصال غير موجودة برقم: ' || p_contact_id);
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_EMERGENCY_CONTACT;
    
    -- تحديث حالة العميل
    PROCEDURE UPDATE_CUSTOMER_STATUS(
        p_customer_id IN NUMBER,
        p_status IN VARCHAR2,
        p_reason IN VARCHAR2 DEFAULT NULL
    ) IS
        v_old_status VARCHAR2(50);
        v_notification_id NUMBER;
    BEGIN
        -- الحصول على الحالة الحالية للعميل
        SELECT CUSTOMER_STATUS INTO v_old_status
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        -- تحديث حالة العميل
        UPDATE CUSTOMERS
        SET
            CUSTOMER_STATUS = p_status,
            LAST_UPDATE_DATE = SYSDATE
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- إضافة سجل لتغيير الحالة
        INSERT INTO CUSTOMER_STATUS_HISTORY (
            HISTORY_ID, CUSTOMER_ID, OLD_STATUS, NEW_STATUS,
            CHANGE_REASON, CHANGE_DATE, CHANGED_BY
        ) VALUES (
            SEQ_STATUS_HISTORY_ID.NEXTVAL, p_customer_id, v_old_status, p_status,
            p_reason, SYSDATE, 1 -- يمكن تغيير معرف المستخدم حسب المستخدم الحالي
        );
        
        -- إذا تم تعطيل العميل، قم بإرسال إشعار للإدارة
        IF p_status = 'INACTIVE' OR p_status = 'BLOCKED' THEN
            DECLARE
                v_customer_name VARCHAR2(200);
            BEGIN
                SELECT FULL_NAME INTO v_customer_name
                FROM CUSTOMERS
                WHERE CUSTOMER_ID = p_customer_id;
                
                PKG_NOTIFICATIONS.SEND_SYSTEM_NOTIFICATION(
                    p_notification_title => 'تغيير حالة العميل',
                    p_notification_message => 'تم تغيير حالة العميل ' || v_customer_name || ' إلى ' || p_status || 
                                 CASE WHEN p_reason IS NOT NULL THEN ' بسبب: ' || p_reason ELSE '' END,
                    p_notification_type => 'CUSTOMER',
                    p_start_date => SYSDATE,
                p_end_date => ADD_MONTHS(SYSDATE, 1),
        p_target_users => NULL, -- لجميع المستخدمين
        p_target_roles => NULL, -- لجميع الأدوار
        p_created_by => 1,
        p_notification_id => v_notification_id
                );
        
            END;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_CUSTOMER_STATUS;
    
    -- الحصول على تقرير ائتماني للعميل
    FUNCTION GET_CUSTOMER_CREDIT_REPORT(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        OPEN v_cursor FOR
            WITH PAYMENT_STATS AS (
                SELECT 
                    fc.FINANCING_ID,
                    COUNT(ins.INSTALLMENT_ID) AS TOTAL_INSTALLMENTS,
                    SUM(CASE WHEN ins.INSTALLMENT_STATUS = 'PAID' THEN 1 ELSE 0 END) AS PAID_INSTALLMENTS,
                    SUM(CASE WHEN ins.INSTALLMENT_STATUS = 'OVERDUE' THEN 1 ELSE 0 END) AS OVERDUE_INSTALLMENTS,
                    SUM(CASE WHEN p.PAYMENT_DATE > ins.DUE_DATE AND ins.INSTALLMENT_STATUS = 'PAID' THEN 1 ELSE 0 END) AS LATE_PAYMENTS,
                    MAX(CASE WHEN p.PAYMENT_DATE > ins.DUE_DATE THEN TRUNC(p.PAYMENT_DATE) - TRUNC(ins.DUE_DATE) ELSE 0 END) AS MAX_DAYS_LATE
                FROM 
                    FINANCING_CONTRACTS fc
                    JOIN INSTALLMENT_SCHEDULE ins ON fc.REQUEST_ID = ins.REQUEST_ID
                    LEFT JOIN PAYMENTS p ON ins.INSTALLMENT_ID = p.INSTALLMENT_ID
                WHERE 
                    fc.CUSTOMER_ID = p_customer_id
                GROUP BY 
                    fc.FINANCING_ID
            )
            SELECT 
                c.CUSTOMER_ID,
                c.FULL_NAME,
                c.NATIONAL_ID,
                c.DATE_OF_BIRTH,
                c.GENDER,
                c.MARITAL_STATUS,
                c.MONTHLY_INCOME,
                c.ADDITIONAL_INCOME,
                cr.RATING_SCORE,
                cr.RATING_VALUE,
                cr.RATING_DATE,
                PKG_CUSTOMERS.CALCULATE_DTI_RATIO(c.CUSTOMER_ID) AS DTI_RATIO,
                (SELECT COUNT(*) FROM FINANCING_CONTRACTS fc WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID) AS TOTAL_FINANCINGS,
                (SELECT COUNT(*) FROM FINANCING_CONTRACTS fc WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID AND fc.CONTRACT_STATUS = 'ACTIVE') AS ACTIVE_FINANCINGS,
                (SELECT SUM(FINANCING_AMOUNT) FROM FINANCING_CONTRACTS fc WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID) AS TOTAL_FINANCING_AMOUNT,
                (SELECT SUM(REMAINING_AMOUNT) FROM FINANCING_CONTRACTS fc WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID) AS TOTAL_REMAINING_AMOUNT,
                (SELECT COUNT(*) FROM PAYMENTS p JOIN FINANCING_CONTRACTS fc ON p.FINANCING_ID = fc.FINANCING_ID WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID) AS TOTAL_PAYMENTS,
                (SELECT SUM(ps.OVERDUE_INSTALLMENTS) FROM PAYMENT_STATS ps) AS TOTAL_OVERDUE_INSTALLMENTS,
                (SELECT SUM(ps.LATE_PAYMENTS) FROM PAYMENT_STATS ps) AS TOTAL_LATE_PAYMENTS,
                (SELECT MAX(ps.MAX_DAYS_LATE) FROM PAYMENT_STATS ps) AS MAX_DAYS_LATE,
                (SELECT COUNT(*) FROM CUSTOMER_FINANCIAL_OBLIGATIONS cfo WHERE cfo.CUSTOMER_ID = c.CUSTOMER_ID AND (cfo.END_DATE IS NULL OR cfo.END_DATE > SYSDATE)) AS ACTIVE_OBLIGATIONS,
                (SELECT SUM(ORIGINAL_AMOUNT) FROM CUSTOMER_FINANCIAL_OBLIGATIONS cfo WHERE cfo.CUSTOMER_ID = c.CUSTOMER_ID AND (cfo.END_DATE IS NULL OR cfo.END_DATE > SYSDATE)) AS TOTAL_OBLIGATION_AMOUNT,
                (SELECT SUM(MONTHLY_PAYMENT) FROM CUSTOMER_FINANCIAL_OBLIGATIONS cfo WHERE cfo.CUSTOMER_ID = c.CUSTOMER_ID AND (cfo.END_DATE IS NULL OR cfo.END_DATE > SYSDATE)) AS TOTAL_MONTHLY_OBLIGATION
            FROM 
                CUSTOMERS c
                LEFT JOIN CUSTOMER_CREDIT_RATINGS cr ON c.CUSTOMER_ID = cr.CUSTOMER_ID
            WHERE 
                c.CUSTOMER_ID = p_customer_id;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMER_CREDIT_REPORT;
    
    -- إضافة ملاحظة للعميل
    PROCEDURE ADD_CUSTOMER_NOTE(
        p_customer_id IN NUMBER,
        p_note_text IN VARCHAR2,
        p_created_by IN NUMBER,
        p_note_id OUT NUMBER
    ) IS
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- إنشاء معرف جديد للملاحظة
        SELECT SEQ_NOTE_ID.NEXTVAL INTO p_note_id FROM DUAL;
        
        -- إدراج الملاحظة
        INSERT INTO CUSTOMER_NOTES (
            NOTE_ID, CUSTOMER_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
        ) VALUES (
            p_note_id, p_customer_id, p_note_text, p_created_by, SYSDATE
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_CUSTOMER_NOTE;
    
    -- الحصول على ملاحظات العميل
    FUNCTION GET_CUSTOMER_NOTES(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                n.NOTE_ID,
                n.CUSTOMER_ID,
                n.NOTE_TEXT,
                n.CREATED_BY,
                u.USERNAME AS CREATED_BY_NAME,
                n.CREATION_DATE
            FROM 
                CUSTOMER_NOTES n
                LEFT JOIN USERS u ON n.CREATED_BY = u.USER_ID
            WHERE 
                n.CUSTOMER_ID = p_customer_id
            ORDER BY 
                n.CREATION_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMER_NOTES;
    
    -- تحديث تفضيلات الاتصال للعميل
    PROCEDURE UPDATE_CONTACT_PREFERENCES(
        p_customer_id IN NUMBER,
        p_preferred_contact_method IN VARCHAR2,
        p_allow_sms IN CHAR DEFAULT 'Y',
        p_allow_email IN CHAR DEFAULT 'Y',
        p_allow_phone IN CHAR DEFAULT 'Y'
    ) IS
        v_customer_exists NUMBER;
        v_preferences_exist NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- التحقق من وجود تفضيلات الاتصال للعميل
        SELECT COUNT(*) INTO v_preferences_exist
        FROM CUSTOMER_CONTACT_PREFERENCES
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_preferences_exist > 0 THEN
            -- تحديث تفضيلات الاتصال
            UPDATE CUSTOMER_CONTACT_PREFERENCES
            SET
                CONTACT_METHOD = p_preferred_contact_method,
                ALLOW_SMS = p_allow_sms,
                ALLOW_EMAIL = p_allow_email,
                ALLOW_PHONE = p_allow_phone,
                UPDATE_DATE = SYSDATE
            WHERE CUSTOMER_ID = p_customer_id;
        ELSE
            -- إنشاء تفضيلات اتصال جديدة
            INSERT INTO CUSTOMER_CONTACT_PREFERENCES (
                PREFERENCE_ID, CUSTOMER_ID, CONTACT_METHOD,
                ALLOW_SMS, ALLOW_EMAIL, ALLOW_PHONE, CREATION_DATE
            ) VALUES (
                SEQ_PREFERENCE_ID.NEXTVAL, p_customer_id, p_preferred_contact_method,
                p_allow_sms, p_allow_email, p_allow_phone, SYSDATE
            );
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_CONTACT_PREFERENCES;
    
    -- الحصول على تفضيلات الاتصال للعميل
    FUNCTION GET_CONTACT_PREFERENCES(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                PREFERENCE_ID,
                CUSTOMER_ID,
                CONTACT_METHOD,
                ALLOW_SMS,
                ALLOW_EMAIL,
                ALLOW_PHONE,
                CREATION_DATE,
                UPDATE_DATE
            FROM 
                CUSTOMER_CONTACT_PREFERENCES
            WHERE 
                CUSTOMER_ID = p_customer_id;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CONTACT_PREFERENCES;
    
    -- التحقق من وجود العميل
    FUNCTION CUSTOMER_EXISTS(
        p_national_id IN VARCHAR2
    ) RETURN BOOLEAN IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM CUSTOMERS
        WHERE NATIONAL_ID = p_national_id;
        
        RETURN (v_count > 0);
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END CUSTOMER_EXISTS;
    
    -- الحصول على عدد العملاء حسب المدينة
    FUNCTION GET_CUSTOMERS_BY_CITY RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                CITY,
                COUNT(*) AS CUSTOMER_COUNT
            FROM 
                CUSTOMERS
            GROUP BY 
                CITY
            ORDER BY 
                COUNT(*) DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMERS_BY_CITY;
    
    -- الحصول على عدد العملاء حسب الفئة العمرية
    FUNCTION GET_CUSTOMERS_BY_AGE_GROUP RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                CASE 
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) < 18 THEN 'أقل من 18'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 18 AND 25 THEN '18-25'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 26 AND 35 THEN '26-35'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 36 AND 45 THEN '36-45'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 46 AND 55 THEN '46-55'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 56 AND 65 THEN '56-65'
                    ELSE 'أكبر من 65'
                END AS AGE_GROUP,
                COUNT(*) AS CUSTOMER_COUNT
            FROM 
                CUSTOMERS
            GROUP BY 
                CASE 
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) < 18 THEN 'أقل من 18'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 18 AND 25 THEN '18-25'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 26 AND 35 THEN '26-35'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 36 AND 45 THEN '36-45'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 46 AND 55 THEN '46-55'
                    WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_OF_BIRTH) / 12) BETWEEN 56 AND 65 THEN '56-65'
                    ELSE 'أكبر من 65'
                END
            ORDER BY 
                CASE AGE_GROUP
                    WHEN 'أقل من 18' THEN 1
                    WHEN '18-25' THEN 2
                    WHEN '26-35' THEN 3
                    WHEN '36-45' THEN 4
                    WHEN '46-55' THEN 5
                    WHEN '56-65' THEN 6
                    WHEN 'أكبر من 65' THEN 7
                END;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMERS_BY_AGE_GROUP;
    
    -- الحصول على عدد العملاء حسب فئة الدخل
    FUNCTION GET_CUSTOMERS_BY_INCOME_RANGE RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                CASE 
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) < 5000 THEN 'أقل من 5,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 5000 AND 10000 THEN '5,000 - 10,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 10001 AND 15000 THEN '10,001 - 15,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 15001 AND 20000 THEN '15,001 - 20,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 20001 AND 30000 THEN '20,001 - 30,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 30001 AND 50000 THEN '30,001 - 50,000'
                    ELSE 'أكثر من 50,000'
                END AS INCOME_RANGE,
                COUNT(*) AS CUSTOMER_COUNT
            FROM 
                CUSTOMERS
            GROUP BY 
                CASE 
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) < 5000 THEN 'أقل من 5,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 5000 AND 10000 THEN '5,000 - 10,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 10001 AND 15000 THEN '10,001 - 15,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 15001 AND 20000 THEN '15,001 - 20,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 20001 AND 30000 THEN '20,001 - 30,000'
                    WHEN (NVL(MONTHLY_INCOME, 0) + NVL(ADDITIONAL_INCOME, 0)) BETWEEN 30001 AND 50000 THEN '30,001 - 50,000'
                    ELSE 'أكثر من 50,000'
                END
            ORDER BY 
                CASE INCOME_RANGE
                    WHEN 'أقل من 5,000' THEN 1
                    WHEN '5,000 - 10,000' THEN 2
                    WHEN '10,001 - 15,000' THEN 3
                    WHEN '15,001 - 20,000' THEN 4
                    WHEN '20,001 - 30,000' THEN 5
                    WHEN '30,001 - 50,000' THEN 6
                    WHEN 'أكثر من 50,000' THEN 7
                END;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMERS_BY_INCOME_RANGE;
    
END PKG_CUSTOMERS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_DEBT_CLASSIFICATION AS
    -- إضافة تصنيف دين جديد
    PROCEDURE ADD_DEBT_CLASSIFICATION(
        p_classification_name IN VARCHAR2,
        p_min_days_past_due IN NUMBER,
        p_max_days_past_due IN NUMBER,
        p_provision_percentage IN NUMBER,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_classification_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_CLASSIFICATION_ID.NEXTVAL INTO p_classification_id FROM DUAL;
        
        INSERT INTO DEBT_CLASSIFICATIONS (
            CLASSIFICATION_ID, CLASSIFICATION_NAME, DAYS_OVERDUE_MIN,
            DAYS_OVERDUE_MAX, PROVISION_PERCENTAGE, DESCRIPTION,
            CREATION_DATE, CREATED_BY
        ) VALUES (
            p_classification_id, p_classification_name, p_min_days_past_due,
            p_max_days_past_due, p_provision_percentage, p_description,
            SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_DEBT_CLASSIFICATION;
    
    -- حساب المخصصات للطلب
    PROCEDURE CALCULATE_PROVISIONS(
        p_request_id IN NUMBER,
        p_calculation_date IN DATE,
        p_created_by IN VARCHAR2
    ) IS
        v_classification_id NUMBER;
        v_provision_percentage NUMBER;
        v_outstanding_amount NUMBER := 0;
        v_provision_amount NUMBER := 0;
        v_max_days_past_due NUMBER := 0;
        v_provision_id NUMBER;
    BEGIN
        -- حساب المبلغ المستحق وأقصى عدد أيام تأخير
        SELECT NVL(SUM(PRINCIPAL_AMOUNT + PROFIT_AMOUNT - NVL(PAID_AMOUNT, 0)), 0),
               NVL(MAX(p_calculation_date - DUE_DATE), 0)
        INTO v_outstanding_amount, v_max_days_past_due
        FROM INSTALLMENT_SCHEDULE
        WHERE REQUEST_ID = p_request_id
        AND INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED')
        AND DUE_DATE <= p_calculation_date;
        
        -- تحديد تصنيف الدين بناءً على عدد أيام التأخير
        SELECT CLASSIFICATION_ID, PROVISION_PERCENTAGE
        INTO v_classification_id, v_provision_percentage
        FROM DEBT_CLASSIFICATIONS
        WHERE v_max_days_past_due BETWEEN NVL(DAYS_OVERDUE_MIN, 0) AND NVL(DAYS_OVERDUE_MAX, 999999)
        ORDER BY DAYS_OVERDUE_MIN DESC
        FETCH FIRST 1 ROW ONLY;
        
        -- حساب مبلغ المخصص
        v_provision_amount := v_outstanding_amount * (v_provision_percentage / 100);
        
        -- حذف المخصصات السابقة للطلب
        DELETE FROM PROVISIONS
        WHERE REQUEST_ID = p_request_id;
        
        -- إضافة المخصص الجديد
        SELECT SEQ_PROVISION_ID.NEXTVAL INTO v_provision_id FROM DUAL;
        
        INSERT INTO PROVISIONS (
            PROVISION_ID, REQUEST_ID, CLASSIFICATION_ID, PROVISION_AMOUNT,
            CALCULATION_DATE, CREATED_DATE, CREATED_BY
        ) VALUES (
            v_provision_id, p_request_id, v_classification_id, v_provision_amount,
            p_calculation_date, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CALCULATE_PROVISIONS;
    
    -- حساب المخصصات لجميع الطلبات
    PROCEDURE CALCULATE_ALL_PROVISIONS(
        p_calculation_date IN DATE,
        p_created_by IN VARCHAR2
    ) IS
        CURSOR c_requests IS
            SELECT REQUEST_ID
            FROM FINANCING_REQUESTS
            WHERE REQUEST_STATUS IN ('DISBURSED', 'ACTIVE');
    BEGIN
        FOR r IN c_requests LOOP
            CALCULATE_PROVISIONS(r.REQUEST_ID, p_calculation_date, p_created_by);
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CALCULATE_ALL_PROVISIONS;
    
    -- الحصول على تصنيفات الديون
    FUNCTION GET_DEBT_CLASSIFICATIONS RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT *
            FROM DEBT_CLASSIFICATIONS
            ORDER BY DAYS_OVERDUE_MIN;
        RETURN v_cursor;
    END GET_DEBT_CLASSIFICATIONS;
    
    -- الحصول على مخصصات الطلب
    FUNCTION GET_REQUEST_PROVISIONS(p_request_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT p.*, dc.CLASSIFICATION_NAME, dc.PROVISION_PERCENTAGE
            FROM PROVISIONS p
            JOIN DEBT_CLASSIFICATIONS dc ON p.CLASSIFICATION_ID = dc.CLASSIFICATION_ID
            WHERE p.REQUEST_ID = p_request_id
            ORDER BY p.CALCULATION_DATE DESC;
        RETURN v_cursor;
    END GET_REQUEST_PROVISIONS;
    
    -- الحصول على تقرير المخصصات
    FUNCTION GET_PROVISIONS_REPORT RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT p.*, dc.CLASSIFICATION_NAME, dc.PROVISION_PERCENTAGE,
                   r.CUSTOMER_ID, c.FULL_NAME AS CUSTOMER_NAME, ip.PRODUCT_NAME
            FROM PROVISIONS p
            JOIN DEBT_CLASSIFICATIONS dc ON p.CLASSIFICATION_ID = dc.CLASSIFICATION_ID
            JOIN FINANCING_REQUESTS r ON p.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            JOIN ISLAMIC_PRODUCTS ip ON r.PRODUCT_ID = ip.PRODUCT_ID
            ORDER BY dc.DAYS_OVERDUE_MIN DESC, c.FULL_NAME;
        RETURN v_cursor;
    END GET_PROVISIONS_REPORT;
END PKG_DEBT_CLASSIFICATION;
/


CREATE OR REPLACE PACKAGE BODY                PKG_DOCUMENTS AS
    -- إضافة مستند للعميل
    PROCEDURE ADD_CUSTOMER_DOCUMENT(
        p_customer_id IN NUMBER,
        p_document_type IN VARCHAR2,
        p_document_number IN VARCHAR2,
        p_issue_date IN DATE,
        p_expiry_date IN DATE,
        p_document_path IN VARCHAR2,
        p_created_by IN VARCHAR2,
        p_document_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_DOCUMENT_ID.NEXTVAL INTO p_document_id FROM DUAL;
        
        INSERT INTO CUSTOMER_DOCUMENTS (
            DOCUMENT_ID, CUSTOMER_ID, DOCUMENT_TYPE, DOCUMENT_NUMBER,
            ISSUE_DATE, EXPIRY_DATE, DOCUMENT_PATH, DOCUMENT_STATUS,
            CREATED_DATE, CREATED_BY
        ) VALUES (
            p_document_id, p_customer_id, p_document_type, p_document_number,
            p_issue_date, p_expiry_date, p_document_path, 'ACTIVE',
            SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_CUSTOMER_DOCUMENT;
    
    -- إضافة مستند للطلب
    PROCEDURE ADD_REQUEST_DOCUMENT(
        p_request_id IN NUMBER,
        p_document_type IN VARCHAR2,
        p_document_number IN VARCHAR2,
        p_issue_date IN DATE,
        p_expiry_date IN DATE,
        p_document_path IN VARCHAR2,
        p_created_by IN VARCHAR2,
        p_document_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_DOCUMENT_ID.NEXTVAL INTO p_document_id FROM DUAL;
        
        INSERT INTO REQUEST_DOCUMENTS (
            DOCUMENT_ID, REQUEST_ID, DOCUMENT_TYPE, DOCUMENT_NUMBER,
            ISSUE_DATE, EXPIRY_DATE, DOCUMENT_PATH, DOCUMENT_STATUS,
            CREATED_DATE, CREATED_BY
        ) VALUES (
            p_document_id, p_request_id, p_document_type, p_document_number,
            p_issue_date, p_expiry_date, p_document_path, 'ACTIVE',
            SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_REQUEST_DOCUMENT;
    
    -- تحديث حالة المستند
    PROCEDURE UPDATE_DOCUMENT_STATUS(
        p_document_id IN NUMBER,
        p_document_status IN VARCHAR2,
        p_notes IN CLOB,
        p_updated_by IN VARCHAR2
    ) IS
        v_table_name VARCHAR2(30);
    BEGIN
        -- تحديد الجدول الذي يحتوي على المستند
        BEGIN
            SELECT 'CUSTOMER_DOCUMENTS' INTO v_table_name
            FROM CUSTOMER_DOCUMENTS
            WHERE DOCUMENT_ID = p_document_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                BEGIN
                    SELECT 'REQUEST_DOCUMENTS' INTO v_table_name
                    FROM REQUEST_DOCUMENTS
                    WHERE DOCUMENT_ID = p_document_id;
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        BEGIN
                            SELECT 'COLLATERAL_DOCUMENTS' INTO v_table_name
                            FROM COLLATERAL_DOCUMENTS
                            WHERE DOCUMENT_ID = p_document_id;
                        EXCEPTION
                            WHEN NO_DATA_FOUND THEN
                                RAISE_APPLICATION_ERROR(-20001, 'Document not found');
                        END;
                END;
        END;
        
        -- تحديث حالة المستند في الجدول المناسب
        IF v_table_name = 'CUSTOMER_DOCUMENTS' THEN
            UPDATE CUSTOMER_DOCUMENTS
            SET DOCUMENT_STATUS = p_document_status,
                NOTES = p_notes,
                UPDATED_DATE = SYSDATE,
                UPDATED_BY = p_updated_by
            WHERE DOCUMENT_ID = p_document_id;
        ELSIF v_table_name = 'REQUEST_DOCUMENTS' THEN
            UPDATE REQUEST_DOCUMENTS
            SET DOCUMENT_STATUS = p_document_status,
                NOTES = p_notes,
                UPDATED_DATE = SYSDATE,
                UPDATED_BY = p_updated_by
            WHERE DOCUMENT_ID = p_document_id;
        ELSIF v_table_name = 'COLLATERAL_DOCUMENTS' THEN
            UPDATE COLLATERAL_DOCUMENTS
            SET NOTES = p_notes,
                UPDATED_DATE = SYSDATE,
                UPDATED_BY = p_updated_by
            WHERE DOCUMENT_ID = p_document_id;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_DOCUMENT_STATUS;
    
    -- الحصول على مستندات العميل
    FUNCTION GET_CUSTOMER_DOCUMENTS(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT *
            FROM CUSTOMER_DOCUMENTS
            WHERE CUSTOMER_ID = p_customer_id
            ORDER BY DOCUMENT_TYPE, CREATED_DATE;
        RETURN v_cursor;
    END GET_CUSTOMER_DOCUMENTS;
    
    -- الحصول على مستندات الطلب
    FUNCTION GET_REQUEST_DOCUMENTS(p_request_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT *
            FROM REQUEST_DOCUMENTS
            WHERE REQUEST_ID = p_request_id
            ORDER BY DOCUMENT_TYPE, CREATED_DATE;
        RETURN v_cursor;
    END GET_REQUEST_DOCUMENTS;
    
    -- التحقق من اكتمال المستندات المطلوبة للطلب
    FUNCTION CHECK_REQUIRED_DOCUMENTS(p_request_id IN NUMBER) RETURN BOOLEAN IS
        v_product_id NUMBER;
        v_required_docs NUMBER;
        v_submitted_docs NUMBER;
    BEGIN
        -- الحصول على معرف المنتج للطلب
        SELECT PRODUCT_ID INTO v_product_id
        FROM FINANCING_REQUESTS
        WHERE REQUEST_ID = p_request_id;
        
        -- عدد المستندات المطلوبة للمنتج
        SELECT COUNT(*) INTO v_required_docs
        FROM PRODUCT_REQUIRED_DOCUMENTS
        WHERE PRODUCT_ID = v_product_id;
        
        -- عدد المستندات المقدمة للطلب
        SELECT COUNT(*) INTO v_submitted_docs
        FROM REQUEST_DOCUMENTS rd
        JOIN PRODUCT_REQUIRED_DOCUMENTS prd ON rd.DOCUMENT_TYPE = prd.DOCUMENT_TYPE
        WHERE rd.REQUEST_ID = p_request_id
        AND prd.PRODUCT_ID = v_product_id
        AND rd.DOCUMENT_STATUS = 'ACTIVE';
        
        -- التحقق من اكتمال المستندات
        RETURN (v_submitted_docs >= v_required_docs);
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END CHECK_REQUIRED_DOCUMENTS;
    
    -- الحصول على المستندات المنتهية الصلاحية
    FUNCTION GET_EXPIRED_DOCUMENTS RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 'CUSTOMER' AS DOCUMENT_OWNER, cd.DOCUMENT_ID, cd.CUSTOMER_ID AS OWNER_ID,
                   c.FULL_NAME AS OWNER_NAME, cd.DOCUMENT_TYPE, cd.DOCUMENT_NUMBER,
                   cd.ISSUE_DATE, cd.EXPIRY_DATE, cd.DOCUMENT_STATUS
            FROM CUSTOMER_DOCUMENTS cd
            JOIN CUSTOMERS c ON cd.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE cd.EXPIRY_DATE < SYSDATE
            AND cd.DOCUMENT_STATUS = 'ACTIVE'
            UNION ALL
            SELECT 'REQUEST' AS DOCUMENT_OWNER, rd.DOCUMENT_ID, rd.REQUEST_ID AS OWNER_ID,
                   r.REQUEST_NUMBER AS OWNER_NAME, rd.DOCUMENT_TYPE, rd.DOCUMENT_NUMBER,
                   rd.ISSUE_DATE, rd.EXPIRY_DATE, rd.DOCUMENT_STATUS
            FROM REQUEST_DOCUMENTS rd
            JOIN FINANCING_REQUESTS r ON rd.REQUEST_ID = r.REQUEST_ID
            WHERE rd.EXPIRY_DATE < SYSDATE
            AND rd.DOCUMENT_STATUS = 'ACTIVE'
            UNION ALL
            SELECT 'COLLATERAL' AS DOCUMENT_OWNER, cd.DOCUMENT_ID, cd.COLLATERAL_ID AS OWNER_ID,
                   c.COLLATERAL_TYPE AS OWNER_NAME, cd.DOCUMENT_TYPE, cd.DOCUMENT_NUMBER,
                   cd.ISSUE_DATE, cd.EXPIRY_DATE, 'ACTIVE' AS DOCUMENT_STATUS
            FROM COLLATERAL_DOCUMENTS cd
            JOIN COLLATERALS c ON cd.COLLATERAL_ID = c.COLLATERAL_ID
            WHERE cd.EXPIRY_DATE < SYSDATE
            ORDER BY EXPIRY_DATE;
        RETURN v_cursor;
    END GET_EXPIRED_DOCUMENTS;
END PKG_DOCUMENTS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_FINANCING AS
    /*
    * تنفيذ حزمة إدارة التمويل
    */
    
    -- إنشاء عقد تمويل جديد
    PROCEDURE CREATE_FINANCING_CONTRACT(
        p_customer_id IN NUMBER,
        p_product_id IN NUMBER,
        p_financing_amount IN NUMBER,
        p_profit_rate IN NUMBER,
        p_installment_count IN NUMBER,
        p_start_date IN DATE,
        p_collateral_ids IN VARCHAR2 DEFAULT NULL, -- قائمة معرفات الضمانات مفصولة بفواصل
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_created_by IN NUMBER,
        p_financing_id OUT NUMBER
    ) IS
        v_customer_exists NUMBER;
        v_product_exists NUMBER;
        v_product_min_amount NUMBER;
        v_product_max_amount NUMBER;
        v_product_min_term NUMBER;
        v_product_max_term NUMBER;
        v_product_profit_rate NUMBER;
        v_customer_credit_score NUMBER;
        v_customer_credit_rating VARCHAR2(50);
        v_dti_ratio NUMBER;
        v_profit_amount NUMBER;
        v_total_amount NUMBER;
        v_installment_amount NUMBER;
        v_end_date DATE;
        v_collateral_id NUMBER;
        v_collateral_cursor SYS_REFCURSOR;
        v_collateral_value NUMBER := 0;
        v_required_collateral_value NUMBER;
        v_collateral_ids_table DBMS_SQL.VARCHAR2_TABLE;
        v_collateral_count NUMBER := 0;
            v_notification_id NUMBER;
            ---
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*) INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- التحقق من وجود المنتج
        SELECT COUNT(*) INTO v_product_exists
        FROM ISLAMIC_PRODUCTS
        WHERE PRODUCT_ID = p_product_id AND PRODUCT_STATUS = 'ACTIVE';
        
        IF v_product_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20008, 'المنتج غير موجود أو غير نشط برقم: ' || p_product_id);
        END IF;
        
        -- الحصول على معلومات المنتج
        SELECT 
            MIN_FINANCING_AMOUNT,
            MAX_FINANCING_AMOUNT,
            MIN_FINANCING_PERIOD,
            MAX_FINANCING_PERIOD,
            PROFIT_RATE
        INTO 
            v_product_min_amount,
            v_product_max_amount,
            v_product_min_term,
            v_product_max_term,
            v_product_profit_rate
        FROM 
            ISLAMIC_PRODUCTS
        WHERE 
            PRODUCT_ID = p_product_id;
        
        -- التحقق من مبلغ التمويل ضمن الحدود المسموحة
        IF p_financing_amount < v_product_min_amount OR p_financing_amount > v_product_max_amount THEN
            RAISE_APPLICATION_ERROR(-20009, 'مبلغ التمويل خارج النطاق المسموح به للمنتج. الحد الأدنى: ' || 
                                           v_product_min_amount || ' الحد الأقصى: ' || v_product_max_amount);
        END IF;
        
        -- التحقق من عدد الأقساط ضمن الحدود المسموحة
        IF p_installment_count < v_product_min_term OR p_installment_count > v_product_max_term THEN
            RAISE_APPLICATION_ERROR(-20010, 'عدد الأقساط خارج النطاق المسموح به للمنتج. الحد الأدنى: ' || 
                                           v_product_min_term || ' الحد الأقصى: ' || v_product_max_term);
        END IF;
        
        -- الحصول على التصنيف الائتماني للعميل
        BEGIN
            SELECT RATING_SCORE, RATING_VALUE
            INTO v_customer_credit_score, v_customer_credit_rating
            FROM CUSTOMER_CREDIT_RATINGS
            WHERE CUSTOMER_ID = p_customer_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- إذا لم يكن للعميل تصنيف ائتماني، قم بإنشاء واحد
                PKG_CREDIT_RATING.UPDATE_CUSTOMER_RATING(p_customer_id);
                
                SELECT RATING_SCORE, RATING_VALUE
                INTO v_customer_credit_score, v_customer_credit_rating
                FROM CUSTOMER_CREDIT_RATINGS
                WHERE CUSTOMER_ID = p_customer_id;
        END;
        
        -- التحقق من أهلية العميل للتمويل بناءً على التصنيف الائتماني
        IF v_customer_credit_rating IN ('F', 'VERY_POOR') THEN
            RAISE_APPLICATION_ERROR(-20011, 'العميل غير مؤهل للتمويل بسبب التصنيف الائتماني المنخفض');
        END IF;
        
        -- حساب نسبة الالتزامات إلى الدخل
        v_dti_ratio := PKG_CUSTOMERS.CALCULATE_DTI_RATIO(p_customer_id);
        
        -- التحقق من نسبة الالتزامات إلى الدخل
        IF v_dti_ratio > 50 THEN
            RAISE_APPLICATION_ERROR(-20012, 'نسبة الالتزامات إلى الدخل مرتفعة جداً: ' || v_dti_ratio || '%');
        END IF;
        
        -- تعديل معدل الربح بناءً على التصنيف الائتماني للعميل
        CASE v_customer_credit_rating
            WHEN 'A' THEN v_product_profit_rate := v_product_profit_rate - 0.5;
            WHEN 'B' THEN v_product_profit_rate := v_product_profit_rate - 0.25;
            WHEN 'C' THEN v_product_profit_rate := v_product_profit_rate;
            WHEN 'D' THEN v_product_profit_rate := v_product_profit_rate + 0.5;
            WHEN 'E' THEN v_product_profit_rate := v_product_profit_rate + 1;
            ELSE v_product_profit_rate := v_product_profit_rate;
        END CASE;
        
        -- استخدام معدل الربح المقدم إذا كان محدداً
        IF p_profit_rate IS NOT NULL THEN
            v_product_profit_rate := p_profit_rate;
        END IF;
        
        -- حساب مبلغ الربح والمبلغ الإجمالي
        v_profit_amount := ROUND(p_financing_amount * (v_product_profit_rate / 100) * (p_installment_count / 12), 2);
        v_total_amount := p_financing_amount + v_profit_amount;
        
        -- حساب مبلغ القسط الشهري
        v_installment_amount := ROUND(v_total_amount / p_installment_count, 2);
        
        -- حساب تاريخ انتهاء العقد
        v_end_date := ADD_MONTHS(p_start_date, p_installment_count);
        
        -- إنشاء معرف جديد لعقد التمويل
        SELECT SEQ_FINANCING_ID.NEXTVAL INTO p_financing_id FROM DUAL;
        
        -- إدراج عقد التمويل
        INSERT INTO FINANCING_CONTRACTS (
            FINANCING_ID, CUSTOMER_ID, PRODUCT_ID, FINANCING_AMOUNT,
            PROFIT_RATE, PROFIT_AMOUNT, TOTAL_AMOUNT, REMAINING_AMOUNT,
            INSTALLMENT_COUNT, INSTALLMENT_AMOUNT, START_DATE, END_DATE,
            CONTRACT_STATUS, NOTES, CREATED_BY, CREATION_DATE
        ) VALUES (
            p_financing_id, p_customer_id, p_product_id, p_financing_amount,
            v_product_profit_rate, v_profit_amount, v_total_amount, v_total_amount,
            p_installment_count, v_installment_amount, p_start_date, v_end_date,
            'PENDING_APPROVAL', p_notes, p_created_by, SYSDATE
        );
        
        -- إضافة الضمانات إذا تم تقديمها
        IF p_collateral_ids IS NOT NULL AND LENGTH(TRIM(p_collateral_ids)) > 0 THEN
            -- تقسيم سلسلة معرفات الضمانات إلى جدول
            v_collateral_count := 0;
            FOR i IN (
                SELECT REGEXP_SUBSTR(p_collateral_ids, '[^,]+', 1, LEVEL) AS collateral_id
                FROM DUAL
                CONNECT BY REGEXP_SUBSTR(p_collateral_ids, '[^,]+', 1, LEVEL) IS NOT NULL
            ) LOOP
                v_collateral_count := v_collateral_count + 1;
                v_collateral_id := TO_NUMBER(TRIM(i.collateral_id));
                
                -- إضافة الضمان لعقد التمويل
                INSERT INTO FINANCING_COLLATERALS (
                    FINANCING_COLLATERAL_ID, COLLATERAL_ID, CREATION_DATE, CREATED_BY
                ) VALUES (
                    p_financing_id, v_collateral_id, SYSDATE, p_created_by
                );
                
                -- حساب إجمالي قيمة الضمانات
                SELECT v_collateral_value + ESTIMATED_VALUE INTO v_collateral_value
                FROM COLLATERALS
                WHERE COLLATERAL_ID = v_collateral_id;
            END LOOP;
        END IF;
        
        -- التحقق من كفاية قيمة الضمانات
        v_required_collateral_value := p_financing_amount * 1.2; -- 120% من مبلغ التمويل
        
        IF v_collateral_value < v_required_collateral_value THEN
            -- إضافة ملاحظة حول عدم كفاية الضمانات
            INSERT INTO FINANCING_NOTES (
                NOTE_ID, FINANCING_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
            ) VALUES (
                SEQ_NOTE_ID.NEXTVAL, p_financing_id, 
                'تنبيه: قيمة الضمانات (' || v_collateral_value || ') أقل من القيمة المطلوبة (' || v_required_collateral_value || ')',
                p_created_by, SYSDATE
            );
        END IF;
        
        -- إنشاء جدول الأقساط
        GENERATE_INSTALLMENT_SCHEDULE(p_financing_id);
        
        -- إضافة سجل لتغيير الحالة
        INSERT INTO FINANCING_STATUS_HISTORY (
            HISTORY_ID, FINANCING_ID, OLD_STATUS, NEW_STATUS,
            CHANGE_REASON, CHANGE_DATE, CHANGED_BY
        ) VALUES (
            SEQ_STATUS_HISTORY_ID.NEXTVAL, p_financing_id, NULL, 'PENDING_APPROVAL',
            'إنشاء عقد تمويل جديد', SYSDATE, p_created_by
        );
        
        -- إرسال إشعار للموافقة على التمويل
        PKG_NOTIFICATIONS.SEND_SYSTEM_NOTIFICATION(
            p_notification_title => 'طلب تمويل جديد بانتظار الموافقة',
            p_notification_message => 'تم إنشاء طلب تمويل جديد برقم ' || p_financing_id || ' للعميل رقم ' || p_customer_id || ' بمبلغ ' || p_financing_amount,
            p_notification_type => 'FINANCING',
            ---p_related_id => p_financing_id,
          ---  p_user_id => NULL -- إرسال لجميع المستخدمين المصرح لهم            
            p_start_date => SYSDATE,
                p_end_date => ADD_MONTHS(SYSDATE, 1),
        p_target_users => NULL, -- لجميع المستخدمين
        p_target_roles => NULL, -- لجميع الأدوار
        p_created_by => p_created_by, ---1,
        p_notification_id => v_notification_id
        );
              
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_FINANCING_CONTRACT;
    
    -- تحديث عقد التمويل
    PROCEDURE UPDATE_FINANCING_CONTRACT(
    p_financing_id IN NUMBER,
    p_profit_rate IN NUMBER DEFAULT NULL,
    p_installment_count IN NUMBER DEFAULT NULL,
    p_start_date IN DATE DEFAULT NULL,
    p_notes IN VARCHAR2 DEFAULT NULL,
    p_updated_by IN NUMBER
) IS
    v_contract_status VARCHAR2(50);
    v_old_profit_rate NUMBER;
    v_old_installment_count NUMBER;
    v_old_start_date DATE;
    v_old_end_date DATE;
    v_old_profit_amount NUMBER;
    v_old_total_amount NUMBER;
    v_old_remaining_amount NUMBER;
    v_old_installment_amount NUMBER;
    v_old_notes VARCHAR2(4000);
    v_financing_amount NUMBER;
    v_profit_amount NUMBER;
    v_total_amount NUMBER;
    v_installment_amount NUMBER;
    v_end_date DATE;
    v_remaining_amount NUMBER;
    v_notes VARCHAR2(4000);
    v_new_profit_rate NUMBER;
    v_new_installment_count NUMBER;
    v_new_start_date DATE;
    v_regenerate_schedule BOOLEAN := FALSE;
BEGIN
    -- الحصول على معلومات العقد الحالية
    SELECT 
        CONTRACT_STATUS, PROFIT_RATE, INSTALLMENT_COUNT,
        START_DATE, END_DATE, FINANCING_AMOUNT,
        PROFIT_AMOUNT, TOTAL_AMOUNT, REMAINING_AMOUNT,
        INSTALLMENT_AMOUNT, NOTES
    INTO 
        v_contract_status, v_old_profit_rate, v_old_installment_count,
        v_old_start_date, v_old_end_date, v_financing_amount,
        v_old_profit_amount, v_old_total_amount, v_old_remaining_amount,
        v_old_installment_amount, v_old_notes
    FROM 
        FINANCING_CONTRACTS
    WHERE 
        FINANCING_ID = p_financing_id;
        
    -- التحقق من إمكانية تحديث العقد
    IF v_contract_status NOT IN ('PENDING_APPROVAL', 'APPROVED', 'ACTIVE') THEN
        RAISE_APPLICATION_ERROR(-20013, 'لا يمكن تحديث عقد التمويل في الحالة الحالية: ' || v_contract_status);
    END IF;
    
    -- تحديد القيم الجديدة للتحديث
    v_new_profit_rate := COALESCE(p_profit_rate, v_old_profit_rate);
    v_new_installment_count := COALESCE(p_installment_count, v_old_installment_count);
    v_new_start_date := COALESCE(p_start_date, v_old_start_date);
    v_notes := COALESCE(p_notes, v_old_notes);
        
    -- تحديد ما إذا كان يجب إعادة إنشاء جدول الأقساط
    IF (p_profit_rate IS NOT NULL AND p_profit_rate != v_old_profit_rate) OR
       (p_installment_count IS NOT NULL AND p_installment_count != v_old_installment_count) OR
       (p_start_date IS NOT NULL AND p_start_date != v_old_start_date) THEN
        v_regenerate_schedule := TRUE;
                
        -- حساب القيم الجديدة
        v_profit_amount := ROUND(v_financing_amount * (v_new_profit_rate / 100) * (v_new_installment_count / 12), 2);
        v_total_amount := v_financing_amount + v_profit_amount;
        v_installment_amount := ROUND(v_total_amount / v_new_installment_count, 2);
        v_end_date := ADD_MONTHS(v_new_start_date, v_new_installment_count);
        v_remaining_amount := v_total_amount;
    ELSE
        -- استخدام القيم القديمة إذا لم يتم إعادة إنشاء الجدول
        v_profit_amount := v_old_profit_amount;
        v_total_amount := v_old_total_amount;
        v_installment_amount := v_old_installment_amount;
        v_end_date := v_old_end_date;
        v_remaining_amount := v_old_remaining_amount;
    END IF;
        
    -- تحديث عقد التمويل
    UPDATE FINANCING_CONTRACTS
    SET
        PROFIT_RATE = v_new_profit_rate,
        INSTALLMENT_COUNT = v_new_installment_count,
        START_DATE = v_new_start_date,
        END_DATE = v_end_date,
        PROFIT_AMOUNT = v_profit_amount,
        TOTAL_AMOUNT = v_total_amount,
        REMAINING_AMOUNT = v_remaining_amount,
        INSTALLMENT_AMOUNT = v_installment_amount,
        NOTES = v_notes,
        LAST_UPDATE_DATE = SYSDATE,
        LAST_UPDATED_BY = p_updated_by
    WHERE 
        FINANCING_ID = p_financing_id;
        
    -- إعادة إنشاء جدول الأقساط إذا لزم الأمر
    IF v_regenerate_schedule THEN
        GENERATE_INSTALLMENT_SCHEDULE(p_financing_id, TRUE);
    END IF;
        
    -- إضافة ملاحظة حول التحديث
    INSERT INTO FINANCING_NOTES (
        NOTE_ID, FINANCING_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
    ) VALUES (
        SEQ_NOTE_ID.NEXTVAL, p_financing_id, 
        'تم تحديث عقد التمويل بواسطة المستخدم رقم ' || p_updated_by,
        p_updated_by, SYSDATE
    );
        
    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
    END UPDATE_FINANCING_CONTRACT;
    
    -- الحصول على تفاصيل عقد التمويل
    FUNCTION GET_FINANCING_CONTRACT(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_contract_exists NUMBER;
    BEGIN
        -- التحقق من وجود العقد
        SELECT COUNT(*) INTO v_contract_exists
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                fc.FINANCING_ID,
                fc.CUSTOMER_ID,
                c.FULL_NAME AS CUSTOMER_NAME,
                c.NATIONAL_ID AS CUSTOMER_NATIONAL_ID,
                c.MOBILE_NUMBER AS CUSTOMER_MOBILE,
                fc.PRODUCT_ID,
                ip.PRODUCT_NAME,
                ip.PRODUCT_TYPE,
                fc.FINANCING_AMOUNT,
                fc.PROFIT_RATE,
                fc.PROFIT_AMOUNT,
                fc.TOTAL_AMOUNT,
                fc.REMAINING_AMOUNT,
                fc.INSTALLMENT_COUNT,
                fc.INSTALLMENT_AMOUNT,
                fc.START_DATE,
                fc.END_DATE,
                fc.CONTRACT_STATUS,
                fc.NOTES,
                fc.CREATED_BY,
                u1.USERNAME AS CREATED_BY_NAME,
                fc.CREATION_DATE,
                fc.LAST_UPDATED_BY,
                u2.USERNAME AS UPDATED_BY_NAME,
                fc.LAST_UPDATE_DATE,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID) AS TOTAL_INSTALLMENTS,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'PAID') AS PAID_INSTALLMENTS,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'OVERDUE') AS OVERDUE_INSTALLMENTS,
                (SELECT COUNT(*) FROM FINANCING_COLLATERALS fcol WHERE fcol.FINANCING_COLLATERAL_ID = fc.FINANCING_ID) AS COLLATERAL_COUNT,
                (SELECT SUM(col.ESTIMATED_VALUE) FROM FINANCING_COLLATERALS fcol JOIN COLLATERALS col ON fcol.COLLATERAL_ID = col.COLLATERAL_ID WHERE fcol.FINANCING_COLLATERAL_ID = fc.FINANCING_ID) AS TOTAL_COLLATERAL_VALUE,
                (SELECT MIN(ins.DUE_DATE) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'UNPAID') AS NEXT_INSTALLMENT_DATE,
                (SELECT ins.TOTAL_AMOUNT FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'UNPAID' AND ROWNUM = 1) AS NEXT_INSTALLMENT_AMOUNT
            FROM 
                FINANCING_CONTRACTS fc
                JOIN CUSTOMERS c ON fc.CUSTOMER_ID = c.CUSTOMER_ID
                JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
                LEFT JOIN USERS u1 ON fc.CREATED_BY = u1.USER_ID
                LEFT JOIN USERS u2 ON fc.LAST_UPDATED_BY = u2.USER_ID
            WHERE 
                fc.FINANCING_ID = p_financing_id;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_FINANCING_CONTRACT;
    
    -- الحصول على جدول الأقساط لعقد التمويل
    FUNCTION GET_INSTALLMENT_SCHEDULE(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_contract_exists NUMBER;
    BEGIN
        -- التحقق من وجود العقد
        SELECT COUNT(*) INTO v_contract_exists
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                ins.INSTALLMENT_ID,
                ins.REQUEST_ID,
                ins.CONTRACT_ID,
                ins.TOTAL_AMOUNT,
                ins.PRINCIPAL_AMOUNT,
                ins.PROFIT_AMOUNT,
                ins.DUE_DATE,
                ins.INSTALLMENT_STATUS,
                ins.PAYMENT_DATE,
                ins.PAID_AMOUNT,
                ins.REMAINING_AMOUNT,
                ins.LATE_FEES,
                ins.CREATED_DATE,
                ins.UPDATED_DATE,
                p.PAYMENT_ID,
                p.PAYMENT_METHOD,
                p.REFERENCE_NUMBER,
                CASE 
                    WHEN ins.INSTALLMENT_STATUS = 'PAID' AND ins.PAYMENT_DATE > ins.DUE_DATE THEN 'متأخر'
                    WHEN ins.INSTALLMENT_STATUS = 'PAID' AND ins.PAYMENT_DATE <= ins.DUE_DATE THEN 'في الموعد'
                    WHEN ins.INSTALLMENT_STATUS = 'UNPAID' AND SYSDATE > ins.DUE_DATE THEN 'متأخر'
                    WHEN ins.INSTALLMENT_STATUS = 'UNPAID' AND SYSDATE <= ins.DUE_DATE THEN 'مستقبلي'
                    ELSE ins.INSTALLMENT_STATUS
                END AS PAYMENT_STATUS,
                CASE 
                    WHEN ins.INSTALLMENT_STATUS = 'PAID' AND ins.PAYMENT_DATE > ins.DUE_DATE THEN TRUNC(ins.PAYMENT_DATE) - TRUNC(ins.DUE_DATE)
                    WHEN ins.INSTALLMENT_STATUS = 'UNPAID' AND SYSDATE > ins.DUE_DATE THEN TRUNC(SYSDATE) - TRUNC(ins.DUE_DATE)
                    ELSE 0
                END AS DAYS_LATE
            FROM 
                INSTALLMENT_SCHEDULE ins
                LEFT JOIN PAYMENTS p ON ins.INSTALLMENT_ID = p.INSTALLMENT_ID
            WHERE 
                ins.REQUEST_ID = p_financing_id
            ORDER BY 
                ins.INSTALLMENT_ID;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_INSTALLMENT_SCHEDULE;
    
    -- تغيير حالة عقد التمويل
    PROCEDURE CHANGE_CONTRACT_STATUS(
        p_financing_id IN NUMBER,
        p_new_status IN VARCHAR2,
        p_reason IN VARCHAR2,
        p_updated_by IN NUMBER
    ) IS
        v_old_status VARCHAR2(50);
        v_customer_id NUMBER;
        v_financing_amount NUMBER;
        v_product_name VARCHAR2(100);
                v_notification_id NUMBER;
    BEGIN
        -- الحصول على الحالة الحالية للعقد ومعلومات أخرى
        SELECT 
            fc.CONTRACT_STATUS, fc.CUSTOMER_ID, fc.FINANCING_AMOUNT, ip.PRODUCT_NAME
        INTO 
            v_old_status, v_customer_id, v_financing_amount, v_product_name
        FROM 
            FINANCING_CONTRACTS fc
            JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
        WHERE 
            fc.FINANCING_ID = p_financing_id;
        
        -- التحقق من صحة تغيير الحالة
        IF v_old_status = p_new_status THEN
            RETURN; -- لا يوجد تغيير في الحالة
        END IF;
        
        -- التحقق من صحة الانتقال بين الحالات
        CASE p_new_status
            WHEN 'APPROVED' THEN
                IF v_old_status != 'PENDING_APPROVAL' THEN
                    RAISE_APPLICATION_ERROR(-20015, 'لا يمكن تغيير الحالة من ' || v_old_status || ' إلى APPROVED');
                END IF;
            WHEN 'REJECTED' THEN
                IF v_old_status != 'PENDING_APPROVAL' THEN
                    RAISE_APPLICATION_ERROR(-20016, 'لا يمكن تغيير الحالة من ' || v_old_status || ' إلى REJECTED');
                END IF;
            WHEN 'ACTIVE' THEN
                IF v_old_status != 'APPROVED' THEN
                    RAISE_APPLICATION_ERROR(-20017, 'لا يمكن تغيير الحالة من ' || v_old_status || ' إلى ACTIVE');
                END IF;
            WHEN 'COMPLETED' THEN
                IF v_old_status != 'ACTIVE' THEN
                    RAISE_APPLICATION_ERROR(-20018, 'لا يمكن تغيير الحالة من ' || v_old_status || ' إلى COMPLETED');
                END IF;
            WHEN 'CANCELLED' THEN
                IF v_old_status NOT IN ('PENDING_APPROVAL', 'APPROVED') THEN
                    RAISE_APPLICATION_ERROR(-20019, 'لا يمكن تغيير الحالة من ' || v_old_status || ' إلى CANCELLED');
                END IF;
            WHEN 'DEFAULTED' THEN
                IF v_old_status != 'ACTIVE' THEN
                    RAISE_APPLICATION_ERROR(-20020, 'لا يمكن تغيير الحالة من ' || v_old_status || ' إلى DEFAULTED');
                END IF;
            WHEN 'SETTLED' THEN
                IF v_old_status != 'ACTIVE' THEN
                    RAISE_APPLICATION_ERROR(-20021, 'لا يمكن تغيير الحالة من ' || v_old_status || ' إلى SETTLED');
                END IF;
            ELSE
                RAISE_APPLICATION_ERROR(-20022, 'حالة غير صالحة: ' || p_new_status);
        END CASE;
        
        -- تحديث حالة العقد
        UPDATE FINANCING_CONTRACTS
        SET
            CONTRACT_STATUS = p_new_status,
            LAST_UPDATE_DATE = SYSDATE,
            LAST_UPDATED_BY = p_updated_by
        WHERE 
            FINANCING_ID = p_financing_id;
        
        -- إضافة سجل لتغيير الحالة
        INSERT INTO FINANCING_STATUS_HISTORY (
            HISTORY_ID, FINANCING_ID, OLD_STATUS, NEW_STATUS,
            CHANGE_REASON, CHANGE_DATE, CHANGED_BY
        ) VALUES (
            SEQ_STATUS_HISTORY_ID.NEXTVAL, p_financing_id, v_old_status, p_new_status,
            p_reason, SYSDATE, p_updated_by
        );
        
        -- إجراءات إضافية بناءً على الحالة الجديدة
        CASE p_new_status
            WHEN 'APPROVED' THEN
                -- إرسال إشعار للعميل
                PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
                    p_customer_id => v_customer_id,
                    p_notification_title => 'تمت الموافقة على طلب التمويل',
                    p_notification_text => 'تمت الموافقة على طلب التمويل الخاص بك رقم ' || p_financing_id || ' بمبلغ ' || v_financing_amount || ' للمنتج ' || v_product_name,
                    p_notification_type => 'FINANCING',
                    p_related_entity_id => p_financing_id,
                    p_related_entity => 'CHANGE_CONTRACT_STATUS',
                    p_notification_id => v_notification_id
                );
                
                
            WHEN 'REJECTED' THEN
                -- إرسال إشعار للعميل
                PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
                    p_customer_id => v_customer_id,
                    p_notification_title => 'تم رفض طلب التمويل',
                    p_notification_text => 'نأسف لإبلاغك بأنه تم رفض طلب التمويل الخاص بك رقم ' || p_financing_id || ' للمنتج ' || v_product_name || '. السبب: ' || p_reason,
                    p_notification_type => 'FINANCING',                    
                    p_related_entity_id => p_financing_id,
                    p_related_entity => 'CHANGE_CONTRACT_STATUS',
                    p_notification_id => v_notification_id                    
                  ---  p_related_id => p_financing_id
                );
                
            WHEN 'ACTIVE' THEN
                -- تحديث التزامات العميل المالية
                INSERT INTO CUSTOMER_FINANCIAL_OBLIGATIONS (
                    OBLIGATION_ID, CUSTOMER_ID, OBLIGATION_TYPE, ORIGINAL_AMOUNT,
                    MONTHLY_PAYMENT, START_DATE, END_DATE, DESCRIPTION, CREATION_DATE
                ) VALUES (
                    SEQ_OBLIGATION_ID.NEXTVAL, v_customer_id, 'FINANCING', v_financing_amount,
                    (SELECT INSTALLMENT_AMOUNT FROM FINANCING_CONTRACTS WHERE FINANCING_ID = p_financing_id),
                    SYSDATE, (SELECT END_DATE FROM FINANCING_CONTRACTS WHERE FINANCING_ID = p_financing_id),
                    'تمويل رقم ' || p_financing_id || ' - ' || v_product_name, SYSDATE
                );
                
                -- إرسال إشعار للعميل
                PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
                    p_customer_id => v_customer_id,
                    p_notification_title => 'تم تفعيل عقد التمويل',
                    p_notification_text => 'تم تفعيل عقد التمويل الخاص بك رقم ' || p_financing_id || ' بمبلغ ' || v_financing_amount || ' للمنتج ' || v_product_name,
                    p_notification_type => 'FINANCING',
                    p_related_entity_id => p_financing_id,
                    p_related_entity => 'CHANGE_CONTRACT_STATUS',
                    p_notification_id => v_notification_id
                );
                ---
                    
            WHEN 'COMPLETED' THEN
                -- تحديث التزامات العميل المالية
                UPDATE CUSTOMER_FINANCIAL_OBLIGATIONS
                SET
                    END_DATE = SYSDATE,
                    LAST_UPDATE_DATE = SYSDATE
                WHERE 
                    CUSTOMER_ID = v_customer_id AND
                    OBLIGATION_TYPE = 'FINANCING' AND
                    DESCRIPTION LIKE '%تمويل رقم ' || p_financing_id || '%';
                
                -- إرسال إشعار للعميل
                PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
                    p_customer_id => v_customer_id,
                    p_notification_title => 'تم إكمال عقد التمويل',
                    p_notification_text => 'تهانينا! تم إكمال عقد التمويل الخاص بك رقم ' || p_financing_id || ' للمنتج ' || v_product_name || ' بنجاح.',
                    p_notification_type => 'FINANCING',
                    p_related_entity_id => p_financing_id,
                    p_related_entity => 'CHANGE_CONTRACT_STATUS',
                    p_notification_id => v_notification_id
                );
                
                
                    
            WHEN 'CANCELLED' THEN
                -- إرسال إشعار للعميل
                PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
                    p_customer_id => v_customer_id,
                    p_notification_title => 'تم إلغاء عقد التمويل',
                    p_notification_text => 'تم إلغاء عقد التمويل الخاص بك رقم ' || p_financing_id || ' للمنتج ' || v_product_name || '. السبب: ' || p_reason,
                    p_notification_type => 'FINANCING',
                    p_related_entity_id => p_financing_id,
                    p_related_entity => 'CHANGE_CONTRACT_STATUS',
                    p_notification_id => v_notification_id
                );
                
            WHEN 'DEFAULTED' THEN
                -- تحديث التصنيف الائتماني للعميل
                PKG_CREDIT_RATING.UPDATE_CUSTOMER_RATING(v_customer_id);
                
                -- إرسال إشعار للعميل
                PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
                    p_customer_id => v_customer_id,
                    p_notification_title => 'تعثر في عقد التمويل',
                    p_notification_text => 'نود إبلاغك بأن عقد التمويل الخاص بك رقم ' || p_financing_id || ' للمنتج ' || v_product_name || ' قد تم تصنيفه كمتعثر. يرجى التواصل معنا في أقرب وقت ممكن.',
                    p_notification_type => 'FINANCING',
                    p_related_entity_id => p_financing_id,
                    p_related_entity => 'CHANGE_CONTRACT_STATUS',
                    p_notification_id => v_notification_id
                );
                
                -- إرسال إشعار للإدارة
                PKG_NOTIFICATIONS.SEND_SYSTEM_NOTIFICATION(
                    p_notification_title => 'تعثر في عقد التمويل',
                    p_notification_message => 'تم تصنيف عقد التمويل رقم ' || p_financing_id || ' للعميل رقم ' || v_customer_id || ' كمتعثر. السبب: ' || p_reason,
                    p_notification_type => 'FINANCING',
                    --p_related_id => p_financing_id,
                    --p_user_id => NULL -- إرسال لجميع المستخدمين المصرح لهم
                    p_start_date => SYSDATE,
                p_end_date => ADD_MONTHS(SYSDATE, 1),
                    p_target_users => NULL, -- لجميع المستخدمين
        p_target_roles => NULL, -- لجميع الأدوار
        p_created_by => p_updated_by, ---1,
        p_notification_id => v_notification_id
                );
          
                
            WHEN 'SETTLED' THEN
                -- تحديث التزامات العميل المالية
                UPDATE CUSTOMER_FINANCIAL_OBLIGATIONS
                SET
                    END_DATE = SYSDATE,
                    LAST_UPDATE_DATE = SYSDATE
                WHERE 
                    CUSTOMER_ID = v_customer_id AND
                    OBLIGATION_TYPE = 'FINANCING' AND
                    DESCRIPTION LIKE '%تمويل رقم ' || p_financing_id || '%';
                
                -- إرسال إشعار للعميل
                PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
                    p_customer_id => v_customer_id,
                    p_notification_title => 'تمت تسوية عقد التمويل',
                    p_notification_text => 'تهانينا! تمت تسوية عقد التمويل الخاص بك رقم ' || p_financing_id || ' للمنتج ' || v_product_name || ' بنجاح.',
                    p_notification_type => 'FINANCING',
                    p_related_entity_id => p_financing_id,
                    p_related_entity => 'SEND_CUSTOMER_NOTIFICATION',
                    p_notification_id => v_notification_id
                );
                    
                    
        END CASE;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CHANGE_CONTRACT_STATUS;
    
    -- تسجيل دفعة جديدة
    PROCEDURE REGISTER_PAYMENT(
        p_financing_id IN NUMBER,
        p_installment_id IN NUMBER,
        p_amount IN NUMBER,
        p_payment_method IN VARCHAR2,
        p_payment_date IN DATE,
        p_reference_number IN VARCHAR2 DEFAULT NULL,
        p_notes IN VARCHAR2 DEFAULT NULL,
        p_created_by IN NUMBER,
        p_payment_id OUT NUMBER
    ) IS
        v_contract_status VARCHAR2(50);
        v_installment_status VARCHAR2(50);
        v_installment_amount NUMBER;
        v_installment_remaining NUMBER;
        v_due_date DATE;
        v_installment_number NUMBER;
        v_customer_id NUMBER;
        v_product_name VARCHAR2(100);
        v_late_fees NUMBER := 0;
        v_days_late NUMBER := 0;
        v_notification_id number;
    BEGIN
        -- التحقق من حالة عقد التمويل
        SELECT CONTRACT_STATUS, CUSTOMER_ID
        INTO v_contract_status, v_customer_id
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_status NOT IN ('ACTIVE', 'DEFAULTED') THEN
            RAISE_APPLICATION_ERROR(-20023, 'لا يمكن تسجيل دفعة لعقد تمويل في الحالة: ' || v_contract_status);
        END IF;
        
        -- الحصول على معلومات القسط
        SELECT 
            ins.INSTALLMENT_STATUS, ins.TOTAL_AMOUNT, ins.REMAINING_AMOUNT, 
            ins.DUE_DATE, ins.INSTALLMENT_ID, ip.PRODUCT_NAME
        INTO 
            v_installment_status, v_installment_amount, v_installment_remaining, 
            v_due_date, v_installment_number, v_product_name
        FROM 
            INSTALLMENT_SCHEDULE ins
            JOIN FINANCING_CONTRACTS fc ON ins.CONTRACT_ID = fc.FINANCING_ID
            JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
        WHERE 
            ins.INSTALLMENT_ID = p_installment_id AND ins.CONTRACT_ID = p_financing_id;
        
        -- التحقق من حالة القسط
        IF v_installment_status = 'PAID' THEN
            RAISE_APPLICATION_ERROR(-20024, 'القسط رقم ' || v_installment_number || ' تم دفعه بالفعل');
        END IF;
        
        -- حساب الغرامات إذا كان الدفع متأخراً
        IF p_payment_date > v_due_date THEN
            v_days_late := TRUNC(p_payment_date) - TRUNC(v_due_date);
            
            -- حساب غرامة التأخير (على سبيل المثال: 0.5% من مبلغ القسط لكل يوم تأخير، بحد أقصى 10%)
            v_late_fees := LEAST(v_installment_amount * 0.005 * v_days_late, v_installment_amount * 0.1);
            
            -- تحديث غرامة التأخير في جدول الأقساط
            UPDATE INSTALLMENT_SCHEDULE
            SET LATE_FEES = v_late_fees
            WHERE INSTALLMENT_ID = p_installment_id;
        END IF;
        
        -- إنشاء معرف جديد للدفعة
        SELECT SEQ_PAYMENT_ID.NEXTVAL INTO p_payment_id FROM DUAL;
        
        -- تسجيل الدفعة
        INSERT INTO PAYMENTS (
            PAYMENT_ID, FINANCING_ID, INSTALLMENT_ID, PAYMENT_AMOUNT,
            PAYMENT_METHOD, PAYMENT_DATE, REFERENCE_NUMBER, NOTES,
            CREATED_BY, CREATION_DATE, PAYMENT_STATUS
        ) VALUES (
            p_payment_id, p_financing_id, p_installment_id, p_amount,
            p_payment_method, p_payment_date, p_reference_number, p_notes,
            p_created_by, SYSDATE, 'COMPLETED'
        );
        
        -- تحديث حالة القسط
        IF p_amount >= (v_installment_remaining + v_late_fees) THEN
            -- دفع كامل للقسط
            UPDATE INSTALLMENT_SCHEDULE
            SET
                INSTALLMENT_STATUS = 'PAID',
                PAYMENT_DATE = p_payment_date,
                PAID_AMOUNT = p_amount,
                REMAINING_AMOUNT = 0,
                UPDATED_DATE = SYSDATE
            WHERE
                INSTALLMENT_ID = p_installment_id;
        ELSE
            -- دفع جزئي للقسط
            UPDATE INSTALLMENT_SCHEDULE
            SET
                PAID_AMOUNT = NVL(PAID_AMOUNT, 0) + p_amount,
                REMAINING_AMOUNT = REMAINING_AMOUNT - p_amount,
                UPDATED_DATE = SYSDATE
            WHERE
                INSTALLMENT_ID = p_installment_id;
        END IF;
        
        -- تحديث المبلغ المتبقي في عقد التمويل
        UPDATE_REMAINING_AMOUNT(p_financing_id);
        
        -- التحقق مما إذا كانت جميع الأقساط مدفوعة
        DECLARE
            v_unpaid_count NUMBER;
        BEGIN
            SELECT COUNT(*)
            INTO v_unpaid_count
            FROM INSTALLMENT_SCHEDULE
            WHERE CONTRACT_ID = p_financing_id AND INSTALLMENT_STATUS != 'PAID';
            
            IF v_unpaid_count = 0 THEN
                -- تغيير حالة العقد إلى مكتمل
                CHANGE_CONTRACT_STATUS(
                    p_financing_id => p_financing_id,
                    p_new_status => 'COMPLETED',
                    p_reason => 'تم دفع جميع الأقساط',
                    p_updated_by => p_created_by
                );
            END IF;
        END;
        
        -- إرسال إشعار للعميل
        PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
            p_customer_id => v_customer_id,
            p_notification_title => 'تم تسجيل دفعة جديدة',
            p_notification_text => 'تم تسجيل دفعة بمبلغ ' || p_amount || ' للقسط رقم ' || v_installment_number || ' من عقد التمويل رقم ' || p_financing_id || ' للمنتج ' || v_product_name,
            p_notification_type => 'PAYMENT',
            p_related_entity_id => p_payment_id,
            p_related_entity => 'REGISTER_PAYMENT',
            p_notification_id => v_notification_id
        );
                    
                    
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20025, 'عقد التمويل أو القسط غير موجود');
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END REGISTER_PAYMENT;
    
    -- إلغاء دفعة
    PROCEDURE CANCEL_PAYMENT(
        p_payment_id IN NUMBER,
        p_reason IN VARCHAR2,
        p_cancelled_by IN NUMBER
    ) IS
        v_payment_status VARCHAR2(50);
        v_financing_id NUMBER;
        v_installment_id NUMBER;
        v_payment_amount NUMBER;
        v_installment_status VARCHAR2(50);
        v_paid_amount NUMBER;
        v_installment_amount NUMBER;
        v_customer_id NUMBER;
        v_notification_id NUMBER;
    BEGIN
        -- الحصول على معلومات الدفعة
        SELECT 
            p.PAYMENT_STATUS, p.FINANCING_ID, p.INSTALLMENT_ID, p.PAYMENT_AMOUNT,
            ins.INSTALLMENT_STATUS, ins.PAID_AMOUNT, ins.TOTAL_AMOUNT,
            fc.CUSTOMER_ID
        INTO 
            v_payment_status, v_financing_id, v_installment_id, v_payment_amount,
            v_installment_status, v_paid_amount, v_installment_amount,
            v_customer_id
        FROM 
            PAYMENTS p
            JOIN INSTALLMENT_SCHEDULE ins ON p.INSTALLMENT_ID = ins.INSTALLMENT_ID
            JOIN FINANCING_CONTRACTS fc ON p.FINANCING_ID = fc.FINANCING_ID
        WHERE 
            p.PAYMENT_ID = p_payment_id;
        
        -- التحقق من إمكانية إلغاء الدفعة
        IF v_payment_status = 'CANCELLED' THEN
            RAISE_APPLICATION_ERROR(-20026, 'الدفعة تم إلغاؤها بالفعل');
        END IF;
        
        -- تحديث حالة الدفعة
        UPDATE PAYMENTS
        SET
            PAYMENT_STATUS = 'CANCELLED',
            CANCELLATION_REASON = p_reason,
            CANCELLED_BY = p_cancelled_by,
            CANCELLATION_DATE = SYSDATE
           --- LAST_UPDATE_DATE = SYSDATE
        WHERE
            PAYMENT_ID = p_payment_id;
        
        -- تحديث حالة القسط
        IF v_installment_status = 'PAID' AND v_paid_amount = v_payment_amount THEN
            -- إذا كان القسط مدفوعاً بالكامل بواسطة هذه الدفعة، أعد تعيين حالته إلى غير مدفوع
            UPDATE INSTALLMENT_SCHEDULE
            SET
                INSTALLMENT_STATUS = 'UNPAID',
                PAYMENT_DATE = NULL,
                PAID_AMOUNT = 0,
                REMAINING_AMOUNT = TOTAL_AMOUNT,
                UPDATED_DATE = SYSDATE
            WHERE
                INSTALLMENT_ID = v_installment_id;
        ELSIF v_paid_amount > v_payment_amount THEN
            -- إذا كان هناك دفعات أخرى للقسط، قم بتحديث المبلغ المدفوع والمتبقي
            UPDATE INSTALLMENT_SCHEDULE
            SET
                PAID_AMOUNT = PAID_AMOUNT - v_payment_amount,
                REMAINING_AMOUNT = REMAINING_AMOUNT + v_payment_amount,
                UPDATED_DATE = SYSDATE
            WHERE
                INSTALLMENT_ID = v_installment_id;
        END IF;
        
        -- تحديث المبلغ المتبقي في عقد التمويل
        UPDATE_REMAINING_AMOUNT(v_financing_id);
        
        -- إرسال إشعار للعميل
        PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
            p_customer_id => v_customer_id,
            p_notification_title => 'تم إلغاء دفعة',
            p_notification_text => 'تم إلغاء دفعة بمبلغ ' || v_payment_amount || ' لعقد التمويل رقم ' || v_financing_id || '. السبب: ' || p_reason,
            p_notification_type => 'PAYMENT',
            p_related_entity_id => p_payment_id,
            p_related_entity => 'CANCEL_PAYMENT',
            p_notification_id => v_notification_id
        );
                    
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20027, 'الدفعة غير موجودة برقم: ' || p_payment_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CANCEL_PAYMENT;
    
   -- إعادة جدولة التمويل
    PROCEDURE RESCHEDULE_FINANCING(
    p_financing_id IN NUMBER,
    p_new_installment_count IN NUMBER,
    p_new_profit_rate IN NUMBER DEFAULT NULL,
    p_grace_period_months IN NUMBER DEFAULT 0,
    p_reason IN VARCHAR2,
    p_approved_by IN NUMBER,
    p_new_financing_id OUT NUMBER
) IS
    v_contract_status VARCHAR2(50);
    v_customer_id NUMBER;
    v_product_id NUMBER;
    v_financing_amount NUMBER;
    v_old_profit_rate NUMBER;
    v_remaining_amount NUMBER;
    v_paid_amount NUMBER;
    v_profit_rate NUMBER;
    v_profit_amount NUMBER;
    v_total_amount NUMBER;
    v_installment_amount NUMBER;
    v_start_date DATE;
    v_end_date DATE;
    v_notification_id NUMBER; -- متغير لاستقبال معرف الإشعار
BEGIN
    -- الحصول على معلومات عقد التمويل الحالي
    SELECT 
        CONTRACT_STATUS, CUSTOMER_ID, PRODUCT_ID, FINANCING_AMOUNT,
        PROFIT_RATE, REMAINING_AMOUNT, (TOTAL_AMOUNT - REMAINING_AMOUNT) AS PAID_AMOUNT
    INTO 
        v_contract_status, v_customer_id, v_product_id, v_financing_amount,
        v_old_profit_rate, v_remaining_amount, v_paid_amount
    FROM 
        FINANCING_CONTRACTS
    WHERE 
        FINANCING_ID = p_financing_id;
        
    -- التحقق من إمكانية إعادة جدولة العقد
    IF v_contract_status NOT IN ('ACTIVE', 'DEFAULTED') THEN
        RAISE_APPLICATION_ERROR(-20028, 'لا يمكن إعادة جدولة عقد تمويل في الحالة: ' || v_contract_status);
    END IF;
        
    -- استخدام معدل الربح الجديد إذا تم تحديده، وإلا استخدم المعدل الحالي
    v_profit_rate := COALESCE(p_new_profit_rate, v_old_profit_rate);
        
    -- تعيين تاريخ البدء الجديد (تاريخ اليوم + فترة السماح)
    v_start_date := ADD_MONTHS(TRUNC(SYSDATE), p_grace_period_months);
        
    -- حساب تاريخ الانتهاء الجديد
    v_end_date := ADD_MONTHS(v_start_date, p_new_installment_count);
        
    -- حساب مبلغ الربح الجديد والمبلغ الإجمالي
    v_profit_amount := ROUND(v_remaining_amount * (v_profit_rate / 100) * (p_new_installment_count / 12), 2);
    v_total_amount := v_remaining_amount + v_profit_amount;
        
    -- حساب مبلغ القسط الشهري الجديد
    v_installment_amount := ROUND(v_total_amount / p_new_installment_count, 2);
        
    -- إنشاء معرف جديد لعقد التمويل المعاد جدولته
    SELECT SEQ_FINANCING_ID.NEXTVAL INTO p_new_financing_id FROM DUAL;
        
    -- إنشاء عقد تمويل جديد للجدولة الجديدة
    INSERT INTO FINANCING_CONTRACTS (
        FINANCING_ID, CUSTOMER_ID, PRODUCT_ID, FINANCING_AMOUNT,
        PROFIT_RATE, PROFIT_AMOUNT, TOTAL_AMOUNT, REMAINING_AMOUNT,
        INSTALLMENT_COUNT, INSTALLMENT_AMOUNT, START_DATE, END_DATE,
        CONTRACT_STATUS, NOTES, CREATED_BY, CREATION_DATE,
        PARENT_FINANCING_ID
    ) VALUES (
        p_new_financing_id, v_customer_id, v_product_id, v_remaining_amount,
        v_profit_rate, v_profit_amount, v_total_amount, v_total_amount,
        p_new_installment_count, v_installment_amount, v_start_date, v_end_date,
        'APPROVED', 'إعادة جدولة للعقد رقم ' || p_financing_id || '. السبب: ' || p_reason,
        p_approved_by, SYSDATE, p_financing_id
    );
        
    -- إنشاء جدول الأقساط للعقد الجديد
    GENERATE_INSTALLMENT_SCHEDULE(p_new_financing_id);
        
    -- تغيير حالة العقد القديم إلى "معاد جدولته"
    UPDATE FINANCING_CONTRACTS
    SET
        CONTRACT_STATUS = 'RESCHEDULED',
        NOTES = NVL(NOTES, '') || CHR(10) || 'تمت إعادة جدولة هذا العقد إلى العقد رقم ' || p_new_financing_id || ' بتاريخ ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD'),
        LAST_UPDATE_DATE = SYSDATE,
        LAST_UPDATED_BY = p_approved_by
    WHERE
        FINANCING_ID = p_financing_id;
        
    -- إضافة سجل لتغيير الحالة للعقد القديم
    INSERT INTO FINANCING_STATUS_HISTORY (
        HISTORY_ID, FINANCING_ID, OLD_STATUS, NEW_STATUS,
        CHANGE_REASON, CHANGE_DATE, CHANGED_BY
    ) VALUES (
        SEQ_STATUS_HISTORY_ID.NEXTVAL, p_financing_id, v_contract_status, 'RESCHEDULED',
        'تمت إعادة جدولة العقد إلى العقد رقم ' || p_new_financing_id || '. السبب: ' || p_reason,
        SYSDATE, p_approved_by
    );
        
    -- إضافة سجل لتغيير الحالة للعقد الجديد
    INSERT INTO FINANCING_STATUS_HISTORY (
        HISTORY_ID, FINANCING_ID, OLD_STATUS, NEW_STATUS,
        CHANGE_REASON, CHANGE_DATE, CHANGED_BY
    ) VALUES (
        SEQ_STATUS_HISTORY_ID.NEXTVAL, p_new_financing_id, NULL, 'APPROVED',
        'إنشاء عقد جديد من إعادة جدولة العقد رقم ' || p_financing_id || '. السبب: ' || p_reason,
        SYSDATE, p_approved_by
    );
        
    -- نقل الضمانات من العقد القديم إلى العقد الجديد
    INSERT INTO FINANCING_COLLATERALS (
        FINANCING_COLLATERAL_ID, COLLATERAL_ID, CREATION_DATE, CREATED_BY
    )
    SELECT 
        p_new_financing_id, COLLATERAL_ID, SYSDATE, p_approved_by
    FROM 
        FINANCING_COLLATERALS
    WHERE 
        FINANCING_COLLATERAL_ID = p_financing_id;
        
    -- تحديث التزامات العميل المالية
    UPDATE CUSTOMER_FINANCIAL_OBLIGATIONS
    SET
        END_DATE = SYSDATE,
        LAST_UPDATE_DATE = SYSDATE
    WHERE 
        CUSTOMER_ID = v_customer_id AND
        OBLIGATION_TYPE = 'FINANCING' AND
        DESCRIPTION LIKE '%تمويل رقم ' || p_financing_id || '%';
        
    -- إضافة التزام مالي جديد للعقد المعاد جدولته
    INSERT INTO CUSTOMER_FINANCIAL_OBLIGATIONS (
        OBLIGATION_ID, CUSTOMER_ID, OBLIGATION_TYPE, ORIGINAL_AMOUNT,
        MONTHLY_PAYMENT, START_DATE, END_DATE, DESCRIPTION, CREATION_DATE
    ) VALUES (
        SEQ_OBLIGATION_ID.NEXTVAL, v_customer_id, 'FINANCING', v_remaining_amount,
        v_installment_amount, v_start_date, v_end_date,
        'تمويل رقم ' || p_new_financing_id || ' (إعادة جدولة للعقد رقم ' || p_financing_id || ')', SYSDATE
    );
        
    -- إرسال إشعار للعميل
    PKG_NOTIFICATIONS.SEND_CUSTOMER_NOTIFICATION(
        p_customer_id => v_customer_id,
        p_notification_type => 'FINANCING',
        p_notification_title => 'تمت إعادة جدولة عقد التمويل',
        p_notification_text => 'تمت إعادة جدولة عقد التمويل الخاص بك رقم ' || p_financing_id || ' إلى عقد جديد برقم ' || p_new_financing_id ||
                      ' بمبلغ متبقي ' || v_remaining_amount || ' وعدد أقساط ' || p_new_installment_count || ' قسط.',
        p_related_entity => 'FINANCING_CONTRACTS',
        p_related_entity_id => p_new_financing_id,
        p_notification_id => v_notification_id
    );
        
    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END RESCHEDULE_FINANCING;
     
    -- البحث عن عقود التمويل
    FUNCTION SEARCH_FINANCING_CONTRACTS(
        p_customer_id IN NUMBER DEFAULT NULL,
        p_product_id IN NUMBER DEFAULT NULL,
        p_status IN VARCHAR2 DEFAULT NULL,
        p_min_amount IN NUMBER DEFAULT NULL,
        p_max_amount IN NUMBER DEFAULT NULL,
        p_start_date_from IN DATE DEFAULT NULL,
        p_start_date_to IN DATE DEFAULT NULL,
        p_created_by IN NUMBER DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                fc.FINANCING_ID,
                fc.CUSTOMER_ID,
                c.FULL_NAME AS CUSTOMER_NAME,
                c.NATIONAL_ID AS CUSTOMER_NATIONAL_ID,
                fc.PRODUCT_ID,
                ip.PRODUCT_NAME,
                ip.PRODUCT_TYPE,
                fc.FINANCING_AMOUNT,
                fc.PROFIT_RATE,
                fc.PROFIT_AMOUNT,
                fc.TOTAL_AMOUNT,
                fc.REMAINING_AMOUNT,
                fc.INSTALLMENT_COUNT,
                fc.INSTALLMENT_AMOUNT,
                fc.START_DATE,
                fc.END_DATE,
                fc.CONTRACT_STATUS,
                fc.CREATION_DATE,
                u.USERNAME AS CREATED_BY_NAME,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID) AS TOTAL_INSTALLMENTS,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'PAID') AS PAID_INSTALLMENTS,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'OVERDUE') AS OVERDUE_INSTALLMENTS,
                (SELECT MIN(ins.DUE_DATE) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'UNPAID') AS NEXT_INSTALLMENT_DATE
            FROM 
                FINANCING_CONTRACTS fc
                JOIN CUSTOMERS c ON fc.CUSTOMER_ID = c.CUSTOMER_ID
                JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
                JOIN USERS u ON fc.CREATED_BY = u.USER_ID
            WHERE 
                (p_customer_id IS NULL OR fc.CUSTOMER_ID = p_customer_id) AND
                (p_product_id IS NULL OR fc.PRODUCT_ID = p_product_id) AND
                (p_status IS NULL OR fc.CONTRACT_STATUS = p_status) AND
                (p_min_amount IS NULL OR fc.FINANCING_AMOUNT >= p_min_amount) AND
                (p_max_amount IS NULL OR fc.FINANCING_AMOUNT <= p_max_amount) AND
                (p_start_date_from IS NULL OR fc.START_DATE >= p_start_date_from) AND
                (p_start_date_to IS NULL OR fc.START_DATE <= p_start_date_to) AND
                (p_created_by IS NULL OR fc.CREATED_BY = p_created_by)
            ORDER BY 
                fc.CREATION_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END SEARCH_FINANCING_CONTRACTS;
    
    -- الحصول على إحصائيات التمويل
    FUNCTION GET_FINANCING_STATISTICS(
        p_start_date IN DATE DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_start_date DATE := COALESCE(p_start_date, TRUNC(ADD_MONTHS(SYSDATE, -12)));
        v_end_date DATE := COALESCE(p_end_date, TRUNC(SYSDATE));
    BEGIN
        OPEN v_cursor FOR
            WITH status_counts AS (
                SELECT 
                    CONTRACT_STATUS,
                    COUNT(*) AS COUNT,
                    SUM(FINANCING_AMOUNT) AS TOTAL_AMOUNT,
                    SUM(REMAINING_AMOUNT) AS REMAINING_AMOUNT
                FROM 
                    FINANCING_CONTRACTS
                WHERE 
                    CREATION_DATE BETWEEN v_start_date AND v_end_date
                GROUP BY 
                    CONTRACT_STATUS
            ),
            product_counts AS (
                SELECT 
                    ip.PRODUCT_NAME,
                    ip.PRODUCT_TYPE,
                    COUNT(*) AS COUNT,
                    SUM(fc.FINANCING_AMOUNT) AS TOTAL_AMOUNT
                FROM 
                    FINANCING_CONTRACTS fc
                    JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
                WHERE 
                    fc.CREATION_DATE BETWEEN v_start_date AND v_end_date
                GROUP BY 
                    ip.PRODUCT_NAME, ip.PRODUCT_TYPE
            ),
            monthly_stats AS (
                SELECT 
                    TO_CHAR(CREATION_DATE, 'YYYY-MM') AS MONTH,
                    COUNT(*) AS COUNT,
                    SUM(FINANCING_AMOUNT) AS TOTAL_AMOUNT
                FROM 
                    FINANCING_CONTRACTS
                WHERE 
                    CREATION_DATE BETWEEN v_start_date AND v_end_date
                GROUP BY 
                    TO_CHAR(CREATION_DATE, 'YYYY-MM')
                ORDER BY 
                    TO_CHAR(CREATION_DATE, 'YYYY-MM')
            ),
            payment_stats AS (
                SELECT 
                    TO_CHAR(PAYMENT_DATE, 'YYYY-MM') AS MONTH,
                    COUNT(*) AS COUNT,
                    SUM(PAYMENT_AMOUNT) AS TOTAL_AMOUNT
                FROM 
                    PAYMENTS
                WHERE 
                    PAYMENT_DATE BETWEEN v_start_date AND v_end_date AND
                    PAYMENT_STATUS = 'COMPLETED'
                GROUP BY 
                    TO_CHAR(PAYMENT_DATE, 'YYYY-MM')
                ORDER BY 
                    TO_CHAR(PAYMENT_DATE, 'YYYY-MM')
            ),
            overdue_stats AS (
                SELECT 
                    COUNT(*) AS OVERDUE_COUNT,
                    SUM(REMAINING_AMOUNT) AS OVERDUE_AMOUNT
                FROM 
                    INSTALLMENT_SCHEDULE
                WHERE 
                    INSTALLMENT_STATUS = 'OVERDUE' AND
                    DUE_DATE BETWEEN v_start_date AND v_end_date
            )
            SELECT 
                'STATUS_COUNTS' AS STAT_TYPE,
                CONTRACT_STATUS AS CATEGORY,
                COUNT AS COUNT,
                TOTAL_AMOUNT AS AMOUNT,
                REMAINING_AMOUNT AS ADDITIONAL_AMOUNT,
                NULL AS MONTH
            FROM 
                status_counts
            UNION ALL
            SELECT 
                'PRODUCT_COUNTS' AS STAT_TYPE,
                PRODUCT_NAME || ' (' || PRODUCT_TYPE || ')' AS CATEGORY,
                COUNT AS COUNT,
                TOTAL_AMOUNT AS AMOUNT,
                NULL AS ADDITIONAL_AMOUNT,
                NULL AS MONTH
            FROM 
                product_counts
            UNION ALL
            SELECT 
                'MONTHLY_FINANCING' AS STAT_TYPE,
                NULL AS CATEGORY,
                COUNT AS COUNT,
                TOTAL_AMOUNT AS AMOUNT,
                NULL AS ADDITIONAL_AMOUNT,
                MONTH AS MONTH
            FROM 
                monthly_stats
            UNION ALL
            SELECT 
                'MONTHLY_PAYMENTS' AS STAT_TYPE,
                NULL AS CATEGORY,
                COUNT AS COUNT,
                TOTAL_AMOUNT AS AMOUNT,
                NULL AS ADDITIONAL_AMOUNT,
                MONTH AS MONTH
            FROM 
                payment_stats
            UNION ALL
            SELECT 
                'OVERDUE_SUMMARY' AS STAT_TYPE,
                'OVERDUE' AS CATEGORY,
                OVERDUE_COUNT AS COUNT,
                OVERDUE_AMOUNT AS AMOUNT,
                NULL AS ADDITIONAL_AMOUNT,
                NULL AS MONTH
            FROM 
                overdue_stats
            ORDER BY 
                STAT_TYPE, MONTH, CATEGORY;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_FINANCING_STATISTICS;
    
    -- تحديث جدول الأقساط
    PROCEDURE UPDATE_INSTALLMENT_SCHEDULE(
        p_financing_id IN NUMBER,
        p_regenerate_schedule IN BOOLEAN DEFAULT FALSE
    ) IS
    BEGIN
        IF p_regenerate_schedule THEN
            -- حذف جدول الأقساط الحالي وإعادة إنشائه
            DELETE FROM INSTALLMENT_SCHEDULE
            WHERE CONTRACT_ID = p_financing_id AND INSTALLMENT_STATUS = 'UNPAID';
            
            -- إعادة إنشاء جدول الأقساط
            GENERATE_INSTALLMENT_SCHEDULE(p_financing_id, TRUE);
        ELSE
            -- تحديث حالة الأقساط المتأخرة
            UPDATE INSTALLMENT_SCHEDULE
            SET
                INSTALLMENT_STATUS = 'OVERDUE',
                UPDATED_DATE = SYSDATE
            WHERE
                CONTRACT_ID = p_financing_id AND
                INSTALLMENT_STATUS = 'UNPAID' AND
                DUE_DATE < TRUNC(SYSDATE);
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_INSTALLMENT_SCHEDULE;
    
    -- إنشاء جدول الأقساط
    PROCEDURE GENERATE_INSTALLMENT_SCHEDULE(
        p_financing_id IN NUMBER,
        p_regenerate IN BOOLEAN DEFAULT FALSE
    ) IS
        v_financing_amount NUMBER;
        v_profit_amount NUMBER;
        v_total_amount NUMBER;
        v_installment_count NUMBER;
        v_installment_amount NUMBER;
        v_start_date DATE;
        v_end_date DATE;
        v_due_date DATE;
        v_principal_per_installment NUMBER;
        v_profit_per_installment NUMBER;
        v_existing_count NUMBER := 0;
        v_start_number NUMBER := 1;
    BEGIN
        -- الحصول على معلومات عقد التمويل
        SELECT 
            FINANCING_AMOUNT, PROFIT_AMOUNT, TOTAL_AMOUNT,
            INSTALLMENT_COUNT, INSTALLMENT_AMOUNT, START_DATE, END_DATE
        INTO 
            v_financing_amount, v_profit_amount, v_total_amount,
            v_installment_count, v_installment_amount, v_start_date, v_end_date
        FROM 
            FINANCING_CONTRACTS
        WHERE 
            FINANCING_ID = p_financing_id;
        
        -- حساب مبلغ الأصل والربح لكل قسط
        v_principal_per_installment := ROUND(v_financing_amount / v_installment_count, 2);
        v_profit_per_installment := ROUND(v_profit_amount / v_installment_count, 2);
        
        -- التحقق من وجود أقساط حالية
        IF NOT p_regenerate THEN
            SELECT COUNT(*) INTO v_existing_count
            FROM INSTALLMENT_SCHEDULE
            WHERE CONTRACT_ID = p_financing_id;
            
            IF v_existing_count > 0 THEN
                RETURN; -- جدول الأقساط موجود بالفعل
            END IF;
        ELSE
            -- إذا كنا نعيد إنشاء الجدول، نحصل على رقم القسط التالي
            SELECT NVL(MAX(INSTALLMENT_SEQ), 0) + 1 INTO v_start_number
            FROM INSTALLMENT_SCHEDULE
            WHERE CONTRACT_ID = p_financing_id AND INSTALLMENT_STATUS = 'PAID';
            
            -- تحديث تاريخ البدء ليكون الشهر التالي من آخر قسط مدفوع
            SELECT MAX(DUE_DATE) INTO v_due_date
            FROM INSTALLMENT_SCHEDULE
            WHERE CONTRACT_ID = p_financing_id AND INSTALLMENT_STATUS = 'PAID';
            
            IF v_due_date IS NOT NULL THEN
                v_start_date := ADD_MONTHS(v_due_date, 1);
            END IF;
        END IF;
        
        -- إنشاء جدول الأقساط
        FOR i IN v_start_number .. v_installment_count LOOP
            -- حساب تاريخ استحقاق القسط
            v_due_date := ADD_MONTHS(v_start_date, i - v_start_number);
            
            -- إدراج القسط في الجدول
            INSERT INTO INSTALLMENT_SCHEDULE (
                INSTALLMENT_ID, CONTRACT_ID, INSTALLMENT_SEQ,
                TOTAL_AMOUNT, PRINCIPAL_AMOUNT, PROFIT_AMOUNT,
                DUE_DATE, INSTALLMENT_STATUS, REMAINING_AMOUNT,
                CREATED_DATE
            ) VALUES (
                SEQ_INSTALLMENT_ID.NEXTVAL, p_financing_id, i,
                v_installment_amount, v_principal_per_installment, v_profit_per_installment,
                v_due_date, 'UNPAID', v_installment_amount,
                SYSDATE
            );
        END LOOP;
        
        -- تعديل القسط الأخير لمراعاة فروق التقريب
        DECLARE
            v_total_scheduled NUMBER;
            v_difference NUMBER;
            v_last_installment_id NUMBER;
        BEGIN
            -- حساب إجمالي المبلغ المجدول
            SELECT SUM(TOTAL_AMOUNT) INTO v_total_scheduled
            FROM INSTALLMENT_SCHEDULE
            WHERE CONTRACT_ID = p_financing_id;
            
            -- حساب الفرق
            v_difference := v_total_amount - v_total_scheduled;
            
            IF ABS(v_difference) > 0.01 THEN
                -- الحصول على معرف آخر قسط
                SELECT INSTALLMENT_ID INTO v_last_installment_id
                FROM INSTALLMENT_SCHEDULE
                WHERE CONTRACT_ID = p_financing_id AND INSTALLMENT_SEQ = v_installment_count;
                
                -- تعديل مبلغ آخر قسط
                UPDATE INSTALLMENT_SCHEDULE
                SET
                    TOTAL_AMOUNT = TOTAL_AMOUNT + v_difference,
                    PRINCIPAL_AMOUNT = PRINCIPAL_AMOUNT + v_difference,
                    REMAINING_AMOUNT = TOTAL_AMOUNT + v_difference
                WHERE
                    INSTALLMENT_ID = v_last_installment_id;
            END IF;
        END;
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_INSTALLMENT_SCHEDULE;
    
    -- تحديث المبلغ المتبقي في عقد التمويل
    PROCEDURE UPDATE_REMAINING_AMOUNT(p_financing_id IN NUMBER) IS
        v_remaining_amount NUMBER;
    BEGIN
        -- حساب المبلغ المتبقي من جدول الأقساط
        SELECT NVL(SUM(REMAINING_AMOUNT), 0)
        INTO v_remaining_amount
        FROM INSTALLMENT_SCHEDULE
        WHERE CONTRACT_ID = p_financing_id;
        
        -- تحديث المبلغ المتبقي في عقد التمويل
        UPDATE FINANCING_CONTRACTS
        SET
            REMAINING_AMOUNT = v_remaining_amount,
            LAST_UPDATE_DATE = SYSDATE
        WHERE
            FINANCING_ID = p_financing_id;
        
        -- التحقق مما إذا كان المبلغ المتبقي صفراً وتغيير حالة العقد إلى مكتمل
        IF v_remaining_amount = 0 THEN
            UPDATE FINANCING_CONTRACTS
            SET
                CONTRACT_STATUS = 'COMPLETED',
                LAST_UPDATE_DATE = SYSDATE
            WHERE
                FINANCING_ID = p_financing_id AND
                CONTRACT_STATUS = 'ACTIVE';
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_REMAINING_AMOUNT;
    
    -- إضافة ضمان لعقد التمويل
    PROCEDURE ADD_COLLATERAL(
        p_financing_id IN NUMBER,
        p_collateral_id IN NUMBER,
        p_added_by IN NUMBER
    ) IS
        v_contract_status VARCHAR2(50);
        v_collateral_exists NUMBER;
    BEGIN
        -- التحقق من حالة عقد التمويل
        SELECT CONTRACT_STATUS
        INTO v_contract_status
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_status NOT IN ('PENDING_APPROVAL', 'APPROVED', 'ACTIVE') THEN
            RAISE_APPLICATION_ERROR(-20029, 'لا يمكن إضافة ضمان لعقد تمويل في الحالة: ' || v_contract_status);
        END IF;
        
        -- التحقق من عدم وجود الضمان مسبقاً
        SELECT COUNT(*)
        INTO v_collateral_exists
        FROM FINANCING_COLLATERALS
        WHERE REQUEST_ID = p_financing_id AND COLLATERAL_ID = p_collateral_id;
        
        IF v_collateral_exists > 0 THEN
            RAISE_APPLICATION_ERROR(-20030, 'الضمان موجود بالفعل في هذا العقد');
        END IF;
        
        -- إضافة الضمان
        INSERT INTO FINANCING_COLLATERALS (
            FINANCING_COLLATERAL_ID, COLLATERAL_ID, CREATION_DATE, CREATED_BY
        ) VALUES (
            p_financing_id, p_collateral_id, SYSDATE, p_added_by
        );
        
        -- إضافة ملاحظة حول إضافة الضمان
        INSERT INTO FINANCING_NOTES (
            NOTE_ID, FINANCING_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_NOTE_ID.NEXTVAL, p_financing_id, 
            'تمت إضافة ضمان جديد برقم ' || p_collateral_id,
            p_added_by, SYSDATE
        );
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_COLLATERAL;
    
    -- إزالة ضمان من عقد التمويل
    PROCEDURE REMOVE_COLLATERAL(
        p_financing_id IN NUMBER,
        p_collateral_id IN NUMBER,
        p_reason IN VARCHAR2,
        p_removed_by IN NUMBER
    ) IS
        v_contract_status VARCHAR2(50);
        v_collateral_exists NUMBER;
    BEGIN
        -- التحقق من حالة عقد التمويل
        SELECT CONTRACT_STATUS
        INTO v_contract_status
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_status NOT IN ('PENDING_APPROVAL', 'APPROVED', 'ACTIVE') THEN
            RAISE_APPLICATION_ERROR(-20031, 'لا يمكن إزالة ضمان من عقد تمويل في الحالة: ' || v_contract_status);
        END IF;
        
        -- التحقق من وجود الضمان
        SELECT COUNT(*)
        INTO v_collateral_exists
        FROM FINANCING_COLLATERALS
        WHERE FINANCING_COLLATERAL_ID = p_financing_id AND COLLATERAL_ID = p_collateral_id;
        
        IF v_collateral_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20032, 'الضمان غير موجود في هذا العقد');
        END IF;
        
        -- إزالة الضمان
        DELETE FROM FINANCING_COLLATERALS
        WHERE FINANCING_COLLATERAL_ID = p_financing_id AND COLLATERAL_ID = p_collateral_id;
        
        -- إضافة ملاحظة حول إزالة الضمان
        INSERT INTO FINANCING_NOTES (
            NOTE_ID, FINANCING_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_NOTE_ID.NEXTVAL, p_financing_id, 
            'تمت إزالة الضمان رقم ' || p_collateral_id || '. السبب: ' || p_reason,
            p_removed_by, SYSDATE
        );
        
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END REMOVE_COLLATERAL;
    
    -- إضافة ملاحظة لعقد التمويل
    PROCEDURE ADD_NOTE(
        p_financing_id IN NUMBER,
        p_note_text IN VARCHAR2,
        p_created_by IN NUMBER
    ) IS
        v_contract_exists NUMBER;
    BEGIN
        -- التحقق من وجود العقد
        SELECT COUNT(*)
        INTO v_contract_exists
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        END IF;
        
        -- إضافة الملاحظة
        INSERT INTO FINANCING_NOTES (
            NOTE_ID, FINANCING_ID, NOTE_TEXT, CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_NOTE_ID.NEXTVAL, p_financing_id, p_note_text, p_created_by, SYSDATE
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_NOTE;
    
    -- الحصول على ملاحظات عقد التمويل
    FUNCTION GET_FINANCING_NOTES(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_contract_exists NUMBER;
    BEGIN
        -- التحقق من وجود العقد
        SELECT COUNT(*)
        INTO v_contract_exists
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                fn.NOTE_ID,
                fn.FINANCING_ID,
                fn.NOTE_TEXT,
                fn.CREATED_BY,
                u.USERNAME AS CREATED_BY_NAME,
                fn.CREATION_DATE
            FROM 
                FINANCING_NOTES fn
                JOIN USERS u ON fn.CREATED_BY = u.USER_ID
            WHERE 
                fn.FINANCING_ID = p_financing_id
            ORDER BY 
                fn.CREATION_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_FINANCING_NOTES;
    
    -- الحصول على تاريخ تغييرات حالة عقد التمويل
    FUNCTION GET_STATUS_HISTORY(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_contract_exists NUMBER;
    BEGIN
        -- التحقق من وجود العقد
        SELECT COUNT(*)
        INTO v_contract_exists
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                fsh.HISTORY_ID,
                fsh.FINANCING_ID,
                fsh.OLD_STATUS,
                fsh.NEW_STATUS,
                fsh.CHANGE_REASON,
                fsh.CHANGE_DATE,
                fsh.CHANGED_BY,
                u.USERNAME AS CHANGED_BY_NAME
            FROM 
                FINANCING_STATUS_HISTORY fsh
                JOIN USERS u ON fsh.CHANGED_BY = u.USER_ID
            WHERE 
                fsh.FINANCING_ID = p_financing_id
            ORDER BY 
                fsh.CHANGE_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_STATUS_HISTORY;
    
    -- الحصول على الضمانات المرتبطة بعقد التمويل
    FUNCTION GET_FINANCING_COLLATERALS(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_contract_exists NUMBER;
    BEGIN
        -- التحقق من وجود العقد
        SELECT COUNT(*)
        INTO v_contract_exists
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                fc.FINANCING_COLLATERAL_ID,
                fc.COLLATERAL_ID,
                c.COLLATERAL_TYPE,
                c.ESTIMATED_VALUE,
                c.COLLATERAL_DESCRIPTION AS COLLATERAL_DESCRIPTION,
                c.CUSTOMER_ID,
                cu.FULL_NAME AS CUSTOMER_NAME,
                fc.CREATION_DATE,
                fc.CREATED_BY,
                u.USERNAME AS ADDED_BY_NAME
            FROM 
                FINANCING_COLLATERALS fc
                JOIN COLLATERALS c ON fc.COLLATERAL_ID = c.COLLATERAL_ID
                JOIN CUSTOMERS cu ON c.CUSTOMER_ID = cu.CUSTOMER_ID
                JOIN USERS u ON fc.CREATED_BY = u.USER_ID
            WHERE 
                fc.FINANCING_COLLATERAL_ID = p_financing_id
            ORDER BY 
                fc.CREATION_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_FINANCING_COLLATERALS;
    
    -- الحصول على دفعات عقد التمويل
    FUNCTION GET_FINANCING_PAYMENTS(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_contract_exists NUMBER;
    BEGIN
        -- التحقق من وجود العقد
        SELECT COUNT(*)
        INTO v_contract_exists
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                p.PAYMENT_ID,
                p.FINANCING_ID,
                p.INSTALLMENT_ID,
                ins.INSTALLMENT_SEQ,
                p.PAYMENT_AMOUNT,
                p.PAYMENT_METHOD,
                p.PAYMENT_DATE,
                p.PAYMENT_STATUS,
                p.REFERENCE_NUMBER,
                p.NOTES,
                p.CREATED_BY,
                u1.USERNAME AS CREATED_BY_NAME,
                p.CREATION_DATE,
                p.CANCELLATION_REASON,
                p.CANCELLED_BY,
                u2.USERNAME AS CANCELLED_BY_NAME,
                p.CANCELLATION_DATE
            FROM 
                PAYMENTS p
                JOIN INSTALLMENT_SCHEDULE ins ON p.INSTALLMENT_ID = ins.INSTALLMENT_ID
                JOIN USERS u1 ON p.CREATED_BY = u1.USER_ID
                LEFT JOIN USERS u2 ON p.CANCELLED_BY = u2.USER_ID
            WHERE 
                p.FINANCING_ID = p_financing_id
            ORDER BY 
                p.PAYMENT_DATE DESC, p.CREATION_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_FINANCING_PAYMENTS;
    
    -- تحديث الأقساط المتأخرة لجميع عقود التمويل
    PROCEDURE UPDATE_OVERDUE_INSTALLMENTS IS
        v_count NUMBER := 0;
        ERR_MSG VARCHAR2(1001);
    BEGIN
        -- تحديث حالة الأقساط المتأخرة
        UPDATE INSTALLMENT_SCHEDULE
        SET
            INSTALLMENT_STATUS = 'OVERDUE',
            UPDATED_DATE = SYSDATE
        WHERE
            INSTALLMENT_STATUS = 'UNPAID' AND
            DUE_DATE < TRUNC(SYSDATE);
        
        v_count := SQL%ROWCOUNT;
        
        -- تسجيل عدد الأقساط التي تم تحديثها
        INSERT INTO SYSTEM_LOGS (
            LOG_ID, LOG_TYPE, LOG_MESSAGE, CREATION_DATE
        ) VALUES (
            SEQ_LOG_ID.NEXTVAL, 'FINANCING', 'تم تحديث ' || v_count || ' قسط متأخر', SYSDATE
        );
        
        -- تحديث حالة العقود المتعثرة (إذا كان هناك أكثر من 3 أقساط متأخرة)
        FOR rec IN (
            SELECT 
                fc.FINANCING_ID, 
                fc.CUSTOMER_ID,
                COUNT(*) AS OVERDUE_COUNT
            FROM 
                FINANCING_CONTRACTS fc
                JOIN INSTALLMENT_SCHEDULE ins ON fc.FINANCING_ID = ins.CONTRACT_ID
            WHERE 
                fc.CONTRACT_STATUS = 'ACTIVE' AND
                ins.INSTALLMENT_STATUS = 'OVERDUE'
            GROUP BY 
                fc.FINANCING_ID, fc.CUSTOMER_ID
            HAVING 
                COUNT(*) >= 3
        ) LOOP
            -- تغيير حالة العقد إلى متعثر
            CHANGE_CONTRACT_STATUS(
                p_financing_id => rec.FINANCING_ID,
                p_new_status => 'DEFAULTED',
                p_reason => 'تجاوز عدد الأقساط المتأخرة الحد المسموح به (' || rec.OVERDUE_COUNT || ' أقساط)',
                p_updated_by => 1  -- معرف المستخدم النظامي
            );
            
            -- تحديث التصنيف الائتماني للعميل
            PKG_CREDIT_RATING.UPDATE_CUSTOMER_RATING(rec.CUSTOMER_ID);
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            ERR_MSG:= 'خطأ في تحديث الأقساط المتأخرة: ' || TO_CHAR(SQLERRM);
            -- تسجيل الخطأ
            INSERT INTO SYSTEM_LOGS (
                LOG_ID, LOG_TYPE, LOG_MESSAGE, CREATION_DATE
            ) VALUES (
                SEQ_LOG_ID.NEXTVAL, 'ERROR',ERR_MSG, SYSDATE
            );
            
            COMMIT;
            RAISE;
    END UPDATE_OVERDUE_INSTALLMENTS;
    
    -- الحصول على تفاصيل عقد التمويل
    -- الحصول على تفاصيل عقد التمويل
FUNCTION GET_FINANCING_DETAILS(p_financing_id IN NUMBER) RETURN SYS_REFCURSOR IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT 
             fc.FINANCING_ID,
            fc.CUSTOMER_ID,
            c.FULL_NAME AS CUSTOMER_NAME,
            c.NATIONAL_ID AS CUSTOMER_NATIONAL_ID,
            c.MOBILE_NUMBER AS CUSTOMER_MOBILE,
            c.EMAIL AS CUSTOMER_EMAIL,
            fc.PRODUCT_ID,
            ip.PRODUCT_NAME,
            ip.PRODUCT_TYPE,
            fc.FINANCING_AMOUNT,
            fc.PROFIT_RATE,
            fc.PROFIT_AMOUNT,
            fc.TOTAL_AMOUNT,
            fc.REMAINING_AMOUNT,
            fc.INSTALLMENT_COUNT,
            fc.INSTALLMENT_AMOUNT,
            fc.START_DATE,
            fc.END_DATE,
            fc.CONTRACT_STATUS,
            fc.CONTRACT_NUMBER,
            fc.NOTES,
            fc.PARENT_FINANCING_ID,
            (SELECT fc2.CONTRACT_NUMBER FROM FINANCING_CONTRACTS fc2 WHERE fc2.FINANCING_ID = fc.PARENT_FINANCING_ID) AS PARENT_CONTRACT_NUMBER,
            fc.CREATED_BY,
            u1.USERNAME AS CREATED_BY_NAME,
            fc.CREATION_DATE,
            fc.LAST_UPDATED_BY,
            u2.USERNAME AS LAST_UPDATED_BY_NAME,
            fc.LAST_UPDATE_DATE,
            (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID) AS TOTAL_INSTALLMENTS,
            (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'PAID') AS PAID_INSTALLMENTS,
            (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'OVERDUE') AS OVERDUE_INSTALLMENTS,
            (SELECT COUNT(*) FROM FINANCING_COLLATERALS fcol WHERE fcol.FINANCING_COLLATERAL_ID = fc.FINANCING_ID) AS COLLATERAL_COUNT,
            (SELECT SUM(col.ESTIMATED_VALUE) FROM FINANCING_COLLATERALS fcol JOIN COLLATERALS col ON fcol.COLLATERAL_ID = col.COLLATERAL_ID WHERE fcol.FINANCING_COLLATERAL_ID = fc.FINANCING_ID) AS TOTAL_COLLATERAL_VALUE,
            (SELECT MIN(ins.DUE_DATE) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'UNPAID') AS NEXT_INSTALLMENT_DATE,
            (SELECT ins.TOTAL_AMOUNT FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'UNPAID' ORDER BY ins.DUE_DATE FETCH FIRST 1 ROW ONLY) AS NEXT_INSTALLMENT_AMOUNT,
            (SELECT SUM(p.PAYMENT_AMOUNT) FROM PAYMENTS p WHERE p.FINANCING_ID = fc.FINANCING_ID AND p.PAYMENT_STATUS = 'COMPLETED') AS TOTAL_PAYMENTS,
            (SELECT MAX(p.PAYMENT_DATE) FROM PAYMENTS p WHERE p.FINANCING_ID = fc.FINANCING_ID AND p.PAYMENT_STATUS = 'COMPLETED') AS LAST_PAYMENT_DATE,
            (SELECT SUM(ins.LATE_FEES) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID) AS TOTAL_LATE_FEES
        FROM 
             FINANCING_CONTRACTS fc
            JOIN CUSTOMERS c ON fc.CUSTOMER_ID = c.CUSTOMER_ID
            JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
            JOIN USERS u1 ON fc.CREATED_BY = u1.USER_ID
            LEFT JOIN USERS u2 ON fc.LAST_UPDATED_BY = u2.USER_ID
        WHERE 
             fc.FINANCING_ID = p_financing_id;
            
    RETURN v_cursor;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20014, 'عقد التمويل غير موجود برقم: ' || p_financing_id);
    WHEN OTHERS THEN
        RAISE;
END GET_FINANCING_DETAILS;

    -- الحصول على عقود التمويل للعميل
    FUNCTION GET_CUSTOMER_FINANCINGS(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*)
        INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20033, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                fc.FINANCING_ID,
                fc.CONTRACT_NUMBER,
                fc.PRODUCT_ID,
                ip.PRODUCT_NAME,
                ip.PRODUCT_TYPE,
                fc.FINANCING_AMOUNT,
                fc.TOTAL_AMOUNT,
                fc.REMAINING_AMOUNT,
                fc.INSTALLMENT_COUNT,
                fc.INSTALLMENT_AMOUNT,
                fc.START_DATE,
                fc.END_DATE,
                fc.CONTRACT_STATUS,
                fc.CREATION_DATE,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID) AS TOTAL_INSTALLMENTS,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'PAID') AS PAID_INSTALLMENTS,
                (SELECT COUNT(*) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'OVERDUE') AS OVERDUE_INSTALLMENTS,
                (SELECT MIN(ins.DUE_DATE) FROM INSTALLMENT_SCHEDULE ins WHERE ins.CONTRACT_ID = fc.FINANCING_ID AND ins.INSTALLMENT_STATUS = 'UNPAID') AS NEXT_INSTALLMENT_DATE,
                (SELECT MAX(p.PAYMENT_DATE) FROM PAYMENTS p WHERE p.FINANCING_ID = fc.FINANCING_ID AND p.PAYMENT_STATUS = 'COMPLETED') AS LAST_PAYMENT_DATE
            FROM 
                FINANCING_CONTRACTS fc
                JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
            WHERE 
                fc.CUSTOMER_ID = p_customer_id
            ORDER BY 
                fc.CREATION_DATE DESC;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMER_FINANCINGS;
    
    -- الحصول على الأقساط المستحقة للعميل
    FUNCTION GET_CUSTOMER_DUE_INSTALLMENTS(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*)
        INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20033, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        OPEN v_cursor FOR
            SELECT 
                ins.INSTALLMENT_ID,
                ins.REQUEST_ID,
                fc.CONTRACT_NUMBER,
                ip.PRODUCT_NAME,
                ins.INSTALLMENT_SEQ,
                ins.TOTAL_AMOUNT,
                ins.DUE_DATE,
                ins.INSTALLMENT_STATUS,
                ins.REMAINING_AMOUNT,
                ins.LATE_FEES,
                CASE 
                    WHEN ins.INSTALLMENT_STATUS = 'UNPAID' AND ins.DUE_DATE < SYSDATE THEN
                        TRUNC(SYSDATE) - TRUNC(ins.DUE_DATE)
                    ELSE 0
                END AS DAYS_OVERDUE
            FROM 
                INSTALLMENT_SCHEDULE ins
                JOIN FINANCING_CONTRACTS fc ON ins.CONTRACT_ID = fc.FINANCING_ID
                JOIN ISLAMIC_PRODUCTS ip ON fc.PRODUCT_ID = ip.PRODUCT_ID
            WHERE 
                fc.CUSTOMER_ID = p_customer_id AND
                ins.INSTALLMENT_STATUS IN ('UNPAID', 'OVERDUE') AND
                fc.CONTRACT_STATUS IN ('ACTIVE', 'DEFAULTED')
            ORDER BY 
                ins.DUE_DATE;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END GET_CUSTOMER_DUE_INSTALLMENTS;
    
    -- حساب إجمالي المديونية للعميل
    FUNCTION CALCULATE_CUSTOMER_DEBT(p_customer_id IN NUMBER) RETURN NUMBER IS
        v_total_debt NUMBER := 0;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*)
        INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20033, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- حساب إجمالي المديونية من عقود التمويل النشطة
        SELECT NVL(SUM(REMAINING_AMOUNT), 0)
        INTO v_total_debt
        FROM FINANCING_CONTRACTS
        WHERE CUSTOMER_ID = p_customer_id AND CONTRACT_STATUS IN ('ACTIVE', 'DEFAULTED');
        
        RETURN v_total_debt;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END CALCULATE_CUSTOMER_DEBT;
    
    -- حساب نسبة الأقساط الشهرية إلى الدخل
    FUNCTION CALCULATE_DTI_RATIO(p_customer_id IN NUMBER) RETURN NUMBER IS
        v_monthly_income NUMBER;
        v_monthly_obligations NUMBER := 0;
        v_dti_ratio NUMBER := 0;
        v_customer_exists NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*)
        INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20033, 'العميل غير موجود برقم: ' || p_customer_id);
        END IF;
        
        -- الحصول على الدخل الشهري للعميل
        SELECT NVL(MONTHLY_INCOME, 0)
        INTO v_monthly_income
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        -- حساب إجمالي الالتزامات الشهرية
        SELECT NVL(SUM(MONTHLY_PAYMENT), 0)
        INTO v_monthly_obligations
        FROM CUSTOMER_FINANCIAL_OBLIGATIONS
        WHERE CUSTOMER_ID = p_customer_id AND END_DATE > SYSDATE;
        
        -- حساب نسبة الأقساط إلى الدخل
        IF v_monthly_income > 0 THEN
            v_dti_ratio := (v_monthly_obligations / v_monthly_income) * 100;
        ELSE
            v_dti_ratio := 0;
        END IF;
        
        RETURN v_dti_ratio;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END CALCULATE_DTI_RATIO;
    
    -- التحقق من أهلية العميل للتمويل
    FUNCTION CHECK_FINANCING_ELIGIBILITY(
        p_customer_id IN NUMBER,
        p_financing_amount IN NUMBER,
        p_installment_count IN NUMBER,
        p_product_id IN NUMBER
    ) RETURN VARCHAR2 IS
        v_customer_exists NUMBER;
        v_product_exists NUMBER;
        v_monthly_income NUMBER;
        v_credit_score NUMBER;
        v_dti_ratio NUMBER;
        v_max_dti_ratio NUMBER := 50; -- الحد الأقصى لنسبة الأقساط إلى الدخل
        v_min_credit_score NUMBER := 600; -- الحد الأدنى للتصنيف الائتماني
        v_monthly_installment NUMBER;
        v_new_dti_ratio NUMBER;
        v_result VARCHAR2(4000);
        v_profit_rate NUMBER;
        v_total_amount NUMBER;
    BEGIN
        -- التحقق من وجود العميل
        SELECT COUNT(*)
        INTO v_customer_exists
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        IF v_customer_exists = 0 THEN
            RETURN 'غير مؤهل: العميل غير موجود';
        END IF;
        
        -- التحقق من وجود المنتج
        SELECT COUNT(*)
        INTO v_product_exists
        FROM ISLAMIC_PRODUCTS
        WHERE PRODUCT_ID = p_product_id AND PRODUCT_STATUS = 'ACTIVE';
        
        IF v_product_exists = 0 THEN
            RETURN 'غير مؤهل: المنتج غير موجود أو غير نشط';
        END IF;
        
        -- الحصول على معلومات العميل
        SELECT NVL(MONTHLY_INCOME, 0), NVL(CREDIT_SCORE, 0)
        INTO v_monthly_income, v_credit_score
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
        
        -- الحصول على معدل الربح للمنتج
        SELECT PROFIT_RATE
        INTO v_profit_rate
        FROM ISLAMIC_PRODUCTS
        WHERE PRODUCT_ID = p_product_id;
        
        -- حساب إجمالي المبلغ مع الربح
        v_total_amount := p_financing_amount * (1 + (v_profit_rate / 100) * (p_installment_count / 12));
        
        -- حساب القسط الشهري
        v_monthly_installment := v_total_amount / p_installment_count;
        
        -- حساب نسبة الأقساط الحالية إلى الدخل
        v_dti_ratio := CALCULATE_DTI_RATIO(p_customer_id);
        
        -- حساب نسبة الأقساط الجديدة إلى الدخل
        IF v_monthly_income > 0 THEN
            v_new_dti_ratio := v_dti_ratio + ((v_monthly_installment / v_monthly_income) * 100);
        ELSE
            v_new_dti_ratio := 100; -- إذا كان الدخل صفر، فنسبة الأقساط إلى الدخل ستكون 100%
        END IF;
        
        -- التحقق من الأهلية
        v_result := 'مؤهل للتمويل';
        
        -- التحقق من التصنيف الائتماني
        IF v_credit_score < v_min_credit_score THEN
            v_result := 'غير مؤهل: التصنيف الائتماني منخفض (' || v_credit_score || '). الحد الأدنى المطلوب: ' || v_min_credit_score;
            RETURN v_result;
        END IF;
        
        -- التحقق من نسبة الأقساط إلى الدخل
        IF v_new_dti_ratio > v_max_dti_ratio THEN
            v_result := 'غير مؤهل: نسبة الأقساط إلى الدخل مرتفعة (' || ROUND(v_new_dti_ratio, 2) || '%). الحد الأقصى المسموح: ' || v_max_dti_ratio || '%';
            RETURN v_result;
        END IF;
        
        -- إضافة معلومات إضافية
        v_result := v_result || CHR(10) || 
                   'الدخل الشهري: ' || v_monthly_income || CHR(10) ||
                   'التصنيف الائتماني: ' || v_credit_score || CHR(10) ||
                   'نسبة الأقساط الحالية إلى الدخل: ' || ROUND(v_dti_ratio, 2) || '%' || CHR(10) ||
                   'نسبة الأقساط المتوقعة إلى الدخل بعد التمويل الجديد: ' || ROUND(v_new_dti_ratio, 2) || '%' || CHR(10) ||
                   'القسط الشهري المتوقع: ' || ROUND(v_monthly_installment, 2);
        
        RETURN v_result;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'خطأ في التحقق من الأهلية: ' || SQLERRM;
    END CHECK_FINANCING_ELIGIBILITY;
    
    -- إنشاء رقم عقد فريد
    FUNCTION GENERATE_CONTRACT_NUMBER(
        p_product_id IN NUMBER,
        p_customer_id IN NUMBER
    ) RETURN VARCHAR2 IS
        v_product_code VARCHAR2(10);
        v_year VARCHAR2(2);
        v_sequence NUMBER;
        v_contract_number VARCHAR2(20);
    BEGIN
        -- الحصول على رمز المنتج
        SELECT SUBSTR(PRODUCT_CODE, 1, 3)
        INTO v_product_code
        FROM ISLAMIC_PRODUCTS
        WHERE PRODUCT_ID = p_product_id;
        
        -- الحصول على السنة الحالية (آخر رقمين)
        v_year := TO_CHAR(SYSDATE, 'YY');
        
        -- الحصول على رقم تسلسلي جديد
        SELECT NVL(MAX(TO_NUMBER(REGEXP_SUBSTR(CONTRACT_NUMBER, '[0-9]+$'))), 0) + 1
        INTO v_sequence
        FROM FINANCING_CONTRACTS
        WHERE CONTRACT_NUMBER LIKE v_product_code || v_year || '%';
        
        -- إنشاء رقم العقد
        v_contract_number := v_product_code || v_year || LPAD(v_sequence, 6, '0');
        
        RETURN v_contract_number;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20034, 'المنتج غير موجود برقم: ' || p_product_id);
        WHEN OTHERS THEN
            RAISE;
    END GENERATE_CONTRACT_NUMBER;
    ---
    -- إضافة إجراء جديد: تسوية مبكرة للتمويل
    PROCEDURE EARLY_SETTLEMENT(
        p_financing_id IN NUMBER,
        p_settlement_date IN DATE,
        p_settlement_amount IN NUMBER,
        p_discount_amount IN NUMBER,
        p_settlement_reason IN VARCHAR2,
        p_payment_method IN VARCHAR2,
        p_payment_reference IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
        v_contract_status VARCHAR2(20);
        v_remaining_amount NUMBER;
        v_payment_id NUMBER;
    BEGIN
        p_success := FALSE;
        
        -- التحقق من حالة عقد التمويل
        SELECT CONTRACT_STATUS, REMAINING_AMOUNT
        INTO v_contract_status, v_remaining_amount
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        IF v_contract_status <> 'ACTIVE' THEN
            p_error_message := 'لا يمكن إجراء تسوية مبكرة لعقد تمويل غير نشط';
            RETURN;
        END IF;
        
        -- تسجيل عملية التسوية المبكرة
        INSERT INTO EARLY_SETTLEMENTS (
            FINANCING_ID, SETTLEMENT_DATE, ORIGINAL_REMAINING, SETTLEMENT_AMOUNT,
            DISCOUNT_AMOUNT, SETTLEMENT_REASON, CREATED_BY, CREATION_DATE
        ) VALUES (
            p_financing_id, p_settlement_date, v_remaining_amount, p_settlement_amount,
            p_discount_amount, p_settlement_reason, p_updated_by, SYSTIMESTAMP
        );
        
        -- تسجيل الدفعة
        INSERT INTO PAYMENTS (
            PAYMENT_ID, FINANCING_ID, INSTALLMENT_ID, PAYMENT_AMOUNT,
            PAYMENT_METHOD, PAYMENT_REFERENCE, PAYMENT_DATE, PAYMENT_TYPE, PAYMENT_STATUS,
            CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_PAYMENT_ID.NEXTVAL, p_financing_id, NULL, p_settlement_amount,
            p_payment_method, p_payment_reference, p_settlement_date, 'EARLY_SETTLEMENT', 'COMPLETED',
            p_updated_by, SYSTIMESTAMP
        )
        RETURNING PAYMENT_ID INTO v_payment_id;
        
        -- حذف الأقساط المستقبلية غير المدفوعة
        DELETE FROM INSTALLMENT_SCHEDULE
        WHERE CONTRACT_ID = p_financing_id
        AND INSTALLMENT_STATUS = 'PENDING';
        
        -- تحديث عقد التمويل
        UPDATE FINANCING_CONTRACTS
        SET CONTRACT_STATUS = 'COMPLETED',
            REMAINING_AMOUNT = 0,
            COMPLETION_DATE = p_settlement_date,
            LAST_UPDATED_BY = p_updated_by,
            LAST_UPDATE_DATE = SYSTIMESTAMP
        WHERE FINANCING_ID = p_financing_id;
        
        p_success := TRUE;
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            p_error_message := SQLERRM;
            ROLLBACK;
    END EARLY_SETTLEMENT;
    ---
    
END PKG_FINANCING;
/


CREATE OR REPLACE PACKAGE BODY                PKG_FINANCING_REQUESTS AS
    -- إنشاء طلب تمويل جديد
    PROCEDURE CREATE_REQUEST(
        p_customer_id IN NUMBER,
        p_product_id IN NUMBER,
        p_requested_amount IN NUMBER,
        p_financing_period IN NUMBER,
        p_created_by IN VARCHAR2,
        p_request_id OUT NUMBER
    ) IS
        v_first_stage_id NUMBER;
    BEGIN
        -- الحصول على أول مرحلة للمنتج
        SELECT MIN(STAGE_ID) INTO v_first_stage_id
        FROM PRODUCT_STAGES
        WHERE PRODUCT_ID = p_product_id
        AND STAGE_ORDER = 1;
        
        -- إنشاء طلب جديد
        SELECT SEQ_REQUEST_ID.NEXTVAL INTO p_request_id FROM DUAL;
        
        INSERT INTO FINANCING_REQUESTS (
            REQUEST_ID, CUSTOMER_ID, PRODUCT_ID, CURRENT_STAGE_ID,
            REQUESTED_AMOUNT, FINANCING_PERIOD, REQUEST_STATUS,
            CREATED_DATE, CREATED_BY
        ) VALUES (
            p_request_id, p_customer_id, p_product_id, v_first_stage_id,
            p_requested_amount, p_financing_period, 'NEW',
            SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_REQUEST;
    
    -- تحديث حالة الطلب
    PROCEDURE UPDATE_REQUEST_STATUS(
        p_request_id IN NUMBER,
        p_request_status IN VARCHAR2,
        p_approved_amount IN NUMBER,
        p_profit_rate IN NUMBER,
        p_updated_by IN VARCHAR2
    ) IS
    BEGIN
        UPDATE FINANCING_REQUESTS
        SET REQUEST_STATUS = p_request_status,
            APPROVED_AMOUNT = p_approved_amount,
            PROFIT_RATE = p_profit_rate,
            UPDATED_DATE = SYSDATE,
            UPDATED_BY = p_updated_by,
            APPROVAL_DATE = CASE WHEN p_request_status = 'APPROVED' THEN SYSDATE ELSE APPROVAL_DATE END
        WHERE REQUEST_ID = p_request_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_REQUEST_STATUS;
    
    -- إضافة ضمان للطلب
    PROCEDURE ADD_REQUEST_COLLATERAL(
        p_request_id IN NUMBER,
        p_collateral_id IN NUMBER,
        p_coverage_ratio IN NUMBER,
        p_created_by IN VARCHAR2,
        p_request_collateral_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_REQUEST_COLLATERAL_ID.NEXTVAL INTO p_request_collateral_id FROM DUAL;
        
        INSERT INTO REQUEST_COLLATERALS (
            REQUEST_COLLATERAL_ID, REQUEST_ID, COLLATERAL_ID,
            COVERAGE_RATIO, CREATED_DATE, CREATED_BY
        ) VALUES (
            p_request_collateral_id, p_request_id, p_collateral_id,
            p_coverage_ratio, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_REQUEST_COLLATERAL;
    
    -- تحديث مرحلة الطلب
    PROCEDURE UPDATE_REQUEST_STAGE(
        p_request_id IN NUMBER,
        p_stage_id IN NUMBER,
        p_updated_by IN VARCHAR2
    ) IS
    BEGIN
        UPDATE FINANCING_REQUESTS
        SET CURRENT_STAGE_ID = p_stage_id,
            UPDATED_DATE = SYSDATE,
            UPDATED_BY = p_updated_by
        WHERE REQUEST_ID = p_request_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_REQUEST_STAGE;
    
    -- صرف التمويل
    PROCEDURE DISBURSE_FINANCING(
        p_request_id IN NUMBER,
        p_disbursement_date IN DATE,
        p_updated_by IN VARCHAR2
    ) IS
    BEGIN
        UPDATE FINANCING_REQUESTS
        SET DISBURSEMENT_DATE = p_disbursement_date,
            REQUEST_STATUS = 'DISBURSED',
            UPDATED_DATE = SYSDATE,
            UPDATED_BY = p_updated_by
        WHERE REQUEST_ID = p_request_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END DISBURSE_FINANCING;
    
    -- الحصول على معلومات الطلب
    FUNCTION GET_REQUEST_INFO(p_request_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT r.*, c.FULL_NAME AS CUSTOMER_NAME, p.PRODUCT_NAME, s.STAGE_NAME
            FROM FINANCING_REQUESTS r
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            LEFT JOIN PRODUCT_STAGES s ON r.CURRENT_STAGE_ID = s.STAGE_ID
            WHERE r.REQUEST_ID = p_request_id;
        RETURN v_cursor;
    END GET_REQUEST_INFO;
    
    -- الحصول على ضمانات الطلب
    FUNCTION GET_REQUEST_COLLATERALS(p_request_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT rc.*, c.COLLATERAL_TYPE, c.ESTIMATED_VALUE, c.COLLATERAL_DESCRIPTION
            FROM REQUEST_COLLATERALS rc
            JOIN COLLATERALS c ON rc.COLLATERAL_ID = c.COLLATERAL_ID
            WHERE rc.REQUEST_ID = p_request_id;
        RETURN v_cursor;
    END GET_REQUEST_COLLATERALS;
    
    -- الحصول على طلبات العميل
    FUNCTION GET_CUSTOMER_REQUESTS(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT r.*, p.PRODUCT_NAME, s.STAGE_NAME
            FROM FINANCING_REQUESTS r
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            LEFT JOIN PRODUCT_STAGES s ON r.CURRENT_STAGE_ID = s.STAGE_ID
            WHERE r.CUSTOMER_ID = p_customer_id
            ORDER BY r.REQUEST_DATE DESC;
        RETURN v_cursor;
    END GET_CUSTOMER_REQUESTS;
    
    -- الحصول على طلبات المنتج
    FUNCTION GET_PRODUCT_REQUESTS(p_product_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT r.*, c.FULL_NAME AS CUSTOMER_NAME, s.STAGE_NAME
            FROM FINANCING_REQUESTS r
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            LEFT JOIN PRODUCT_STAGES s ON r.CURRENT_STAGE_ID = s.STAGE_ID
            WHERE r.PRODUCT_ID = p_product_id
            ORDER BY r.REQUEST_DATE DESC;
        RETURN v_cursor;
    END GET_PRODUCT_REQUESTS;
END PKG_FINANCING_REQUESTS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_INSTALLMENT_SCHEDULE AS
    -- إنشاء جدول الأقساط
    PROCEDURE CREATE_SCHEDULE(
        p_request_id IN NUMBER,
        p_start_date IN DATE,
        p_created_by IN VARCHAR2
    ) IS
        v_approved_amount NUMBER;
        v_financing_period NUMBER;
        v_profit_rate NUMBER;
        v_principal_per_installment NUMBER;
        v_total_profit NUMBER;
        v_profit_per_installment NUMBER;
        v_installment_date DATE;
        v_installment_id NUMBER;
    BEGIN
        -- الحصول على معلومات الطلب
        SELECT APPROVED_AMOUNT, FINANCING_PERIOD, PROFIT_RATE
        INTO v_approved_amount, v_financing_period, v_profit_rate
        FROM FINANCING_REQUESTS
        WHERE REQUEST_ID = p_request_id;
        
        -- حساب المبلغ الأساسي لكل قسط
        v_principal_per_installment := v_approved_amount / v_financing_period;
        
        -- حساب إجمالي الربح (بطريقة بسيطة - يمكن تعديلها حسب نوع المنتج)
        v_total_profit := v_approved_amount * (v_profit_rate / 100) * (v_financing_period / 12);
        
        -- حساب الربح لكل قسط
        v_profit_per_installment := v_total_profit / v_financing_period;
        
        -- إنشاء الأقساط
        v_installment_date := p_start_date;
        
        FOR i IN 1..v_financing_period LOOP
            SELECT SEQ_INSTALLMENT_ID.NEXTVAL INTO v_installment_id FROM DUAL;
            
            INSERT INTO INSTALLMENT_SCHEDULE (
                INSTALLMENT_ID, REQUEST_ID, INSTALLMENT_seq, DUE_DATE,
                PRINCIPAL_AMOUNT, PROFIT_AMOUNT, TOTAL_AMOUNT,
                INSTALLMENT_STATUS, CREATED_DATE, CREATED_BY
            ) VALUES (
                v_installment_id, p_request_id, i, v_installment_date,
                v_principal_per_installment, v_profit_per_installment, 
                (v_principal_per_installment + v_profit_per_installment),
                'SCHEDULED', SYSDATE, p_created_by
            );
            
            -- تحديث تاريخ القسط التالي (شهر واحد)
            v_installment_date := ADD_MONTHS(v_installment_date, 1);
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_SCHEDULE;
    
    -- تحديث حالة القسط
    PROCEDURE UPDATE_INSTALLMENT_STATUS(
        p_installment_id IN NUMBER,
        p_installment_status IN VARCHAR2,
        p_paid_amount IN NUMBER,
        p_payment_date IN DATE,
        p_updated_by IN VARCHAR2
    ) IS
    BEGIN
        UPDATE INSTALLMENT_SCHEDULE
        SET INSTALLMENT_STATUS = p_installment_status,
            PAID_AMOUNT = p_paid_amount,
            PAYMENT_DATE = p_payment_date,
            UPDATED_DATE = SYSDATE,
            UPDATED_BY = p_updated_by
        WHERE INSTALLMENT_ID = p_installment_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_INSTALLMENT_STATUS;
    
    -- إعادة جدولة الأقساط
    PROCEDURE RESCHEDULE_INSTALLMENTS(
        p_request_id IN NUMBER,
        p_start_date IN DATE,
        p_new_period IN NUMBER,
        p_new_profit_rate IN NUMBER,
        p_updated_by IN VARCHAR2
    ) IS
        v_remaining_principal NUMBER := 0;
        v_new_principal_per_installment NUMBER;
        v_new_total_profit NUMBER;
        v_new_profit_per_installment NUMBER;
        v_installment_date DATE;
        v_installment_id NUMBER;
    BEGIN
        -- حساب المبلغ الأساسي المتبقي
        SELECT SUM(PRINCIPAL_AMOUNT - NVL(PAID_AMOUNT, 0))
        INTO v_remaining_principal
        FROM INSTALLMENT_SCHEDULE
        WHERE REQUEST_ID = p_request_id
        AND INSTALLMENT_STATUS != 'PAID';
        
        -- تحديث معلومات الطلب
        UPDATE FINANCING_REQUESTS
        SET FINANCING_PERIOD = p_new_period,
            PROFIT_RATE = p_new_profit_rate,
            UPDATED_DATE = SYSDATE,
            UPDATED_BY = p_updated_by
        WHERE REQUEST_ID = p_request_id;
        
        -- حذف الأقساط غير المدفوعة
        DELETE FROM INSTALLMENT_SCHEDULE
        WHERE REQUEST_ID = p_request_id
        AND INSTALLMENT_STATUS != 'PAID';
        
        -- حساب المبلغ الأساسي لكل قسط الجديد
        v_new_principal_per_installment := v_remaining_principal / p_new_period;
        
        -- حساب إجمالي الربح الجديد
        v_new_total_profit := v_remaining_principal * (p_new_profit_rate / 100) * (p_new_period / 12);
        
        -- حساب الربح لكل قسط الجديد
        v_new_profit_per_installment := v_new_total_profit / p_new_period;
        
        -- إنشاء الأقساط الجديدة
        v_installment_date := p_start_date;
        
        FOR i IN 1..p_new_period LOOP
            SELECT SEQ_INSTALLMENT_ID.NEXTVAL INTO v_installment_id FROM DUAL;
            
            INSERT INTO INSTALLMENT_SCHEDULE (
                INSTALLMENT_ID, REQUEST_ID, INSTALLMENT_SEQ, DUE_DATE,
                PRINCIPAL_AMOUNT, PROFIT_AMOUNT, TOTAL_AMOUNT,
                INSTALLMENT_STATUS, CREATED_DATE, CREATED_BY
            ) VALUES (
                v_installment_id, p_request_id, i, v_installment_date,
                v_new_principal_per_installment, v_new_profit_per_installment, 
                (v_new_principal_per_installment + v_new_profit_per_installment),
                'RESCHEDULED', SYSDATE, p_updated_by
            );
            
            -- تحديث تاريخ القسط التالي (شهر واحد)
            v_installment_date := ADD_MONTHS(v_installment_date, 1);
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END RESCHEDULE_INSTALLMENTS;
    
    -- تأجيل القسط
    PROCEDURE POSTPONE_INSTALLMENT(
        p_installment_id IN NUMBER,
        p_new_due_date IN DATE,
        p_updated_by IN VARCHAR2
    ) IS
    BEGIN
        UPDATE INSTALLMENT_SCHEDULE
        SET DUE_DATE = p_new_due_date,
            INSTALLMENT_STATUS = 'POSTPONED',
            UPDATED_DATE = SYSDATE,
            UPDATED_BY = p_updated_by
        WHERE INSTALLMENT_ID = p_installment_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END POSTPONE_INSTALLMENT;
    
    -- السداد المبكر
    PROCEDURE EARLY_SETTLEMENT(
        p_request_id IN NUMBER,
        p_settlement_date IN DATE,
        p_settlement_amount IN NUMBER,
        p_updated_by IN VARCHAR2
    ) IS
    BEGIN
        -- تحديث حالة الأقساط غير المدفوعة
        UPDATE INSTALLMENT_SCHEDULE
        SET INSTALLMENT_STATUS = 'SETTLED',
            PAID_AMOUNT = TOTAL_AMOUNT,
            PAYMENT_DATE = p_settlement_date,
            UPDATED_DATE = SYSDATE,
            UPDATED_BY = p_updated_by
        WHERE REQUEST_ID = p_request_id
        AND INSTALLMENT_STATUS NOT IN ('PAID', 'SETTLED');
        
        -- تحديث حالة الطلب
        UPDATE FINANCING_REQUESTS
        SET REQUEST_STATUS = 'SETTLED',
            UPDATED_DATE = SYSDATE,
            UPDATED_BY = p_updated_by
        WHERE REQUEST_ID = p_request_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END EARLY_SETTLEMENT;
    
    -- الحصول على جدول الأقساط للطلب
    FUNCTION GET_REQUEST_SCHEDULE(p_request_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT *
            FROM INSTALLMENT_SCHEDULE
            WHERE REQUEST_ID = p_request_id
            ORDER BY INSTALLMENT_SEQ;
        RETURN v_cursor;
    END GET_REQUEST_SCHEDULE;
    
    -- الحصول على الأقساط المستحقة
    FUNCTION GET_DUE_INSTALLMENTS(p_due_date IN DATE) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT i.*, r.CUSTOMER_ID, c.FULL_NAME AS CUSTOMER_NAME, p.PRODUCT_NAME
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            WHERE i.DUE_DATE <= p_due_date
            AND i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED')
            ORDER BY i.DUE_DATE;
        RETURN v_cursor;
    END GET_DUE_INSTALLMENTS;
    
    -- الحصول على الأقساط المتأخرة
    FUNCTION GET_OVERDUE_INSTALLMENTS RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT i.*, r.CUSTOMER_ID, c.FULL_NAME AS CUSTOMER_NAME, p.PRODUCT_NAME,
                   (SYSDATE - i.DUE_DATE) AS DAYS_OVERDUE
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            WHERE i.DUE_DATE < SYSDATE
            AND i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED')
            ORDER BY i.DUE_DATE;
        RETURN v_cursor;
    END GET_OVERDUE_INSTALLMENTS;
END PKG_INSTALLMENT_SCHEDULE;
/


CREATE OR REPLACE PACKAGE BODY                PKG_ISLAMIC_PRODUCTS AS
    -- إضافة منتج إسلامي جديد
    PROCEDURE ADD_PRODUCT(
        p_product_name IN VARCHAR2,
        p_product_type IN VARCHAR2,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_product_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_PRODUCT_ID.NEXTVAL INTO p_product_id FROM DUAL;
        
        INSERT INTO ISLAMIC_PRODUCTS (
            PRODUCT_ID, PRODUCT_NAME, PRODUCT_TYPE, DESCRIPTION, 
            PRODUCT_STATUS, CREATION_DATE, CREATED_BY
        ) VALUES (
            p_product_id, p_product_name, p_product_type, p_description, 
            'ACTIVE', SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_PRODUCT;
    
    -- تعديل منتج إسلامي
    PROCEDURE UPDATE_PRODUCT(
        p_product_id IN NUMBER,
        p_product_name IN VARCHAR2,
        p_product_type IN VARCHAR2,
        p_description IN CLOB,
        p_is_active IN NUMBER,
        p_updated_by IN VARCHAR2
    ) IS
    BEGIN
        UPDATE ISLAMIC_PRODUCTS
        SET PRODUCT_NAME = p_product_name,
            PRODUCT_TYPE = p_product_type,
            DESCRIPTION = p_description,
            PRODUCT_STATUS = DECODE(p_is_active,1,'ACTIVE','NOT ACTIVE'),
            LAST_UPDATE_DATE = SYSDATE,
            LAST_UPDATED_BY = p_updated_by
        WHERE PRODUCT_ID = p_product_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_PRODUCT;
    
    -- إضافة شرط للمنتج
    PROCEDURE ADD_PRODUCT_CONDITION(
        p_product_id IN NUMBER,
        p_condition_name IN VARCHAR2,
        p_condition_description IN CLOB,
        p_is_mandatory IN NUMBER,
        p_created_by IN VARCHAR2,
        p_condition_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_CONDITION_ID.NEXTVAL INTO p_condition_id FROM DUAL;
        
        INSERT INTO PRODUCT_CONDITIONS (
            CONDITION_ID, PRODUCT_ID, CONDITION_NAME, CONDITION_DESCRIPTION, 
            IS_MANDATORY, CREATED_DATE, CREATED_BY
        ) VALUES (
            p_condition_id, p_product_id, p_condition_name, p_condition_description, 
            p_is_mandatory, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_PRODUCT_CONDITION;
    
    -- إضافة مرحلة للمنتج
    PROCEDURE ADD_PRODUCT_STAGE(
        p_product_id IN NUMBER,
        p_stage_name IN VARCHAR2,
        p_stage_order IN NUMBER,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_stage_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_STAGE_ID.NEXTVAL INTO p_stage_id FROM DUAL;
        
        INSERT INTO PRODUCT_STAGES (
            STAGE_ID, PRODUCT_ID, STAGE_NAME, STAGE_ORDER, 
            DESCRIPTION, CREATED_DATE, CREATED_BY
        ) VALUES (
            p_stage_id, p_product_id, p_stage_name, p_stage_order, 
            p_description, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_PRODUCT_STAGE;
    
    -- إضافة معادلة محاسبية
    PROCEDURE ADD_ACCOUNTING_FORMULA(
        p_product_id IN NUMBER,
        p_stage_id IN NUMBER,
        p_formula_name IN VARCHAR2,
        p_formula_expression IN CLOB,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_formula_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_FORMULA_ID.NEXTVAL INTO p_formula_id FROM DUAL;
        
        INSERT INTO ACCOUNTING_FORMULAS (
            FORMULA_ID, PRODUCT_ID, STAGE_ID, FORMULA_NAME, 
            FORMULA_EXPRESSION, DESCRIPTION, CREATED_DATE, CREATED_BY
        ) VALUES (
            p_formula_id, p_product_id, p_stage_id, p_formula_name, 
            p_formula_expression, p_description, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_ACCOUNTING_FORMULA;
    
    -- إضافة رسوم أو عمولة
    PROCEDURE ADD_FEE(
        p_product_id IN NUMBER,
        p_stage_id IN NUMBER,
        p_fee_name IN VARCHAR2,
        p_fee_type IN VARCHAR2,
        p_fee_value IN NUMBER,
        p_min_value IN NUMBER,
        p_max_value IN NUMBER,
        p_description IN CLOB,
        p_created_by IN VARCHAR2,
        p_fee_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_FEE_ID.NEXTVAL INTO p_fee_id FROM DUAL;
        
        INSERT INTO FEES_COMMISSIONS (
            FEE_ID, PRODUCT_ID, STAGE_ID, FEE_NAME, FEE_TYPE, 
            FEE_VALUE, MIN_VALUE, MAX_VALUE, DESCRIPTION, CREATED_DATE, CREATED_BY
        ) VALUES (
            p_fee_id, p_product_id, p_stage_id, p_fee_name, p_fee_type, 
            p_fee_value, p_min_value, p_max_value, p_description, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_FEE;
    
    -- الحصول على معلومات المنتج
    FUNCTION GET_PRODUCT_INFO(p_product_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT * FROM ISLAMIC_PRODUCTS WHERE PRODUCT_ID = p_product_id;
        RETURN v_cursor;
    END GET_PRODUCT_INFO;
    
    -- الحصول على شروط المنتج
    FUNCTION GET_PRODUCT_CONDITIONS(p_product_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT * FROM PRODUCT_CONDITIONS WHERE PRODUCT_ID = p_product_id;
        RETURN v_cursor;
    END GET_PRODUCT_CONDITIONS;
    
    -- الحصول على مراحل المنتج
    FUNCTION GET_PRODUCT_STAGES(p_product_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT * FROM PRODUCT_STAGES WHERE PRODUCT_ID = p_product_id
            ORDER BY STAGE_ORDER;
        RETURN v_cursor;
    END GET_PRODUCT_STAGES;
    
    -- الحصول على المعادلات المحاسبية للمنتج
    FUNCTION GET_PRODUCT_FORMULAS(p_product_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT f.*, s.STAGE_NAME 
            FROM ACCOUNTING_FORMULAS f
            LEFT JOIN PRODUCT_STAGES s ON f.STAGE_ID = s.STAGE_ID
            WHERE f.PRODUCT_ID = p_product_id;
        RETURN v_cursor;
    END GET_PRODUCT_FORMULAS;
    
    -- الحصول على الرسوم والعمولات للمنتج
    FUNCTION GET_PRODUCT_FEES(p_product_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT f.*, s.STAGE_NAME 
            FROM FEES_COMMISSIONS f
            LEFT JOIN PRODUCT_STAGES s ON f.STAGE_ID = s.STAGE_ID
            WHERE f.PRODUCT_ID = p_product_id;
        RETURN v_cursor;
    END GET_PRODUCT_FEES;
END PKG_ISLAMIC_PRODUCTS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_NOTIFICATIONS AS
    -- تنفيذ الإجراءات والدوال الموجودة حاليًا
    -- ...
    
    -- إرسال إشعار للمستخدم
    PROCEDURE SEND_USER_NOTIFICATION(
        p_user_id IN NUMBER,
        p_notification_type IN VARCHAR2,
        p_notification_title IN VARCHAR2,
        p_notification_text IN VARCHAR2,
        p_related_entity IN VARCHAR2,
        p_related_entity_id IN NUMBER,
        p_notification_id OUT NUMBER
    ) IS
    BEGIN
        -- إنشاء معرف الإشعار
        SELECT SEQ_NOTIFICATION_ID.NEXTVAL INTO p_notification_id FROM DUAL;
                
        -- إدخال بيانات الإشعار
        INSERT INTO USER_NOTIFICATIONS (
            NOTIFICATION_ID, USER_ID, NOTIFICATION_TYPE, NOTIFICATION_TITLE,
            NOTIFICATION_MESSAGE, RELATED_ENTITY_TYPE, RELATED_ENTITY_ID,
            NOTIFICATION_DATE, IS_READ
        ) VALUES (
            p_notification_id, p_user_id, p_notification_type, p_notification_title,
            p_notification_text, p_related_entity, p_related_entity_id,
            SYSDATE, 0
        );
                
        -- يمكن إضافة منطق لإرسال الإشعار عبر البريد الإلكتروني أو الرسائل القصيرة هنا
                
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END SEND_USER_NOTIFICATION;
    
    -- تنفيذ باقي الإجراءات والدوال الموجودة
    -- ...
    
    -- إضافة تنفيذ الإجراء الجديد
    PROCEDURE SEND_SYSTEM_NOTIFICATION(
        p_notification_type IN VARCHAR2,
        p_notification_title IN VARCHAR2,
        p_notification_message IN VARCHAR2,
        p_start_date IN DATE DEFAULT SYSDATE,
        p_end_date IN DATE DEFAULT NULL,
        p_target_users IN VARCHAR2 DEFAULT NULL,
        p_target_roles IN VARCHAR2 DEFAULT NULL,
        p_created_by IN NUMBER DEFAULT 1,
        p_notification_id OUT NUMBER
    ) IS
    BEGIN
        -- إنشاء معرف الإشعار
        SELECT SEQ_NOTIFICATION_ID.NEXTVAL INTO p_notification_id FROM DUAL;
        
        -- إدخال بيانات إشعار النظام
        INSERT INTO SYSTEM_NOTIFICATIONS (
            NOTIFICATION_ID, NOTIFICATION_TYPE, NOTIFICATION_TITLE,
            NOTIFICATION_MESSAGE, START_DATE, END_DATE,
            TARGET_USERS, TARGET_ROLES, IS_ACTIVE,
            CREATED_BY, CREATION_DATE
        ) VALUES (
            p_notification_id, p_notification_type, p_notification_title,
            p_notification_message, p_start_date, p_end_date,
            p_target_users, p_target_roles, 1,
            p_created_by, SYSDATE
        );
        
        -- إذا كان هناك مستخدمين محددين، يمكن إرسال إشعارات فردية لهم أيضًا
        IF p_target_users IS NOT NULL THEN
            DECLARE
                v_user_id NUMBER;
                v_individual_notification_id NUMBER;
                
                v_start_pos NUMBER := 1;
                v_comma_pos NUMBER;
                v_user_id_str VARCHAR2(100);
            BEGIN
                -- تحليل قائمة معرفات المستخدمين
                v_comma_pos := INSTR(p_target_users, ',', v_start_pos);
                
                WHILE v_comma_pos > 0 LOOP
                    v_user_id_str := TRIM(SUBSTR(p_target_users, v_start_pos, v_comma_pos - v_start_pos));
                    
                    IF v_user_id_str IS NOT NULL AND REGEXP_LIKE(v_user_id_str, '^\d+$') THEN
                        v_user_id := TO_NUMBER(v_user_id_str);
                        
                        -- إرسال إشعار فردي للمستخدم
                        SEND_USER_NOTIFICATION(
                            p_user_id => v_user_id,
                            p_notification_type => 'SYSTEM_' || p_notification_type,
                            p_notification_title => p_notification_title,
                            p_notification_text => p_notification_message,
                            p_related_entity => 'SYSTEM_NOTIFICATIONS',
                            p_related_entity_id => p_notification_id,
                            p_notification_id => v_individual_notification_id
                        );
                    END IF;
                    
                    v_start_pos := v_comma_pos + 1;
                    v_comma_pos := INSTR(p_target_users, ',', v_start_pos);
                END LOOP;
                
                -- معالجة آخر معرف مستخدم
                v_user_id_str := TRIM(SUBSTR(p_target_users, v_start_pos));
                
                IF v_user_id_str IS NOT NULL AND REGEXP_LIKE(v_user_id_str, '^\d+$') THEN
                    v_user_id := TO_NUMBER(v_user_id_str);
                    
                    -- إرسال إشعار فردي للمستخدم
                    SEND_USER_NOTIFICATION(
                        p_user_id => v_user_id,
                        p_notification_type => 'SYSTEM_' || p_notification_type,
                        p_notification_title => p_notification_title,
                        p_notification_text => p_notification_message,
                        p_related_entity => 'SYSTEM_NOTIFICATIONS',
                        p_related_entity_id => p_notification_id,
                        p_notification_id => v_individual_notification_id
                    );
                END IF;
            EXCEPTION
                WHEN OTHERS THEN
                    -- تسجيل الخطأ والاستمرار
                    NULL;
            END;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END SEND_SYSTEM_NOTIFICATION;
    
    -- دالة للحصول على إشعارات النظام النشطة
    FUNCTION GET_ACTIVE_SYSTEM_NOTIFICATIONS(
        p_user_id IN NUMBER,
        p_user_roles IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                NOTIFICATION_ID, NOTIFICATION_TYPE, NOTIFICATION_TITLE,
                NOTIFICATION_MESSAGE, START_DATE, END_DATE,
                TARGET_USERS, TARGET_ROLES, CREATION_DATE
            FROM SYSTEM_NOTIFICATIONS
            WHERE IS_ACTIVE = 1
            AND SYSDATE BETWEEN START_DATE AND NVL(END_DATE, SYSDATE + 1000)
            AND (
                -- إشعارات عامة (بدون مستخدمين أو أدوار محددة)
                (TARGET_USERS IS NULL AND TARGET_ROLES IS NULL)
                -- أو إشعارات تستهدف هذا المستخدم
                OR (
                    TARGET_USERS IS NOT NULL 
                    AND (
                        ',' || TARGET_USERS || ',' LIKE '%,' || TO_CHAR(p_user_id) || ',%'
                        OR TARGET_USERS = TO_CHAR(p_user_id)
                    )
                )
                -- أو إشعارات تستهدف أدوار هذا المستخدم
                OR (
                    TARGET_ROLES IS NOT NULL 
                    AND p_user_roles IS NOT NULL
                    AND EXISTS (
                        SELECT 1
                        FROM (
                            SELECT REGEXP_SUBSTR(TARGET_ROLES, '[^,]+', 1, LEVEL) AS ROLE
                            FROM DUAL
                            CONNECT BY REGEXP_SUBSTR(TARGET_ROLES, '[^,]+', 1, LEVEL) IS NOT NULL
                        ) target_roles
                        WHERE ',' || p_user_roles || ',' LIKE '%,' || target_roles.ROLE || ',%'
                        OR p_user_roles = target_roles.ROLE
                    )
                )
            )
            ORDER BY CREATION_DATE DESC;
        
        RETURN v_cursor;
    END GET_ACTIVE_SYSTEM_NOTIFICATIONS;
    
    -- تنفيذ باقي الإجراءات والدوال
    -- إرسال إشعار للعميل
    PROCEDURE SEND_CUSTOMER_NOTIFICATION(
        p_customer_id IN NUMBER,
        p_notification_type IN VARCHAR2,
        p_notification_title IN VARCHAR2,
        p_notification_text IN VARCHAR2,
        p_related_entity IN VARCHAR2,
        p_related_entity_id IN NUMBER,
        p_notification_id OUT NUMBER
    ) IS
        v_email VARCHAR2(100);
        v_mobile VARCHAR2(20);
    BEGIN
        -- إنشاء معرف الإشعار
        SELECT SEQ_NOTIFICATION_ID.NEXTVAL INTO p_notification_id FROM DUAL;
                
        -- الحصول على بيانات الاتصال بالعميل
        SELECT EMAIL, MOBILE_NUMBER
        INTO v_email, v_mobile
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = p_customer_id;
                
        -- إدخال بيانات الإشعار
        INSERT INTO CUSTOMER_NOTIFICATIONS (
            NOTIFICATION_ID, CUSTOMER_ID, NOTIFICATION_TYPE, NOTIFICATION_TITLE,
            NOTIFICATION_TEXT, RELATED_ENTITY, RELATED_ENTITY_ID,
            NOTIFICATION_DATE, IS_READ
        ) VALUES (
            p_notification_id, p_customer_id, p_notification_type, p_notification_title,
            p_notification_text, p_related_entity, p_related_entity_id,
            SYSDATE, 0
        );
                
        -- يمكن إضافة منطق لإرسال الإشعار عبر البريد الإلكتروني أو الرسائل القصيرة هنا
                
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END SEND_CUSTOMER_NOTIFICATION;
        
    -- تحديث حالة الإشعار
    PROCEDURE UPDATE_NOTIFICATION_STATUS(
        p_notification_id IN NUMBER,
        p_is_read IN NUMBER
    ) IS
        v_notification_type VARCHAR2(20);
    BEGIN
        -- تحديد نوع الإشعار (للمستخدم أو للعميل)
        BEGIN
            SELECT 'USER' INTO v_notification_type
            FROM USER_NOTIFICATIONS
            WHERE NOTIFICATION_ID = p_notification_id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                BEGIN
                    SELECT 'CUSTOMER' INTO v_notification_type
                    FROM CUSTOMER_NOTIFICATIONS
                    WHERE NOTIFICATION_ID = p_notification_id;
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        RAISE_APPLICATION_ERROR(-20001, 'الإشعار غير موجود');
                END;
        END;
                
        -- تحديث حالة الإشعار
        IF v_notification_type = 'USER' THEN
            UPDATE USER_NOTIFICATIONS
            SET IS_READ = p_is_read,
                READ_DATE = CASE WHEN p_is_read = 1 THEN SYSDATE ELSE NULL END
            WHERE NOTIFICATION_ID = p_notification_id;
        ELSE
            UPDATE CUSTOMER_NOTIFICATIONS
            SET IS_READ = p_is_read,
                READ_DATE = CASE WHEN p_is_read = 1 THEN SYSDATE ELSE NULL END
            WHERE NOTIFICATION_ID = p_notification_id;
        END IF;
                
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_NOTIFICATION_STATUS;
        
    -- الحصول على إشعارات المستخدم
    FUNCTION GET_USER_NOTIFICATIONS(
        p_user_id IN NUMBER,
        p_is_read IN NUMBER DEFAULT NULL,
        p_days_back IN NUMBER DEFAULT 30
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT
                NOTIFICATION_ID, USER_ID, NOTIFICATION_TYPE, NOTIFICATION_TITLE,
                NOTIFICATION_MESSAGE, RELATED_ENTITY_TYPE, RELATED_ENTITY_ID,
                NOTIFICATION_DATE, IS_READ, READ_DATE
            FROM USER_NOTIFICATIONS
            WHERE USER_ID = p_user_id
            AND (p_is_read IS NULL OR IS_READ = p_is_read)
            AND NOTIFICATION_DATE >= SYSDATE - p_days_back
            ORDER BY NOTIFICATION_DATE DESC;
                
        RETURN v_cursor;
    END GET_USER_NOTIFICATIONS;
        
    -- الحصول على إشعارات العميل
    FUNCTION GET_CUSTOMER_NOTIFICATIONS(
        p_customer_id IN NUMBER,
        p_is_read IN NUMBER DEFAULT NULL,
        p_days_back IN NUMBER DEFAULT 30
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT
                NOTIFICATION_ID, CUSTOMER_ID, NOTIFICATION_TYPE, NOTIFICATION_TITLE,
                NOTIFICATION_TEXT, RELATED_ENTITY, RELATED_ENTITY_ID,
                NOTIFICATION_DATE, IS_READ, READ_DATE
            FROM CUSTOMER_NOTIFICATIONS
            WHERE CUSTOMER_ID = p_customer_id
            AND (p_is_read IS NULL OR IS_READ = p_is_read)
            AND NOTIFICATION_DATE >= SYSDATE - p_days_back
            ORDER BY NOTIFICATION_DATE DESC;
                
        RETURN v_cursor;
    END GET_CUSTOMER_NOTIFICATIONS;
        
    -- إرسال إشعار للطلبات المتأخرة
    PROCEDURE NOTIFY_OVERDUE_REQUESTS IS
        v_notification_id NUMBER;
        v_notification_title VARCHAR2(200);
        v_notification_text VARCHAR2(4000);
                
        CURSOR c_overdue_requests IS
            SELECT
                r.REQUEST_ID, r.REQUEST_NUMBER, r.CURRENT_STAGE_ID, r.STAGE_START_DATE,
                TRUNC(SYSDATE - r.STAGE_START_DATE) AS DAYS_IN_STAGE,
                s.MAX_DAYS_IN_STAGE AS STAGE_SLA,
                TRUNC(SYSDATE - r.STAGE_START_DATE) - s.MAX_DAYS_IN_STAGE AS DAYS_OVERDUE,
                r.ASSIGNED_TO, u.FULL_NAME AS ASSIGNED_TO_NAME,
                u.EMAIL AS ASSIGNED_TO_EMAIL,
                m.USER_ID AS MANAGER_ID, m.FULL_NAME AS MANAGER_NAME,
                m.EMAIL AS MANAGER_EMAIL
            FROM FINANCING_REQUESTS r
            JOIN REQUEST_STAGES s ON r.CURRENT_STAGE_ID = s.STAGE_ID
            JOIN USERS u ON r.ASSIGNED_TO = u.USER_ID
            LEFT JOIN USERS m ON u.MANAGER_ID = m.USER_ID
            WHERE r.REQUEST_STATUS IN ('NEW', 'IN_PROGRESS')
            AND (SYSDATE - r.STAGE_START_DATE) > s.MAX_DAYS_IN_STAGE;
    BEGIN
        FOR r IN c_overdue_requests LOOP
            -- إشعار للموظف المسؤول
            v_notification_title := 'طلب متأخر: ' || r.REQUEST_NUMBER;
            v_notification_text := 'الطلب رقم ' || r.REQUEST_NUMBER || ' متأخر في مرحلة ' ||
                                   r.CURRENT_STAGE_ID || ' بمدة ' || r.DAYS_OVERDUE || ' يوم. ' ||
                                  'يرجى اتخاذ الإجراء اللازم في أقرب وقت ممكن.';
                        
            SEND_USER_NOTIFICATION(
                p_user_id => r.ASSIGNED_TO,
                p_notification_type => 'OVERDUE_REQUEST',
                p_notification_title => v_notification_title,
                p_notification_text => v_notification_text,
                p_related_entity => 'FINANCING_REQUESTS',
                p_related_entity_id => r.REQUEST_ID,
                p_notification_id => v_notification_id
            );
                        
            -- إشعار للمدير إذا كان التأخير أكثر من 3 أيام
            IF r.DAYS_OVERDUE > 3 AND r.MANAGER_ID IS NOT NULL THEN
                v_notification_title := 'تنبيه: طلب متأخر للموظف ' || r.ASSIGNED_TO_NAME;
                v_notification_text := 'الطلب رقم ' || r.REQUEST_NUMBER || ' المسند إلى ' ||
                                       r.ASSIGNED_TO_NAME || ' متأخر في مرحلة ' ||
                                       r.CURRENT_STAGE_ID || ' بمدة ' || r.DAYS_OVERDUE || ' يوم. ' ||
                                      'يرجى متابعة الموظف لإنجاز الطلب.';
                                
                SEND_USER_NOTIFICATION(
                    p_user_id => r.MANAGER_ID,
                    p_notification_type => 'OVERDUE_REQUEST_MANAGER',
                    p_notification_title => v_notification_title,
                    p_notification_text => v_notification_text,
                    p_related_entity => 'FINANCING_REQUESTS',
                    p_related_entity_id => r.REQUEST_ID,
                    p_notification_id => v_notification_id
                );
            END IF;
        END LOOP;
                
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END NOTIFY_OVERDUE_REQUESTS;
        
    -- إرسال إشعار للأقساط المستحقة
    PROCEDURE NOTIFY_DUE_INSTALLMENTS(p_days_before_due IN NUMBER DEFAULT 5) IS
        v_notification_id NUMBER;
        v_notification_title VARCHAR2(200);
        v_notification_text VARCHAR2(4000);
                
        CURSOR c_due_installments IS
            SELECT
                i.INSTALLMENT_ID, i.REQUEST_ID, r.REQUEST_NUMBER, i.INSTALLMENT_SEQ,
                i.DUE_DATE, i.TOTAL_AMOUNT, r.CUSTOMER_ID, c.FULL_NAME AS CUSTOMER_NAME,
                c.EMAIL, c.MOBILE_NUMBER, c.RELATIONSHIP_MANAGER,
                u.FULL_NAME AS MANAGER_NAME, u.EMAIL AS MANAGER_EMAIL
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            LEFT JOIN USERS u ON c.RELATIONSHIP_MANAGER = u.USER_ID
            WHERE i.INSTALLMENT_STATUS = 'SCHEDULED'
            AND i.DUE_DATE BETWEEN SYSDATE AND (SYSDATE + p_days_before_due);
    BEGIN
        FOR i IN c_due_installments LOOP
            -- إشعار للعميل
            v_notification_title := 'قسط مستحق قريباً';
            v_notification_text := 'لديك قسط مستحق الدفع بتاريخ ' || TO_CHAR(i.DUE_DATE, 'DD/MM/YYYY') ||
                                   ' بمبلغ ' || TO_CHAR(i.TOTAL_AMOUNT, '999,999,999.99') || ' ريال ' ||
                                  'للطلب رقم ' || i.REQUEST_NUMBER || '. ' ||
                                  'يرجى التأكد من توفر الرصيد الكافي في حسابك.';
                        
            SEND_CUSTOMER_NOTIFICATION(
                p_customer_id => i.CUSTOMER_ID,
                p_notification_type => 'DUE_INSTALLMENT',
                p_notification_title => v_notification_title,
                p_notification_text => v_notification_text,
                p_related_entity => 'INSTALLMENT_SCHEDULE',
                p_related_entity_id => i.INSTALLMENT_ID,
                p_notification_id => v_notification_id
            );
                        
            -- إشعار لمدير العلاقة إذا كان موجوداً
            IF i.RELATIONSHIP_MANAGER IS NOT NULL THEN
                v_notification_title := 'قسط مستحق قريباً للعميل ' || i.CUSTOMER_NAME;
                v_notification_text := 'لدى العميل ' || i.CUSTOMER_NAME || ' قسط مستحق الدفع بتاريخ ' ||
                                       TO_CHAR(i.DUE_DATE, 'DD/MM/YYYY') || ' بمبلغ ' ||
                                       TO_CHAR(i.TOTAL_AMOUNT, '999,999,999.99') || ' ريال ' ||
                                      'للطلب رقم ' || i.REQUEST_NUMBER || '. ' ||
                                      'يرجى التواصل مع العميل للتذكير.';
                                
                SEND_USER_NOTIFICATION(
                    p_user_id => i.RELATIONSHIP_MANAGER,
                    p_notification_type => 'DUE_INSTALLMENT_RM',
                    p_notification_title => v_notification_title,
                    p_notification_text => v_notification_text,
                    p_related_entity => 'INSTALLMENT_SCHEDULE',
                    p_related_entity_id => i.INSTALLMENT_ID,
                    p_notification_id => v_notification_id
                );
            END IF;
        END LOOP;
                
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END NOTIFY_DUE_INSTALLMENTS;
        
    -- إرسال إشعار للمستندات المنتهية
    PROCEDURE NOTIFY_EXPIRING_DOCUMENTS(p_days_before_expiry IN NUMBER DEFAULT 30) IS
        v_notification_id NUMBER;
        v_notification_title VARCHAR2(200);
        v_notification_text VARCHAR2(4000);
                
        CURSOR c_expiring_documents IS
            SELECT
                cd.DOCUMENT_ID, cd.DOCUMENT_TYPE, cd.DOCUMENT_NUMBER,
                cd.EXPIRY_DATE, TRUNC(cd.EXPIRY_DATE - SYSDATE) AS DAYS_TO_EXPIRY,
                c.CUSTOMER_ID, c.FULL_NAME AS CUSTOMER_NAME,
                c.EMAIL, c.MOBILE_NUMBER, c.RELATIONSHIP_MANAGER,
                u.FULL_NAME AS MANAGER_NAME, u.EMAIL AS MANAGER_EMAIL
            FROM CUSTOMER_DOCUMENTS cd
            JOIN CUSTOMERS c ON cd.CUSTOMER_ID = c.CUSTOMER_ID
            LEFT JOIN USERS u ON c.RELATIONSHIP_MANAGER = u.USER_ID
            WHERE cd.EXPIRY_DATE BETWEEN SYSDATE AND (SYSDATE + p_days_before_expiry)
            AND cd.DOCUMENT_STATUS = 'ACTIVE';
    BEGIN
        FOR d IN c_expiring_documents LOOP
            -- إشعار للعميل
            v_notification_title := 'مستند قارب على الانتهاء: ' || d.DOCUMENT_TYPE;
            v_notification_text := 'مستندك ' || d.DOCUMENT_TYPE || ' رقم ' || d.DOCUMENT_NUMBER ||
                                   ' سينتهي بتاريخ ' || TO_CHAR(d.EXPIRY_DATE, 'DD/MM/YYYY') ||
                                   ' (بعد ' || d.DAYS_TO_EXPIRY || ' يوم). ' ||
                                  'يرجى تجديد المستند وتحديث بياناته في النظام.';
                        
            SEND_CUSTOMER_NOTIFICATION(
                p_customer_id => d.CUSTOMER_ID,
                p_notification_type => 'EXPIRING_DOCUMENT',
                p_notification_title => v_notification_title,
                p_notification_text => v_notification_text,
                p_related_entity => 'CUSTOMER_DOCUMENTS',
                p_related_entity_id => d.DOCUMENT_ID,
                p_notification_id => v_notification_id
            );
                        
            -- إشعار لمدير العلاقة إذا كان موجوداً
            IF d.RELATIONSHIP_MANAGER IS NOT NULL THEN
                v_notification_title := 'مستند قارب على الانتهاء للعميل ' || d.CUSTOMER_NAME;
                v_notification_text := 'مستند ' || d.DOCUMENT_TYPE || ' رقم ' || d.DOCUMENT_NUMBER ||
                                       ' للعميل ' || d.CUSTOMER_NAME || ' سينتهي بتاريخ ' ||
                                       TO_CHAR(d.EXPIRY_DATE, 'DD/MM/YYYY') ||
                                       ' (بعد ' || d.DAYS_TO_EXPIRY || ' يوم). ' ||
                                      'يرجى التواصل مع العميل لتذكيره بتجديد المستند.';
                                
                SEND_USER_NOTIFICATION(
                    p_user_id => d.RELATIONSHIP_MANAGER,
                    p_notification_type => 'EXPIRING_DOCUMENT_RM',
                    p_notification_title => v_notification_title,
                    p_notification_text => v_notification_text,
                    p_related_entity => 'CUSTOMER_DOCUMENTS',
                    p_related_entity_id => d.DOCUMENT_ID,
                    p_notification_id => v_notification_id
                );
            END IF;
        END LOOP;
                
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END NOTIFY_EXPIRING_DOCUMENTS;

END PKG_NOTIFICATIONS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_PERMISSIONS AS
    -- إنشاء دور جديد
    PROCEDURE CREATE_ROLE(
        p_role_name IN VARCHAR2,
        p_role_description IN VARCHAR2,
        p_created_by IN VARCHAR2,
        p_role_id OUT NUMBER
    ) IS
        v_count NUMBER;
    BEGIN
        -- التحقق من عدم وجود دور بنفس الاسم
        SELECT COUNT(*) INTO v_count
        FROM ROLES
        WHERE ROLE_NAME = p_role_name;
        
        IF v_count > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'اسم الدور موجود بالفعل');
        END IF;
        
        -- إنشاء معرف الدور
        SELECT SEQ_ROLE_ID.NEXTVAL INTO p_role_id FROM DUAL;
        
        -- إدخال بيانات الدور
        INSERT INTO ROLES (
            ROLE_ID, ROLE_NAME, DESCRIPTION, CREATION_DATE, CREATED_BY
        ) VALUES (
            p_role_id, p_role_name, p_role_description, SYSDATE, p_created_by
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_ROLE;
    
    -- تحديث بيانات الدور
    PROCEDURE UPDATE_ROLE(
        p_role_id IN NUMBER,
        p_role_name IN VARCHAR2,
        p_role_description IN VARCHAR2,
        p_updated_by IN VARCHAR2
    ) IS
        v_count NUMBER;
        v_current_name VARCHAR2(50);
    BEGIN
        -- الحصول على الاسم الحالي للدور
        SELECT ROLE_NAME INTO v_current_name
        FROM ROLES
        WHERE ROLE_ID = p_role_id;
        
        -- التحقق من عدم وجود دور آخر بنفس الاسم الجديد
        IF v_current_name <> p_role_name THEN
            SELECT COUNT(*) INTO v_count
            FROM ROLES
            WHERE ROLE_NAME = p_role_name
            AND ROLE_ID <> p_role_id;
            
            IF v_count > 0 THEN
                RAISE_APPLICATION_ERROR(-20001, 'اسم الدور موجود بالفعل');
            END IF;
        END IF;
        
        -- تحديث بيانات الدور
        UPDATE ROLES
        SET ROLE_NAME = p_role_name,
            DESCRIPTION = p_role_description,
            LAST_UPDATE_DATE = SYSDATE,
            LAST_UPDATED_BY = p_updated_by
        WHERE ROLE_ID = p_role_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_ROLE;
    
    -- إضافة صلاحية للدور
    PROCEDURE ADD_PERMISSION_TO_ROLE(
        p_role_id IN NUMBER,
        p_permission_id IN NUMBER,
        p_granted_by IN VARCHAR2
    ) IS
        v_count NUMBER;
    BEGIN
        -- التحقق من عدم وجود الصلاحية بالفعل للدور
        SELECT COUNT(*) INTO v_count
        FROM ROLE_PERMISSIONS
        WHERE ROLE_ID = p_role_id
        AND PERMISSION_ID = p_permission_id;
        
        IF v_count > 0 THEN
            RETURN; -- الصلاحية موجودة بالفعل
        END IF;
        
        -- إضافة الصلاحية للدور
        INSERT INTO ROLE_PERMISSIONS (
            ROLE_ID, PERMISSION_ID, GRANTED_BY, GRANTED_DATE
        ) VALUES (
            p_role_id, p_permission_id, p_granted_by, SYSDATE
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_PERMISSION_TO_ROLE;
    
    -- حذف صلاحية من الدور
    PROCEDURE REMOVE_PERMISSION_FROM_ROLE(
        p_role_id IN NUMBER,
        p_permission_id IN NUMBER
    ) IS
    BEGIN
        DELETE FROM ROLE_PERMISSIONS
        WHERE ROLE_ID = p_role_id
        AND PERMISSION_ID = p_permission_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END REMOVE_PERMISSION_FROM_ROLE;
    
    -- إضافة صلاحية للمستخدم
    PROCEDURE ADD_PERMISSION_TO_USER(
        p_user_id IN NUMBER,
        p_permission_id IN NUMBER,
        p_granted_by IN VARCHAR2
    ) IS
        v_count NUMBER;
    BEGIN
        -- التحقق من عدم وجود الصلاحية بالفعل للمستخدم
        SELECT COUNT(*) INTO v_count
        FROM USER_PERMISSIONS
        WHERE USER_ID = p_user_id
        AND PERMISSION_ID = p_permission_id;
        
        IF v_count > 0 THEN
            RETURN; -- الصلاحية موجودة بالفعل
        END IF;
        
        -- إضافة الصلاحية للمستخدم
        INSERT INTO USER_PERMISSIONS (
            USER_ID, PERMISSION_ID, GRANTED_BY, GRANTED_DATE
        ) VALUES (
            p_user_id, p_permission_id, p_granted_by, SYSDATE
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END ADD_PERMISSION_TO_USER;
    
    -- حذف صلاحية من المستخدم
    PROCEDURE REMOVE_PERMISSION_FROM_USER(
        p_user_id IN NUMBER,
        p_permission_id IN NUMBER
    ) IS
    BEGIN
        DELETE FROM USER_PERMISSIONS
        WHERE USER_ID = p_user_id
        AND PERMISSION_ID = p_permission_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END REMOVE_PERMISSION_FROM_USER;
    
    -- الحصول على صلاحيات الدور
    FUNCTION GET_ROLE_PERMISSIONS(p_role_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT p.PERMISSION_ID, p.PERMISSION_CODE, p.PERMISSION_NAME, 
                   p.DESCRIPTION, rp.GRANTED_DATE, rp.GRANTED_BY
            FROM PERMISSIONS p
            JOIN ROLE_PERMISSIONS rp ON p.PERMISSION_ID = rp.PERMISSION_ID
            WHERE rp.ROLE_ID = p_role_id
            ORDER BY p.PERMISSION_CODE;
        RETURN v_cursor;
    END GET_ROLE_PERMISSIONS;
    
    -- الحصول على صلاحيات المستخدم
    FUNCTION GET_USER_PERMISSIONS(p_user_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT p.PERMISSION_ID, p.PERMISSION_CODE, p.PERMISSION_NAME, 
                   p.DESCRIPTION, 'USER' AS PERMISSION_SOURCE,
                   up.GRANTED_DATE, up.GRANTED_BY
            FROM PERMISSIONS p
            JOIN USER_PERMISSIONS up ON p.PERMISSION_ID = up.PERMISSION_ID
            WHERE up.USER_ID = p_user_id
            UNION
            SELECT p.PERMISSION_ID, p.PERMISSION_CODE, p.PERMISSION_NAME, 
                   p.DESCRIPTION, 'ROLE' AS PERMISSION_SOURCE,
                   rp.GRANTED_DATE, rp.GRANTED_BY
            FROM PERMISSIONS p
            JOIN ROLE_PERMISSIONS rp ON p.PERMISSION_ID = rp.PERMISSION_ID
            JOIN USERS u ON rp.ROLE_ID = (SELECT ROLE_ID FROM ROLES WHERE ROLE_NAME = u.USER_ROLE)
            WHERE u.USER_ID = p_user_id
            ORDER BY PERMISSION_NAME;
        RETURN v_cursor;
    END GET_USER_PERMISSIONS;
    
    -- التحقق من وجود صلاحية للمستخدم
    FUNCTION CHECK_USER_PERMISSION(
        p_user_id IN NUMBER,
        p_permission_code IN VARCHAR2
    ) RETURN BOOLEAN IS
        v_count NUMBER;
    BEGIN
        -- التحقق من وجود الصلاحية للمستخدم مباشرة
        SELECT COUNT(*) INTO v_count
        FROM USER_PERMISSIONS up
        JOIN PERMISSIONS p ON up.PERMISSION_ID = p.PERMISSION_ID
        WHERE up.USER_ID = p_user_id
        AND p.PERMISSION_CODE = p_permission_code;
        
        IF v_count > 0 THEN
            RETURN TRUE;
        END IF;
        
        -- التحقق من وجود الصلاحية من خلال دور المستخدم
        SELECT COUNT(*) INTO v_count
        FROM USERS u
        JOIN ROLES r ON u.USER_ROLE = r.ROLE_NAME
        JOIN ROLE_PERMISSIONS rp ON r.ROLE_ID = rp.ROLE_ID
        JOIN PERMISSIONS p ON rp.PERMISSION_ID = p.PERMISSION_ID
        WHERE u.USER_ID = p_user_id
        AND p.PERMISSION_CODE = p_permission_code;
        
        RETURN (v_count > 0);
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END CHECK_USER_PERMISSION;
    
    -- الحصول على قائمة الأدوار
    FUNCTION GET_ROLES_LIST RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT ROLE_ID, ROLE_NAME, DESCRIPTION, CREATION_DATE, CREATED_BY,
                   LAST_UPDATE_DATE, LAST_UPDATED_BY
            FROM ROLES
            ORDER BY ROLE_NAME;
        RETURN v_cursor;
    END GET_ROLES_LIST;
    
    -- الحصول على قائمة الصلاحيات
    FUNCTION GET_PERMISSIONS_LIST RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT PERMISSION_ID, PERMISSION_CODE, PERMISSION_NAME, DESCRIPTION,
                   CREATION_DATE, CREATED_BY, UPDATED_DATE, UPDATED_BY
            FROM PERMISSIONS
            ORDER BY PERMISSION_NAME;
        RETURN v_cursor;
    END GET_PERMISSIONS_LIST;
END PKG_PERMISSIONS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_REMINDER_MESSAGES AS
    -- إرسال رسالة تذكير
    PROCEDURE SEND_REMINDER(
        p_customer_id IN NUMBER,
        p_request_id IN NUMBER,
        p_installment_id IN NUMBER,
        p_message_type IN VARCHAR2,
        p_message_content IN CLOB,
        p_created_by IN VARCHAR2,
        p_message_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_MESSAGE_ID.NEXTVAL INTO p_message_id FROM DUAL;
        
        INSERT INTO REMINDER_MESSAGES (
            MESSAGE_ID, CUSTOMER_ID, REQUEST_ID, INSTALLMENT_ID,
            MESSAGE_TYPE, MESSAGE_CONTENT, SEND_DATE,
            CREATED_DATE, CREATED_BY
        ) VALUES (
            p_message_id, p_customer_id, p_request_id, p_installment_id,
            p_message_type, p_message_content, SYSDATE,
            SYSDATE, p_created_by
        );
        
        -- هنا يمكن إضافة كود لإرسال الرسالة فعلياً عبر SMS أو البريد الإلكتروني
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END SEND_REMINDER;
    
    -- إرسال تذكيرات للأقساط المستحقة
    PROCEDURE SEND_DUE_INSTALLMENTS_REMINDERS(
        p_days_before_due IN NUMBER,
        p_message_type IN VARCHAR2,
        p_created_by IN VARCHAR2
    ) IS
        CURSOR c_due_installments IS
            SELECT i.INSTALLMENT_ID, i.REQUEST_ID, r.CUSTOMER_ID, c.FULL_NAME,
                   i.DUE_DATE, i.TOTAL_AMOUNT
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE i.DUE_DATE = SYSDATE + p_days_before_due
            AND i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED');
            
        v_message_content CLOB;
        v_message_id NUMBER;
    BEGIN
        FOR i IN c_due_installments LOOP
            -- إعداد محتوى الرسالة
            v_message_content := 'عزيزي العميل ' || i.FULL_NAME || 
                                 '، نود تذكيركم بموعد استحقاق القسط بتاريخ ' || 
                                 TO_CHAR(i.DUE_DATE, 'DD/MM/YYYY') || 
                                 ' بمبلغ ' || i.TOTAL_AMOUNT || 
                                 '. نشكركم على التزامكم بالسداد في الموعد المحدد.';
            
            -- إرسال الرسالة
            SEND_REMINDER(
                i.CUSTOMER_ID, i.REQUEST_ID, i.INSTALLMENT_ID,
                p_message_type, v_message_content, p_created_by, v_message_id
            );
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END SEND_DUE_INSTALLMENTS_REMINDERS;
    
    -- إرسال تذكيرات للأقساط المتأخرة
    PROCEDURE SEND_OVERDUE_INSTALLMENTS_REMINDERS(
        p_message_type IN VARCHAR2,
        p_created_by IN VARCHAR2
    ) IS
        CURSOR c_overdue_installments IS
            SELECT i.INSTALLMENT_ID, i.REQUEST_ID, r.CUSTOMER_ID, c.FULL_NAME,
                   i.DUE_DATE, i.TOTAL_AMOUNT, (SYSDATE - i.DUE_DATE) AS DAYS_OVERDUE
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE i.DUE_DATE < SYSDATE
            AND i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED');
            
        v_message_content CLOB;
        v_message_id NUMBER;
    BEGIN
        FOR i IN c_overdue_installments LOOP
            -- إعداد محتوى الرسالة
            v_message_content := 'عزيزي العميل ' || i.FULL_NAME || 
                                 '، نود إشعاركم بتأخر سداد القسط المستحق بتاريخ ' || 
                                 TO_CHAR(i.DUE_DATE, 'DD/MM/YYYY') || 
                                 ' بمبلغ ' || i.TOTAL_AMOUNT || 
                                 ' لمدة ' || ROUND(i.DAYS_OVERDUE) || 
                                 ' يوم. يرجى المبادرة بالسداد في أقرب وقت ممكن.';
            
            -- إرسال الرسالة
            SEND_REMINDER(
                i.CUSTOMER_ID, i.REQUEST_ID, i.INSTALLMENT_ID,
                p_message_type, v_message_content, p_created_by, v_message_id
            );
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END SEND_OVERDUE_INSTALLMENTS_REMINDERS;
    
    -- الحصول على رسائل العميل
    FUNCTION GET_CUSTOMER_MESSAGES(p_customer_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT *
            FROM REMINDER_MESSAGES
            WHERE CUSTOMER_ID = p_customer_id
            ORDER BY SEND_DATE DESC;
        RETURN v_cursor;
    END GET_CUSTOMER_MESSAGES;
    
    -- الحصول على رسائل الطلب
    FUNCTION GET_REQUEST_MESSAGES(p_request_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT *
            FROM REMINDER_MESSAGES
            WHERE REQUEST_ID = p_request_id
            ORDER BY SEND_DATE DESC;
        RETURN v_cursor;
    END GET_REQUEST_MESSAGES;
END PKG_REMINDER_MESSAGES;
/


CREATE OR REPLACE PACKAGE BODY                PKG_REPORTS AS
    -- إنشاء تقرير الأقساط المتأخرة
    PROCEDURE GENERATE_OVERDUE_INSTALLMENTS_REPORT(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_overdue NUMBER := 0;
        v_count_overdue NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير الأقساط المتأخرة</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير الأقساط المتأخرة</h2>';
        v_report_data := v_report_data || '<p>الفترة: ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(p_end_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- جدول الأقساط المتأخرة
        v_report_data := v_report_data || '<h3>الأقساط المتأخرة</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>رقم القسط</th><th>رقم العميل</th><th>اسم العميل</th><th>رقم التمويل</th><th>تاريخ الاستحقاق</th><th>عدد أيام التأخير</th><th>المبلغ المستحق</th><th>المبلغ المدفوع</th><th>المبلغ المتبقي</th></tr>';
        
        -- استعلام عن الأقساط المتأخرة
        FOR rec IN (
            SELECT 
                i.INSTALLMENT_ID,
                c.CUSTOMER_ID,
                c.FULL_NAME,
                i.REQUEST_ID,
                i.DUE_DATE,
                TRUNC(LEAST(p_end_date, SYSDATE)) - TRUNC(i.DUE_DATE) AS DAYS_OVERDUE,
                i.TOTAL_AMOUNT,
                i.PAID_AMOUNT,
                i.TOTAL_AMOUNT - i.PAID_AMOUNT AS REMAINING_AMOUNT
            FROM 
                INSTALLMENT_SCHEDULE i
                JOIN FINANCING_CONTRACTS f ON i.REQUEST_ID = f.REQUEST_ID
                JOIN CUSTOMERS c ON f.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE 
                i.INSTALLMENT_STATUS = 'OVERDUE'
                AND i.DUE_DATE BETWEEN p_start_date AND p_end_date
            ORDER BY 
                DAYS_OVERDUE DESC, c.CUSTOMER_ID
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.INSTALLMENT_ID || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_ID || '</td>';
            v_report_data := v_report_data || '<td>' || rec.FULL_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.REQUEST_ID || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.DUE_DATE, 'DD/MM/YYYY') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.DAYS_OVERDUE || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.PAID_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.REMAINING_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
            
            v_total_overdue := v_total_overdue + rec.REMAINING_AMOUNT;
            v_count_overdue := v_count_overdue + 1;
        END LOOP;
        
        -- إضافة ملخص
        v_report_data := v_report_data || '<tr class="summary">';
        v_report_data := v_report_data || '<td colspan="6">الإجمالي (' || v_count_overdue || ' قسط متأخر)</td>';
        v_report_data := v_report_data || '<td colspan="3">' || TO_CHAR(v_total_overdue, '999,999,999.99') || '</td>';
        v_report_data := v_report_data || '</tr>';
        v_report_data := v_report_data || '</table>';
        
        -- تحليل الأقساط المتأخرة حسب فترة التأخير
        v_report_data := v_report_data || '<h3>تحليل الأقساط المتأخرة حسب فترة التأخير</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>فترة التأخير</th><th>عدد الأقساط</th><th>إجمالي المبلغ المتأخر</th><th>النسبة من إجمالي المتأخرات</th></tr>';
        
        -- استعلام عن تحليل الأقساط المتأخرة حسب فترة التأخير
        FOR rec IN (
            SELECT 
                CASE 
                    WHEN DAYS_OVERDUE BETWEEN 1 AND 30 THEN '1-30 يوم'
                    WHEN DAYS_OVERDUE BETWEEN 31 AND 60 THEN '31-60 يوم'
                    WHEN DAYS_OVERDUE BETWEEN 61 AND 90 THEN '61-90 يوم'
                    ELSE 'أكثر من 90 يوم'
                END AS OVERDUE_PERIOD,
                COUNT(*) AS COUNT_OVERDUE,
                SUM(REMAINING_AMOUNT) AS TOTAL_OVERDUE,
                ROUND(SUM(REMAINING_AMOUNT) / NULLIF(v_total_overdue, 0) * 100, 2) AS PERCENTAGE
            FROM (
                SELECT 
                    TRUNC(LEAST(p_end_date, SYSDATE)) - TRUNC(i.DUE_DATE) AS DAYS_OVERDUE,
                    i.TOTAL_AMOUNT - i.PAID_AMOUNT AS REMAINING_AMOUNT
                FROM 
                    INSTALLMENT_SCHEDULE i
                WHERE 
                    i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE BETWEEN p_start_date AND p_end_date
            )
            GROUP BY 
                CASE 
                    WHEN DAYS_OVERDUE BETWEEN 1 AND 30 THEN '1-30 يوم'
                    WHEN DAYS_OVERDUE BETWEEN 31 AND 60 THEN '31-60 يوم'
                    WHEN DAYS_OVERDUE BETWEEN 61 AND 90 THEN '61-90 يوم'
                    ELSE 'أكثر من 90 يوم'
                END
            ORDER BY 
                MIN(DAYS_OVERDUE)
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.OVERDUE_PERIOD || '</td>';
            v_report_data := v_report_data || '<td>' || rec.COUNT_OVERDUE || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_OVERDUE, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_NAME, REPORT_DESCRIPTION, 
            REPORT_QUERY, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'OVERDUE_INSTALLMENTS', 'تقرير الأقساط المتأخرة', 
            'تقرير الأقساط المتأخرة للفترة من ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(p_end_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_start_date, p_end_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_OVERDUE_INSTALLMENTS_REPORT;
    
    -- إنشاء تقرير أداء المبيعات
    PROCEDURE GENERATE_SALES_PERFORMANCE_REPORT(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_sales NUMBER := 0;
        v_total_count NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير أداء المبيعات</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير أداء المبيعات</h2>';
        v_report_data := v_report_data || '<p>الفترة: ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(p_end_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- جدول أداء المبيعات حسب الموظف
        v_report_data := v_report_data || '<h3>أداء المبيعات حسب الموظف</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>رقم الموظف</th><th>اسم الموظف</th><th>عدد العقود</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th><th>النسبة من إجمالي المبيعات</th></tr>';
        
        -- استعلام عن أداء المبيعات حسب الموظف
        FOR rec IN (
            SELECT 
                e.USER_ID AS EMPLOYEE_ID,
                e.USERNAME AS FULL_NAME,
                COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_AMOUNT,
                ROUND(AVG(f.FINANCING_AMOUNT), 2) AS AVG_AMOUNT,
                0 AS PERCENTAGE -- سيتم حسابها لاحقاً
            FROM 
                USERS e
                JOIN FINANCING_CONTRACTS f ON e.USER_ID = f.CREATED_BY
            WHERE 
                f.CREATION_DATE BETWEEN p_start_date AND p_end_date
                AND f.CONTRACT_STATUS IN ('ACTIVE', 'COMPLETED')
            GROUP BY 
                e.USER_ID, e.USERNAME
            ORDER BY 
                SUM(f.FINANCING_AMOUNT) DESC
        ) LOOP
            -- حساب إجمالي المبيعات
            v_total_sales := v_total_sales + rec.TOTAL_AMOUNT;
            v_total_count := v_total_count + rec.CONTRACT_COUNT;
            
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.EMPLOYEE_ID || '</td>';
            v_report_data := v_report_data || '<td>' || rec.FULL_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td id="percentage_' || rec.EMPLOYEE_ID || '">0%</td>'; -- سيتم تحديثها لاحقاً
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        -- إضافة ملخص
        v_report_data := v_report_data || '<tr class="summary">';
        v_report_data := v_report_data || '<td colspan="2">الإجمالي</td>';
        v_report_data := v_report_data || '<td>' || v_total_count || '</td>';
        v_report_data := v_report_data || '<td>' || TO_CHAR(v_total_sales, '999,999,999.99') || '</td>';
        v_report_data := v_report_data || '<td>' || TO_CHAR(ROUND(v_total_sales / NULLIF(v_total_count, 0), 2), '999,999,999.99') || '</td>';
        v_report_data := v_report_data || '<td>100%</td>';
        v_report_data := v_report_data || '</tr>';
        v_report_data := v_report_data || '</table>';
        
        -- إضافة سكريبت لحساب النسب المئوية
        v_report_data := v_report_data || '<script>';
        v_report_data := v_report_data || 'var totalSales = ' || v_total_sales || ';';
        
        -- استعلام مرة أخرى لحساب النسب المئوية
        FOR rec IN (
            SELECT 
                e.USER_ID AS EMPLOYEE_ID,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_AMOUNT
            FROM 
                USERS e
                JOIN FINANCING_CONTRACTS f ON e.USER_ID = f.CREATED_BY
            WHERE 
                f.CREATION_DATE BETWEEN p_start_date AND p_end_date
                AND f.CONTRACT_STATUS IN ('ACTIVE', 'COMPLETED')
            GROUP BY 
                e.USER_ID
        ) LOOP
            v_report_data := v_report_data || 'document.getElementById("percentage_' || rec.EMPLOYEE_ID || '").innerHTML = "' || 
                              TO_CHAR(ROUND(rec.TOTAL_AMOUNT / NULLIF(v_total_sales, 0) * 100, 2), '990.99') || '%";';
        END LOOP;
        
        v_report_data := v_report_data || '</script>';
        
        -- جدول أداء المبيعات حسب نوع التمويل
        v_report_data := v_report_data || '<h3>أداء المبيعات حسب نوع التمويل</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>نوع التمويل</th><th>عدد العقود</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th><th>النسبة من إجمالي المبيعات</th></tr>';
        
        -- استعلام عن أداء المبيعات حسب نوع التمويل
        FOR rec IN (
            SELECT 
                f.FINANCING_TYPE,
                COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_AMOUNT,
                ROUND(AVG(f.FINANCING_AMOUNT), 2) AS AVG_AMOUNT,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(v_total_sales, 0) * 100, 2) AS PERCENTAGE
            FROM 
                FINANCING_CONTRACTS f
            WHERE 
                f.CREATION_DATE BETWEEN p_start_date AND p_end_date
                AND f.CONTRACT_STATUS IN ('ACTIVE', 'COMPLETED')
            GROUP BY 
                f.FINANCING_TYPE
            ORDER BY 
                SUM(f.FINANCING_AMOUNT) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_TYPE || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- جدول أداء المبيعات الشهري
        v_report_data := v_report_data || '<h3>أداء المبيعات الشهري</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>الشهر</th><th>عدد العقود</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th><th>النسبة من إجمالي المبيعات</th></tr>';
        
        -- استعلام عن أداء المبيعات الشهري
        FOR rec IN (
            SELECT 
                TO_CHAR(f.CREATION_DATE, 'YYYY-MM') AS MONTH_YEAR,
                TO_CHAR(f.CREATION_DATE, 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ARABIC') AS MONTH_NAME,
                COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_AMOUNT,
                ROUND(AVG(f.FINANCING_AMOUNT), 2) AS AVG_AMOUNT,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(v_total_sales, 0) * 100, 2) AS PERCENTAGE
            FROM 
                FINANCING_CONTRACTS f
            WHERE 
                f.CREATION_DATE BETWEEN p_start_date AND p_end_date
                AND f.CONTRACT_STATUS IN ('ACTIVE', 'COMPLETED')
            GROUP BY 
                TO_CHAR(f.CREATION_DATE, 'YYYY-MM'),
                TO_CHAR(f.CREATION_DATE, 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ARABIC')
            ORDER BY 
                TO_CHAR(f.CREATION_DATE, 'YYYY-MM')
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.MONTH_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_NAME, REPORT_DESCRIPTION, 
            REPORT_QUERY, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'SALES_PERFORMANCE', 'تقرير أداء المبيعات', 
            'تقرير أداء المبيعات للفترة من ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(p_end_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_start_date, p_end_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_SALES_PERFORMANCE_REPORT;
    
    -- إرسال تقرير الأداء الأسبوعي
    PROCEDURE SEND_WEEKLY_PERFORMANCE_REPORT IS
        v_report_id NUMBER;
        v_start_date DATE;
        v_end_date DATE;
        v_email_subject VARCHAR2(200);
        v_email_body CLOB;
        v_recipients VARCHAR2(1000);
        p_email_id NUMBER;
        P_ERR_MSG VARCHAR2(1001);
    BEGIN
        -- تحديد فترة التقرير (الأسبوع الماضي)
        v_end_date := TRUNC(SYSDATE) - 1; -- بالأمس
        v_start_date := TRUNC(v_end_date, 'IW'); -- بداية الأسبوع
        
        -- إنشاء تقرير أداء المبيعات
        GENERATE_SALES_PERFORMANCE_REPORT(v_start_date, v_end_date, v_report_id);
        
        -- تحديد عنوان ونص البريد الإلكتروني
        v_email_subject := 'تقرير الأداء الأسبوعي: ' || TO_CHAR(v_start_date, 'DD/MM/YYYY') || ' - ' || TO_CHAR(v_end_date, 'DD/MM/YYYY');
        
        v_email_body := 'السادة المحترمين،' || CHR(10) || CHR(10);
        v_email_body := v_email_body || 'مرفق لكم تقرير الأداء الأسبوعي للفترة من ' || TO_CHAR(v_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(v_end_date, 'DD/MM/YYYY') || '.' || CHR(10) || CHR(10);
        v_email_body := v_email_body || 'يمكنكم الاطلاع على التقرير من خلال الرابط التالي:' || CHR(10);
        v_email_body := v_email_body || 'http://financing-system.com/reports/view/' || v_report_id || CHR(10) || CHR(10);
        v_email_body := v_email_body || 'مع خالص التحية،' || CHR(10);
        v_email_body := v_email_body || 'نظام إدارة التمويل';
        
        -- تحديد المستلمين (يمكن استرجاعهم من جدول الإعدادات أو المستخدمين)
        SELECT LISTAGG(EMAIL, ';') WITHIN GROUP (ORDER BY USER_ID)
        INTO v_recipients
        FROM USERS
        WHERE DEPARTMENT = 'MANAGEMENT' OR USER_ROLE = 'MANAGER';
        
        -- إرسال البريد الإلكتروني
        email_management.SEND_EMAIL(
            p_to => v_recipients,
            p_subject => v_email_subject,
            p_body => v_email_body,
            ---p_attachment_id => v_report_id            
        p_cc => null,
        p_bcc => null,
        p_attachment_path => null,
        p_email_id => p_email_id
        );
        
        -- تسجيل إرسال التقرير
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'REPORT', 'إرسال تقرير الأداء الأسبوعي', 
            'تم إرسال تقرير الأداء الأسبوعي للفترة من ' || TO_CHAR(v_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(v_end_date, 'DD/MM/YYYY') || ' إلى ' || v_recipients,
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'ERROR', 'خطأ في إرسال تقرير الأداء الأسبوعي', 
                P_ERR_MSG,
                1
            );
            
            COMMIT;
            RAISE;
    END SEND_WEEKLY_PERFORMANCE_REPORT;
    
    -- إرسال تقرير الأداء الشهري
    PROCEDURE SEND_MONTHLY_PERFORMANCE_REPORT IS
        v_report_id_sales NUMBER;
        v_report_id_portfolio NUMBER;
        v_start_date DATE;
        v_end_date DATE;
        v_email_subject VARCHAR2(200);
        v_email_body CLOB;
        v_recipients VARCHAR2(1000);
        p_email_id NUMBER;
        P_ERR_MSG VARCHAR2(1001);
        ---
    BEGIN
        -- تحديد فترة التقرير (الشهر الماضي)
        v_end_date := LAST_DAY(ADD_MONTHS(SYSDATE, -1));
        v_start_date := TRUNC(v_end_date, 'MM');
        
        -- إنشاء تقرير أداء المبيعات
        GENERATE_SALES_PERFORMANCE_REPORT(v_start_date, v_end_date, v_report_id_sales);
        
        -- إنشاء تقرير تحليل المحفظة
        GENERATE_PORTFOLIO_ANALYSIS_REPORT(v_end_date, v_report_id_portfolio);
        
        -- تحديد عنوان ونص البريد الإلكتروني
        v_email_subject := 'تقرير الأداء الشهري: ' || TO_CHAR(v_start_date, 'MM/YYYY');
        
        v_email_body := 'السادة المحترمين،' || CHR(10) || CHR(10);
        v_email_body := v_email_body || 'مرفق لكم تقرير الأداء الشهري لشهر ' || TO_CHAR(v_start_date, 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ARABIC') || '.' || CHR(10) || CHR(10);
        v_email_body := v_email_body || 'يمكنكم الاطلاع على التقارير من خلال الروابط التالية:' || CHR(10);
        v_email_body := v_email_body || '1. تقرير أداء المبيعات: http://financing-system.com/reports/view/' || v_report_id_sales || CHR(10);
        v_email_body := v_email_body || '2. تقرير تحليل المحفظة: http://financing-system.com/reports/view/' || v_report_id_portfolio || CHR(10) || CHR(10);
        v_email_body := v_email_body || 'مع خالص التحية،' || CHR(10);
        v_email_body := v_email_body || 'نظام إدارة التمويل';
        
        -- تحديد المستلمين (يمكن استرجاعهم من جدول الإعدادات أو المستخدمين)
        SELECT LISTAGG(EMAIL, ';') WITHIN GROUP (ORDER BY USER_ID)
        INTO v_recipients
        FROM USERS
        WHERE DEPARTMENT = 'MANAGEMENT' OR USER_ROLE IN ('MANAGER', 'DIRECTOR', 'CEO');
        
        -- إرسال البريد الإلكتروني
        email_management.SEND_EMAIL(
            p_to => v_recipients,
            p_subject => v_email_subject,
            p_body => v_email_body,
           --- p_attachment_id => v_report_id_sales || ',' || v_report_id_portfolio
           p_cc => null,
        p_bcc => null,
        p_attachment_path => null,
        p_email_id => p_email_id
        );
        
        -- تسجيل إرسال التقرير
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'REPORT', 'إرسال تقرير الأداء الشهري', 
            'تم إرسال تقرير الأداء الشهري لشهر ' || TO_CHAR(v_start_date, 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ARABIC') || ' إلى ' || v_recipients,
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'ERROR', 'خطأ في إرسال تقرير الأداء الشهري', 
                P_ERR_MSG,
                1
            );
            
            COMMIT;
            RAISE;
    END SEND_MONTHLY_PERFORMANCE_REPORT;
    
    -- إنشاء تقرير تصنيف العملاء
    PROCEDURE GENERATE_CUSTOMER_CLASSIFICATION_REPORT(
        p_as_of_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_customers NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير تصنيف العملاء</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير تصنيف العملاء</h2>';
        v_report_data := v_report_data || '<p>كما في: ' || TO_CHAR(p_as_of_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- حساب إجمالي عدد العملاء
        SELECT COUNT(*) INTO v_total_customers FROM CUSTOMERS;
        
        -- ملخص تصنيف العملاء
        v_report_data := v_report_data || '<h3>ملخص تصنيف العملاء</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>التصنيف</th><th>عدد العملاء</th><th>النسبة المئوية</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th></tr>';
        
        -- استعلام عن تصنيف العملاء
        FOR rec IN (
            SELECT 
                c.CUSTOMER_CLASSIFICATION,
                COUNT(DISTINCT c.CUSTOMER_ID) AS CUSTOMER_COUNT,
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / v_total_customers * 100, 2) AS PERCENTAGE,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_FINANCING,
                ROUND(SUM(f.FINANCING_AMOUNT) / COUNT(DISTINCT c.CUSTOMER_ID), 2) AS AVG_FINANCING
            FROM 
                CUSTOMERS c
                LEFT JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
            GROUP BY 
                c.CUSTOMER_CLASSIFICATION
            ORDER BY 
                COUNT(DISTINCT c.CUSTOMER_ID) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_CLASSIFICATION || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل العملاء حسب عدد العقود
        v_report_data := v_report_data || '<h3>تحليل العملاء حسب عدد العقود</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>عدد العقود</th><th>عدد العملاء</th><th>النسبة المئوية</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th></tr>';
        
        -- استعلام عن تحليل العملاء حسب عدد العقود
        FOR rec IN (
            SELECT 
                CASE 
                    WHEN CONTRACT_COUNT = 0 THEN 'لا يوجد عقود'
                    WHEN CONTRACT_COUNT = 1 THEN 'عقد واحد'
                    WHEN CONTRACT_COUNT = 2 THEN 'عقدين'
                    WHEN CONTRACT_COUNT BETWEEN 3 AND 5 THEN '3-5 عقود'
                    ELSE 'أكثر من 5 عقود'
                END AS CONTRACT_RANGE,
                COUNT(*) AS CUSTOMER_COUNT,
                ROUND(COUNT(*) / v_total_customers * 100, 2) AS PERCENTAGE,
                SUM(TOTAL_FINANCING) AS TOTAL_FINANCING,
                ROUND(SUM(TOTAL_FINANCING) / NULLIF(COUNT(*), 0), 2) AS AVG_FINANCING
            FROM (
                SELECT 
                    c.CUSTOMER_ID,
                    COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                    SUM(NVL(f.FINANCING_AMOUNT, 0)) AS TOTAL_FINANCING
                FROM 
                    CUSTOMERS c
                    LEFT JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
                GROUP BY 
                    c.CUSTOMER_ID
            )
            GROUP BY 
                CASE 
                    WHEN CONTRACT_COUNT = 0 THEN 'لا يوجد عقود'
                    WHEN CONTRACT_COUNT = 1 THEN 'عقد واحد'
                    WHEN CONTRACT_COUNT = 2 THEN 'عقدين'
                    WHEN CONTRACT_COUNT BETWEEN 3 AND 5 THEN '3-5 عقود'
                    ELSE 'أكثر من 5 عقود'
                END
            ORDER BY 
                MIN(CONTRACT_COUNT)
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_RANGE || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل العملاء حسب تاريخ الانضمام
        v_report_data := v_report_data || '<h3>تحليل العملاء حسب تاريخ الانضمام</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>فترة الانضمام</th><th>عدد العملاء</th><th>النسبة المئوية</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th></tr>';
        
        -- استعلام عن تحليل العملاء حسب تاريخ الانضمام
        FOR rec IN (
            SELECT 
                CASE 
                    WHEN MONTHS_SINCE_JOIN <= 3 THEN 'خلال 3 أشهر'
                    WHEN MONTHS_SINCE_JOIN BETWEEN 4 AND 6 THEN '4-6 أشهر'
                    WHEN MONTHS_SINCE_JOIN BETWEEN 7 AND 12 THEN '7-12 شهر'
                    WHEN MONTHS_SINCE_JOIN BETWEEN 13 AND 24 THEN '1-2 سنة'
                    WHEN MONTHS_SINCE_JOIN BETWEEN 25 AND 36 THEN '2-3 سنوات'
                    ELSE 'أكثر من 3 سنوات'
                END AS JOIN_PERIOD,
                COUNT(*) AS CUSTOMER_COUNT,
                ROUND(COUNT(*) / v_total_customers * 100, 2) AS PERCENTAGE,
                SUM(TOTAL_FINANCING) AS TOTAL_FINANCING,
                ROUND(SUM(TOTAL_FINANCING) / NULLIF(COUNT(*), 0), 2) AS AVG_FINANCING
            FROM (
                SELECT 
                    c.CUSTOMER_ID,
                    MONTHS_BETWEEN(p_as_of_date, c.CREATION_DATE) AS MONTHS_SINCE_JOIN,
                    SUM(NVL(f.FINANCING_AMOUNT, 0)) AS TOTAL_FINANCING
                FROM 
                    CUSTOMERS c
                    LEFT JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
                GROUP BY 
                    c.CUSTOMER_ID, MONTHS_BETWEEN(p_as_of_date, c.CREATION_DATE)
            )
            GROUP BY 
                CASE 
                    WHEN MONTHS_SINCE_JOIN <= 3 THEN 'خلال 3 أشهر'
                    WHEN MONTHS_SINCE_JOIN BETWEEN 4 AND 6 THEN '4-6 أشهر'
                    WHEN MONTHS_SINCE_JOIN BETWEEN 7 AND 12 THEN '7-12 شهر'
                    WHEN MONTHS_SINCE_JOIN BETWEEN 13 AND 24 THEN '1-2 سنة'
                    WHEN MONTHS_SINCE_JOIN BETWEEN 25 AND 36 THEN '2-3 سنوات'
                    ELSE 'أكثر من 3 سنوات'
                END
            ORDER BY 
                MIN(MONTHS_SINCE_JOIN)
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.JOIN_PERIOD || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل العملاء حسب سجل السداد
        v_report_data := v_report_data || '<h3>تحليل العملاء حسب سجل السداد</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>سجل السداد</th><th>عدد العملاء</th><th>النسبة المئوية</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th></tr>';
        
        -- استعلام عن تحليل العملاء حسب سجل السداد
        FOR rec IN (
            SELECT 
                PAYMENT_HISTORY,
                COUNT(*) AS CUSTOMER_COUNT,
                ROUND(COUNT(*) / v_total_customers * 100, 2) AS PERCENTAGE,
                SUM(TOTAL_FINANCING) AS TOTAL_FINANCING,
                ROUND(SUM(TOTAL_FINANCING) / NULLIF(COUNT(*), 0), 2) AS AVG_FINANCING
            FROM (
                SELECT 
                    c.CUSTOMER_ID,
                    CASE 
                        WHEN NOT EXISTS (SELECT 1 FROM FINANCING_CONTRACTS fc WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID) THEN 'لا يوجد عقود'
                        WHEN EXISTS (
                            SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                            JOIN FINANCING_CONTRACTS fc ON i.REQUEST_ID = fc.REQUEST_ID
                            WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID AND i.INSTALLMENT_STATUS = 'OVERDUE'
                            AND i.DUE_DATE <= p_as_of_date
                        ) THEN 'متأخر حالياً'
                        WHEN EXISTS (
                            SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                            JOIN FINANCING_CONTRACTS fc ON i.REQUEST_ID = fc.REQUEST_ID
                            WHERE fc.CUSTOMER_ID = c.CUSTOMER_ID AND i.INSTALLMENT_STATUS = 'LATE_PAYMENT'
                        ) THEN 'متأخر سابقاً'
                        ELSE 'منتظم'
                    END AS PAYMENT_HISTORY,
                    SUM(NVL(fc.FINANCING_AMOUNT, 0)) AS TOTAL_FINANCING
                FROM 
                    CUSTOMERS c
                    LEFT JOIN FINANCING_CONTRACTS fc ON c.CUSTOMER_ID = fc.CUSTOMER_ID
                GROUP BY 
                    c.CUSTOMER_ID
            )
            GROUP BY 
                PAYMENT_HISTORY
            ORDER BY 
                CASE PAYMENT_HISTORY
                    WHEN 'منتظم' THEN 1
                    WHEN 'متأخر سابقاً' THEN 2
                    WHEN 'متأخر حالياً' THEN 3
                    WHEN 'لا يوجد عقود' THEN 4
                END
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.PAYMENT_HISTORY || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_NAME, REPORT_DESCRIPTION, 
            REPORT_QUERY, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'CUSTOMER_CLASSIFICATION', 'تقرير تصنيف العملاء', 
            'تقرير تصنيف العملاء كما في ' || TO_CHAR(p_as_of_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_as_of_date, p_as_of_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_CUSTOMER_CLASSIFICATION_REPORT;
    /*
    -- إنشاء تقرير تحليل المخاطر
    PROCEDURE GENERATE_RISK_ANALYSIS_REPORT(
        p_as_of_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_portfolio NUMBER := 0;
        v_total_risk_amount NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير تحليل المخاطر</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
            .high-risk { background-color: #ffcccc; }
            .medium-risk { background-color: #ffffcc; }
            .low-risk { background-color: #ccffcc; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير تحليل المخاطر</h2>';
        v_report_data := v_report_data || '<p>كما في: ' || TO_CHAR(p_as_of_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- حساب إجمالي المحفظة وإجمالي المخاطر
        SELECT 
            SUM(REMAINING_AMOUNT),
            SUM(CASE 
                WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN REMAINING_AMOUNT 
                ELSE 0 
            END)
        INTO 
            v_total_portfolio, v_total_risk_amount
        FROM 
            FINANCING_CONTRACTS f
        WHERE 
            CONTRACT_STATUS = 'ACTIVE';
        
        -- ملخص المخاطر
        v_report_data := v_report_data || '<h3>ملخص المخاطر</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>البيان</th><th>القيمة</th><th>النسبة المئوية</th></tr>';
        v_report_data := v_report_data || '<tr><td>إجمالي قيمة المحفظة النشطة</td><td>' || TO_CHAR(v_total_portfolio, '999,999,999.99') || '</td><td>100%</td></tr>';
        v_report_data := v_report_data || '<tr><td>إجمالي قيمة المحفظة المعرضة للمخاطر</td><td>' || TO_CHAR(v_total_risk_amount, '999,999,999.99') || '</td><td>' || 
                          TO_CHAR(ROUND(v_total_risk_amount / NULLIF(v_total_portfolio, 0) * 100, 2), '990.99') || '%</td></tr>';
        v_report_data := v_report_data || '</table>';
        
        -- تحليل المخاطر حسب فترة التأخير
        v_report_data := v_report_data || '<h3>تحليل المخاطر حسب فترة التأخير</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>فترة التأخير</th><th>عدد العقود</th><th>قيمة المخاطر</th><th>النسبة من إجمالي المحفظة</th><th>مستوى المخاطر</th></tr>';
        
        -- استعلام عن تحليل المخاطر حسب فترة التأخير
        FOR rec IN (
            SELECT 
                CASE 
                    WHEN MAX_DAYS_OVERDUE = 0 THEN 'لا يوجد تأخير'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 1 AND 30 THEN '1-30 يوم'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 31 AND 60 THEN '31-60 يوم'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 61 AND 90 THEN '61-90 يوم'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 91 AND 180 THEN '91-180 يوم'
                    ELSE 'أكثر من 180 يوم'
                END AS OVERDUE_PERIOD,
                COUNT(*) AS CONTRACT_COUNT,
                SUM(REMAINING_AMOUNT) AS RISK_AMOUNT,
                ROUND(SUM(REMAINING_AMOUNT) / NULLIF(v_total_portfolio, 0) * 100, 2) AS PERCENTAGE,
                CASE 
                    WHEN MAX_DAYS_OVERDUE = 0 THEN 'منخفض'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 1 AND 30 THEN 'منخفض'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 31 AND 60 THEN 'متوسط'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 61 AND 90 THEN 'متوسط'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 91 AND 180 THEN 'مرتفع'
                    ELSE 'مرتفع جداً'
                END AS RISK_LEVEL
            FROM (
                SELECT 
                    f.FINANCING_ID,
                    f.REMAINING_AMOUNT,
                    NVL(MAX(CASE WHEN i.INSTALLMENT_STATUS = 'OVERDUE' AND i.DUE_DATE <= p_as_of_date
                        THEN TRUNC(p_as_of_date) - TRUNC(i.DUE_DATE)
                        ELSE 0
                    END), 0) AS MAX_DAYS_OVERDUE
                FROM 
                    FINANCING_CONTRACTS f
                    LEFT JOIN INSTALLMENT_SCHEDULE i ON f.REQUEST_ID = i.REQUEST_ID
                WHERE 
                    f.CONTRACT_STATUS = 'ACTIVE'
                GROUP BY 
                    f.FINANCING_ID, f.REMAINING_AMOUNT
            )
            GROUP BY 
                CASE 
                    WHEN MAX_DAYS_OVERDUE = 0 THEN 'لا يوجد تأخير'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 1 AND 30 THEN '1-30 يوم'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 31 AND 60 THEN '31-60 يوم'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 61 AND 90 THEN '61-90 يوم'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 91 AND 180 THEN '91-180 يوم'
                    ELSE 'أكثر من 180 يوم'
                END,
                CASE 
                    WHEN MAX_DAYS_OVERDUE = 0 THEN 'منخفض'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 1 AND 30 THEN 'منخفض'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 31 AND 60 THEN 'متوسط'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 61 AND 90 THEN 'متوسط'
                    WHEN MAX_DAYS_OVERDUE BETWEEN 91 AND 180 THEN 'مرتفع'
                    ELSE 'مرتفع جداً'
                END
            ORDER BY 
                MIN(MAX_DAYS_OVERDUE)
        ) LOOP
            v_report_data := v_report_data || '<tr class="' || 
                CASE 
                    WHEN rec.RISK_LEVEL = 'مرتفع' OR rec.RISK_LEVEL = 'مرتفع جداً' THEN 'high-risk'
                    WHEN rec.RISK_LEVEL = 'متوسط' THEN 'medium-risk'
                    ELSE 'low-risk'
                END || '">';
            v_report_data := v_report_data || '<td>' || rec.OVERDUE_PERIOD || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.RISK_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || rec.RISK_LEVEL || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل المخاطر حسب نوع التمويل
        v_report_data := v_report_data || '<h3>تحليل المخاطر حسب نوع التمويل</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>نوع التمويل</th><th>إجمالي المحفظة</th><th>قيمة المخاطر</th><th>نسبة المخاطر</th><th>عدد العقود المتأخرة</th><th>نسبة العقود المتأخرة</th></tr>';
        
        -- استعلام عن تحليل المخاطر حسب نوع التمويل
        FOR rec IN (
            SELECT 
                f.FINANCING_TYPE,
                SUM(f.REMAINING_AMOUNT) AS TOTAL_PORTFOLIO,
                SUM(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN f.REMAINING_AMOUNT ELSE 0 END) AS RISK_AMOUNT,
                ROUND(SUM(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN f.REMAINING_AMOUNT ELSE 0 END) / NULLIF(SUM(f.REMAINING_AMOUNT), 0) * 100, 2) AS RISK_PERCENTAGE,
                COUNT(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN 1 END) AS OVERDUE_CONTRACTS,
                ROUND(COUNT(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN 1 END) / NULLIF(COUNT(*), 0) * 100, 2) AS OVERDUE_PERCENTAGE
            FROM 
                FINANCING_CONTRACTS f
            WHERE 
                f.CONTRACT_STATUS = 'ACTIVE'
            GROUP BY 
                f.FINANCING_TYPE
            ORDER BY 
                SUM(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN f.REMAINING_AMOUNT ELSE 0 END) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_TYPE || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_PORTFOLIO, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.RISK_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.RISK_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || rec.OVERDUE_CONTRACTS || '</td>';
            v_report_data := v_report_data || '<td>' || rec.OVERDUE_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل المخاطر حسب تصنيف العملاء
        v_report_data := v_report_data || '<h3>تحليل المخاطر حسب تصنيف العملاء</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>تصنيف العميل</th><th>إجمالي المحفظة</th><th>قيمة المخاطر</th><th>نسبة المخاطر</th><th>عدد العملاء المتأخرين</th><th>نسبة العملاء المتأخرين</th></tr>';
        
        -- استعلام عن تحليل المخاطر حسب تصنيف العملاء
        FOR rec IN (
            SELECT 
                c.CUSTOMER_CLASSIFICATION,
                SUM(f.REMAINING_AMOUNT) AS TOTAL_PORTFOLIO,
                SUM(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN f.REMAINING_AMOUNT ELSE 0 END) AS RISK_AMOUNT,
                ROUND(SUM(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN f.REMAINING_AMOUNT ELSE 0 END) / NULLIF(SUM(f.REMAINING_AMOUNT), 0) * 100, 2) AS RISK_PERCENTAGE,
                COUNT(DISTINCT CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN c.CUSTOMER_ID END) AS OVERDUE_CUSTOMERS,
                ROUND(COUNT(DISTINCT CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN c.CUSTOMER_ID END) / NULLIF(COUNT(DISTINCT c.CUSTOMER_ID), 0) * 100, 2) AS OVERDUE_PERCENTAGE
            FROM 
                CUSTOMERS c
                JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
            WHERE 
                f.CONTRACT_STATUS = 'ACTIVE'
            GROUP BY 
                c.CUSTOMER_CLASSIFICATION
            ORDER BY 
                SUM(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN f.REMAINING_AMOUNT ELSE 0 END) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_CLASSIFICATION || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_PORTFOLIO, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.RISK_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.RISK_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || rec.OVERDUE_CUSTOMERS || '</td>';
            v_report_data := v_report_data || '<td>' || rec.OVERDUE_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- قائمة أعلى 10 عقود متأخرة
        v_report_data := v_report_data || '<h3>أعلى 10 عقود متأخرة</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>رقم العقد</th><th>اسم العميل</th><th>نوع التمويل</th><th>المبلغ المتبقي</th><th>عدد أيام التأخير</th><th>المبلغ المتأخر</th><th>نسبة المبلغ المتأخر</th></tr>';
        
        -- استعلام عن أعلى 10 عقود متأخرة
        FOR rec IN (
            SELECT 
                f.FINANCING_ID,
                c.FULL_NAME AS CUSTOMER_NAME,
                f.FINANCING_ID,
                c.FULL_NAME AS CUSTOMER_NAME,
                f.FINANCING_TYPE,
                f.REMAINING_AMOUNT,
                MAX(TRUNC(p_as_of_date) - TRUNC(i.DUE_DATE)) AS DAYS_OVERDUE,
                SUM(CASE WHEN i.INSTALLMENT_STATUS = 'OVERDUE' AND i.DUE_DATE <= p_as_of_date
                    THEN i.INSTALLMENT_AMOUNT ELSE 0 END) AS OVERDUE_AMOUNT,
                ROUND(SUM(CASE WHEN i.INSTALLMENT_STATUS = 'OVERDUE' AND i.DUE_DATE <= p_as_of_date
                    THEN i.INSTALLMENT_AMOUNT ELSE 0 END) / NULLIF(f.REMAINING_AMOUNT, 0) * 100, 2) AS OVERDUE_PERCENTAGE
            FROM 
                FINANCING_CONTRACTS f
                JOIN CUSTOMERS c ON f.CUSTOMER_ID = c.CUSTOMER_ID
                JOIN INSTALLMENT_SCHEDULE i ON f.REQUEST_ID = i.REQUEST_ID
            WHERE 
                f.CONTRACT_STATUS = 'ACTIVE'
                AND i.INSTALLMENT_STATUS = 'OVERDUE'
                AND i.DUE_DATE <= p_as_of_date
            GROUP BY 
                f.FINANCING_ID, c.FULL_NAME, f.FINANCING_TYPE, f.REMAINING_AMOUNT
            ORDER BY 
                SUM(CASE WHEN i.INSTALLMENT_STATUS = 'OVERDUE' AND i.DUE_DATE <= p_as_of_date
                    THEN i.INSTALLMENT_AMOUNT ELSE 0 END) DESC
            FETCH FIRST 10 ROWS ONLY
        ) LOOP
            v_report_data := v_report_data || '<tr class="' || 
                CASE 
                    WHEN rec.DAYS_OVERDUE > 90 THEN 'high-risk'
                    WHEN rec.DAYS_OVERDUE > 30 THEN 'medium-risk'
                    ELSE 'low-risk'
                END || '">';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_ID || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_TYPE || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.REMAINING_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.DAYS_OVERDUE || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.OVERDUE_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.OVERDUE_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_NAME, REPORT_DESCRIPTION, 
            REPORT_QUERY, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'RISK_ANALYSIS', 'تقرير تحليل المخاطر', 
            'تقرير تحليل المخاطر كما في ' || TO_CHAR(p_as_of_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_as_of_date, p_as_of_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_RISK_ANALYSIS_REPORT;
    */
    /*
    -- إنشاء تقرير التدفقات النقدية المتوقعة
    PROCEDURE GENERATE_CASH_FLOW_FORECAST_REPORT(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_inflow NUMBER := 0;
        v_total_outflow NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير التدفقات النقدية المتوقعة</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
            .inflow { color: green; }
            .outflow { color: red; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير التدفقات النقدية المتوقعة</h2>';
        v_report_data := v_report_data || '<p>للفترة من: ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى: ' || TO_CHAR(p_end_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- التدفقات النقدية الشهرية
        v_report_data := v_report_data || '<h3>التدفقات النقدية الشهرية</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>الشهر</th><th>التدفقات الواردة</th><th>التدفقات الصادرة</th><th>صافي التدفق</th><th>التدفق التراكمي</th></tr>';
        
        -- استعلام عن التدفقات النقدية الشهرية
        FOR rec IN (
            WITH MONTHS AS (
                SELECT 
                    ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1) AS MONTH_START,
                    LAST_DAY(ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1)) AS MONTH_END
                FROM DUAL
                CONNECT BY LEVEL <= MONTHS_BETWEEN(TRUNC(p_end_date, 'MM'), TRUNC(p_start_date, 'MM')) + 1
            ),
            INFLOWS AS (
                SELECT 
                    TRUNC(i.DUE_DATE, 'MM') AS MONTH_START,
                    SUM(i.INSTALLMENT_AMOUNT) AS AMOUNT
                FROM 
                    INSTALLMENT_SCHEDULE i
                WHERE 
                    i.DUE_DATE BETWEEN p_start_date AND p_end_date
                    AND i.INSTALLMENT_STATUS IN ('PENDING', 'PARTIAL')
                GROUP BY 
                    TRUNC(i.DUE_DATE, 'MM')
            ),
            OUTFLOWS AS (
                SELECT 
                    TRUNC(e.EXPECTED_DATE, 'MM') AS MONTH_START,
                    SUM(e.AMOUNT) AS AMOUNT
                FROM 
                    EXPECTED_EXPENSES e
                WHERE 
                    e.EXPECTED_DATE BETWEEN p_start_date AND p_end_date
                GROUP BY 
                    TRUNC(e.EXPECTED_DATE, 'MM')
            )
            SELECT 
                TO_CHAR(m.MONTH_START, 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ARABIC') AS MONTH_NAME,
                NVL(i.AMOUNT, 0) AS INFLOW,
                NVL(o.AMOUNT, 0) AS OUTFLOW,
                NVL(i.AMOUNT, 0) - NVL(o.AMOUNT, 0) AS NET_FLOW,
                SUM(NVL(i.AMOUNT, 0) - NVL(o.AMOUNT, 0)) OVER (ORDER BY m.MONTH_START) AS CUMULATIVE_FLOW
            FROM 
                MONTHS m
                LEFT JOIN INFLOWS i ON m.MONTH_START = i.MONTH_START
                LEFT JOIN OUTFLOWS o ON m.MONTH_START = o.MONTH_START
            ORDER BY 
                m.MONTH_START
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.MONTH_NAME || '</td>';
            v_report_data := v_report_data || '<td class="inflow">' || TO_CHAR(rec.INFLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td class="outflow">' || TO_CHAR(rec.OUTFLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.NET_FLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.CUMULATIVE_FLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
            
            v_total_inflow := v_total_inflow + rec.INFLOW;
            v_total_outflow := v_total_outflow + rec.OUTFLOW;
        END LOOP;
        
        v_report_data := v_report_data || '<tr class="summary">';
        v_report_data := v_report_data || '<td>الإجمالي</td>';
        v_report_data := v_report_data || '<td class="inflow">' || TO_CHAR(v_total_inflow, '999,999,999.99') || '</td>';
        v_report_data := v_report_data || '<td class="outflow">' || TO_CHAR(v_total_outflow, '999,999,999.99') || '</td>';
        v_report_data := v_report_data || '<td>' || TO_CHAR(v_total_inflow - v_total_outflow, '999,999,999.99') || '</td>';
        v_report_data := v_report_data || '<td></td>';
        v_report_data := v_report_data || '</tr>';
        
        v_report_data := v_report_data || '</table>';
        
        -- التدفقات النقدية حسب نوع التمويل
        v_report_data := v_report_data || '<h3>التدفقات النقدية الواردة حسب نوع التمويل</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>نوع التمويل</th><th>التدفقات الواردة</th><th>النسبة من الإجمالي</th></tr>';
        
        -- استعلام عن التدفقات النقدية حسب نوع التمويل
        FOR rec IN (
            SELECT 
                f.FINANCING_TYPE,
                SUM(i.INSTALLMENT_AMOUNT) AS INFLOW,
                ROUND(SUM(i.INSTALLMENT_AMOUNT) / NULLIF(v_total_inflow, 0) * 100, 2) AS PERCENTAGE
            FROM 
                INSTALLMENT_SCHEDULE i
                JOIN FINANCING_CONTRACTS f ON i.FINANCING_ID = f.FINANCING_ID
            WHERE 
                i.DUE_DATE BETWEEN p_start_date AND p_end_date
                AND i.INSTALLMENT_STATUS IN ('PENDING', 'PARTIAL')
            GROUP BY 
                f.FINANCING_TYPE
            ORDER BY 
                SUM(i.INSTALLMENT_AMOUNT) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_TYPE || '</td>';
            v_report_data := v_report_data || '<td class="inflow">' || TO_CHAR(rec.INFLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- التدفقات النقدية الصادرة حسب النوع
        v_report_data := v_report_data || '<h3>التدفقات النقدية الصادرة حسب النوع</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>نوع المصروف</th><th>التدفقات الصادرة</th><th>النسبة من الإجمالي</th></tr>';
        
        -- استعلام عن التدفقات النقدية الصادرة حسب النوع
        FOR rec IN (
            SELECT 
                e.EXPENSE_TYPE,
                SUM(e.AMOUNT) AS OUTFLOW,
                ROUND(SUM(e.AMOUNT) / NULLIF(v_total_outflow, 0) * 100, 2) AS PERCENTAGE
            FROM 
                EXPECTED_EXPENSES e
            WHERE 
                e.EXPECTED_DATE BETWEEN p_start_date AND p_end_date
            GROUP BY 
                e.EXPENSE_TYPE
            ORDER BY 
                SUM(e.AMOUNT) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.EXPENSE_TYPE || '</td>';
            v_report_data := v_report_data || '<td class="outflow">' || TO_CHAR(rec.OUTFLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل التدفقات النقدية الأسبوعية
        v_report_data := v_report_data || '<h3>تحليل التدفقات النقدية الأسبوعية</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>الأسبوع</th><th>التدفقات الواردة</th><th>التدفقات الصادرة</th><th>صافي التدفق</th></tr>';
        
        -- استعلام عن التدفقات النقدية الأسبوعية
        FOR rec IN (
            WITH WEEKS AS (
                SELECT 
                    TRUNC(p_start_date, 'IW') + (LEVEL-1)*7 AS WEEK_START,
                    LEAST(TRUNC(p_start_date, 'IW') + (LEVEL*7) - 1, p_end_date) AS WEEK_END
                FROM DUAL
                CONNECT BY LEVEL <= CEIL((p_end_date - TRUNC(p_start_date, 'IW') + 1) / 7)
            ),
            INFLOWS AS (
                SELECT 
                    TRUNC(i.DUE_DATE, 'IW') AS WEEK_START,
                    SUM(i.INSTALLMENT_AMOUNT) AS AMOUNT
                FROM 
                    INSTALLMENT_SCHEDULE i
                WHERE 
                    i.DUE_DATE BETWEEN p_start_date AND p_end_date
                    AND i.INSTALLMENT_STATUS IN ('PENDING', 'PARTIAL')
                GROUP BY 
                    TRUNC(i.DUE_DATE, 'IW')
            ),
            OUTFLOWS AS (
                SELECT 
                    TRUNC(e.EXPECTED_DATE, 'IW') AS WEEK_START,
                    SUM(e.AMOUNT) AS AMOUNT
                FROM 
                    EXPECTED_EXPENSES e
                WHERE 
                    e.EXPECTED_DATE BETWEEN p_start_date AND p_end_date
                GROUP BY 
                    TRUNC(e.EXPECTED_DATE, 'IW')
            )
            SELECT 
                'من ' || TO_CHAR(w.WEEK_START, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(w.WEEK_END, 'DD/MM/YYYY') AS WEEK_RANGE,
                NVL(i.AMOUNT, 0) AS INFLOW,
                NVL(o.AMOUNT, 0) AS OUTFLOW,
                NVL(i.AMOUNT, 0) - NVL(o.AMOUNT, 0) AS NET_FLOW
            FROM 
                WEEKS w
                LEFT JOIN INFLOWS i ON w.WEEK_START = i.WEEK_START
                LEFT JOIN OUTFLOWS o ON w.WEEK_START = o.WEEK_START
            ORDER BY 
                w.WEEK_START
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.WEEK_RANGE || '</td>';
            v_report_data := v_report_data || '<td class="inflow">' || TO_CHAR(rec.INFLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td class="outflow">' || TO_CHAR(rec.OUTFLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.NET_FLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- أيام الذروة للتدفقات النقدية
        v_report_data := v_report_data || '<h3>أيام الذروة للتدفقات النقدية</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>التاريخ</th><th>اليوم</th><th>التدفقات الواردة</th><th>عدد الأقساط</th><th>متوسط قيمة القسط</th></tr>';
        
        -- استعلام عن أيام الذروة للتدفقات النقدية
        FOR rec IN (
            SELECT 
                i.DUE_DATE,
                TO_CHAR(i.DUE_DATE, 'Day', 'NLS_DATE_LANGUAGE=ARABIC') AS DAY_NAME,
                SUM(i.INSTALLMENT_AMOUNT) AS INFLOW,
                COUNT(*) AS INSTALLMENT_COUNT,
                ROUND(SUM(i.INSTALLMENT_AMOUNT) / COUNT(*), 2) AS AVG_INSTALLMENT
            FROM 
                INSTALLMENT_SCHEDULE i
            WHERE 
                i.DUE_DATE BETWEEN p_start_date AND p_end_date
                AND i.INSTALLMENT_STATUS IN ('PENDING', 'PARTIAL')
            GROUP BY 
                i.DUE_DATE, TO_CHAR(i.DUE_DATE, 'Day', 'NLS_DATE_LANGUAGE=ARABIC')
            ORDER BY 
                SUM(i.INSTALLMENT_AMOUNT) DESC
            FETCH FIRST 10 ROWS ONLY
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.DUE_DATE, 'DD/MM/YYYY') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.DAY_NAME || '</td>';
            v_report_data := v_report_data || '<td class="inflow">' || TO_CHAR(rec.INFLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.INSTALLMENT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_INSTALLMENT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل التدفقات النقدية حسب احتمالية التحصيل
        v_report_data := v_report_data || '<h3>تحليل التدفقات النقدية حسب احتمالية التحصيل</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>احتمالية التحصيل</th><th>التدفقات الواردة</th><th>النسبة من الإجمالي</th><th>عدد الأقساط</th></tr>';
        
        -- استعلام عن التدفقات النقدية حسب احتمالية التحصيل
        FOR rec IN (
            SELECT 
                CASE 
                    WHEN c.PAYMENT_HISTORY = 'REGULAR' THEN 'مرتفعة (عميل منتظم)'
                    WHEN c.PAYMENT_HISTORY = 'OCCASIONAL_DELAY' THEN 'متوسطة (تأخير عرضي)'
                    WHEN c.PAYMENT_HISTORY = 'FREQUENT_DELAY' THEN 'منخفضة (تأخير متكرر)'
                    ELSE 'غير معروفة'
                END AS COLLECTION_PROBABILITY,
                SUM(i.INSTALLMENT_AMOUNT) AS INFLOW,
                ROUND(SUM(i.INSTALLMENT_AMOUNT) / NULLIF(v_total_inflow, 0) * 100, 2) AS PERCENTAGE,
                COUNT(*) AS INSTALLMENT_COUNT
            FROM 
                INSTALLMENT_SCHEDULE i
                JOIN FINANCING_CONTRACTS f ON i.FINANCING_ID = f.FINANCING_ID
                JOIN CUSTOMERS c ON f.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE 
                i.DUE_DATE BETWEEN p_start_date AND p_end_date
                AND i.INSTALLMENT_STATUS IN ('PENDING', 'PARTIAL')
            GROUP BY 
                CASE 
                    WHEN c.PAYMENT_HISTORY = 'REGULAR' THEN 'مرتفعة (عميل منتظم)'
                    WHEN c.PAYMENT_HISTORY = 'OCCASIONAL_DELAY' THEN 'متوسطة (تأخير عرضي)'
                    WHEN c.PAYMENT_HISTORY = 'FREQUENT_DELAY' THEN 'منخفضة (تأخير متكرر)'
                    ELSE 'غير معروفة'
                END
            ORDER BY 
                CASE 
                    WHEN c.PAYMENT_HISTORY = 'REGULAR' THEN 1
                    WHEN c.PAYMENT_HISTORY = 'OCCASIONAL_DELAY' THEN 2
                    WHEN c.PAYMENT_HISTORY = 'FREQUENT_DELAY' THEN 3
                    ELSE 4
                END
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.COLLECTION_PROBABILITY || '</td>';
            v_report_data := v_report_data || '<td class="inflow">' || TO_CHAR(rec.INFLOW, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || rec.INSTALLMENT_COUNT || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_TITLE, REPORT_DESCRIPTION, 
            REPORT_CONTENT, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'CASH_FLOW_FORECAST', 'تقرير التدفقات النقدية المتوقعة', 
            'تقرير التدفقات النقدية المتوقعة للفترة من ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(p_end_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_start_date, p_end_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_CASH_FLOW_FORECAST_REPORT;
    */
    /*
    -- إنشاء تقرير أداء الموظفين
    PROCEDURE GENERATE_EMPLOYEE_PERFORMANCE_REPORT(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_contracts NUMBER := 0;
        v_total_amount NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير أداء الموظفين</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
            .top-performer { background-color: #ccffcc; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير أداء الموظفين</h2>';
        v_report_data := v_report_data || '<p>للفترة من: ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى: ' || TO_CHAR(p_end_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- حساب إجمالي العقود والمبالغ
        SELECT 
            COUNT(*),
            SUM(FINANCING_AMOUNT)
        INTO 
            v_total_contracts, v_total_amount
        FROM 
            FINANCING_CONTRACTS
        WHERE 
            START_DATE BETWEEN p_start_date AND p_end_date;
        
        -- ملخص أداء الموظفين
        v_report_data := v_report_data || '<h3>ملخص أداء الموظفين</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>اسم الموظف</th><th>عدد العقود</th><th>النسبة من الإجمالي</th><th>إجمالي قيمة التمويل</th><th>النسبة من الإجمالي</th><th>متوسط قيمة العقد</th></tr>';
        
        -- استعلام عن أداء الموظفين
        FOR rec IN (
            SELECT 
                e.USERNAME AS EMPLOYEE_NAME,
                COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                ROUND(COUNT(f.FINANCING_ID) / NULLIF(v_total_contracts, 0) * 100, 2) AS CONTRACT_PERCENTAGE,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_AMOUNT,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(v_total_amount, 0) * 100, 2) AS AMOUNT_PERCENTAGE,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(COUNT(f.FINANCING_ID), 0), 2) AS AVG_CONTRACT_AMOUNT
            FROM 
                USERS e
                LEFT JOIN FINANCING_CONTRACTS f ON e.USER_ID = f.CREATED_BY
                AND f.START_DATE BETWEEN p_start_date AND p_end_date
            WHERE 
                e.DEPARTMENT = 'SALES'
            GROUP BY 
                e.FULL_NAME
            ORDER BY 
                SUM(f.FINANCING_AMOUNT) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.EMPLOYEE_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.AMOUNT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_CONTRACT_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل أداء الموظفين حسب نوع التمويل
        v_report_data := v_report_data || '<h3>تحليل أداء الموظفين حسب نوع التمويل</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>اسم الموظف</th><th>نوع التمويل</th><th>عدد العقود</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة العقد</th></tr>';
        
        -- استعلام عن أداء الموظفين حسب نوع التمويل
        FOR rec IN (
            SELECT 
                e.FULL_NAME AS EMPLOYEE_NAME,
                f.FINANCING_TYPE,
                COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_AMOUNT,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(COUNT(f.FINANCING_ID), 0), 2) AS AVG_CONTRACT_AMOUNT
            FROM 
                USERS e
                JOIN FINANCING_CONTRACTS f ON e.USER_ID = f.CREATED_BY
            WHERE 
                e.DEPARTMENT = 'SALES'
                AND f.START_DATE BETWEEN p_start_date AND p_end_date
            GROUP BY 
                e.FULL_NAME, f.FINANCING_TYPE
            ORDER BY 
                e.FULL_NAME, SUM(f.FINANCING_AMOUNT) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.EMPLOYEE_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_TYPE || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_CONTRACT_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل أداء الموظفين شهرياً
        v_report_data := v_report_data || '<h3>تحليل أداء الموظفين شهرياً</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>الشهر</th><th>اسم الموظف</th><th>عدد العقود</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة العقد</th></tr>';
        
        -- استعلام عن أداء الموظفين شهرياً
        FOR rec IN (
            WITH MONTHS AS (
                SELECT 
                    ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1) AS MONTH_START,
                    LAST_DAY(ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1)) AS MONTH_END,
                    TO_CHAR(ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1), 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ARABIC') AS MONTH_NAME
                FROM DUAL
                CONNECT BY LEVEL <= MONTHS_BETWEEN(TRUNC(p_end_date, 'MM'), TRUNC(p_start_date, 'MM')) + 1
            )
            SELECT 
                m.MONTH_NAME,
                e.USERNAME AS EMPLOYEE_NAME,
                COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_AMOUNT,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(COUNT(f.FINANCING_ID), 0), 2) AS AVG_CONTRACT_AMOUNT,
                RANK() OVER (PARTITION BY m.MONTH_START ORDER BY SUM(f.FINANCING_AMOUNT) DESC) AS RANK
            FROM 
                MONTHS m
                CROSS JOIN USERS e
                LEFT JOIN FINANCING_CONTRACTS f ON e.USER_ID = f.CREATED_BY
                    AND f.START_DATE BETWEEN m.MONTH_START AND m.MONTH_END
            WHERE 
                e.DEPARTMENT = 'SALES'
            GROUP BY 
                m.MONTH_NAME, m.MONTH_START, e.FULL_NAME
            ORDER BY 
                m.MONTH_START, SUM(f.FINANCING_AMOUNT) DESC NULLS LAST
        ) LOOP
            v_report_data := v_report_data || '<tr' || CASE WHEN rec.RANK = 1 THEN ' class="top-performer"' ELSE '' END || '>';
            v_report_data := v_report_data || '<td>' || rec.MONTH_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.EMPLOYEE_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_CONTRACT_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل معدل تحويل العملاء المحتملين
        v_report_data := v_report_data || '<h3>تحليل معدل تحويل العملاء المحتملين</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>اسم الموظف</th><th>عدد العملاء المحتملين</th><th>عدد العقود المبرمة</th><th>معدل التحويل</th><th>متوسط وقت التحويل (أيام)</th></tr>';
        
        -- استعلام عن معدل تحويل العملاء المحتملين
        FOR rec IN (
            SELECT 
                e.USER_NAME AS EMPLOYEE_NAME,
                COUNT(l.LEAD_ID) AS LEAD_COUNT,
                COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                ROUND(COUNT(f.FINANCING_ID) / NULLIF(COUNT(l.LEAD_ID), 0) * 100, 2) AS CONVERSION_RATE,
                ROUND(AVG(CASE WHEN f.FINANCING_ID IS NOT NULL THEN f.CONTRACT_DATE - l.LEAD_DATE END), 1) AS AVG_CONVERSION_DAYS
            FROM 
                USERS e
                LEFT JOIN LEADS l ON e.USER_ID = l.ASSIGNED_TO
                    AND l.LEAD_DATE BETWEEN p_start_date AND p_end_date
                LEFT JOIN FINANCING_CONTRACTS f ON l.LEAD_ID = f.LEAD_ID
                    AND f.CONTRACT_DATE BETWEEN p_start_date AND p_end_date
            WHERE 
                e.DEPARTMENT = 'SALES'
            GROUP BY 
                e.FULL_NAME
            ORDER BY 
                ROUND(COUNT(f.FINANCING_ID) / NULLIF(COUNT(l.LEAD_ID), 0) * 100, 2) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.EMPLOYEE_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.LEAD_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONVERSION_RATE || '%</td>';
            v_report_data := v_report_data || '<td>' || rec.AVG_CONVERSION_DAYS || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل جودة العقود
        v_report_data := v_report_data || '<h3>تحليل جودة العقود</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>اسم الموظف</th><th>إجمالي العقود</th><th>العقود المنتظمة</th><th>العقود المتأخرة</th><th>نسبة العقود المنتظمة</th></tr>';
        
        -- استعلام عن جودة العقود
        FOR rec IN (
            SELECT 
                e.FULL_NAME AS EMPLOYEE_NAME,
                COUNT(f.FINANCING_ID) AS TOTAL_CONTRACTS,
                COUNT(CASE WHEN NOT EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.FINANCING_ID = f.FINANCING_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                ) THEN 1 END) AS REGULAR_CONTRACTS,
                COUNT(CASE WHEN EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.FINANCING_ID = f.FINANCING_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                ) THEN 1 END) AS OVERDUE_CONTRACTS,
                ROUND(COUNT(CASE WHEN NOT EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.FINANCING_ID = f.FINANCING_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                ) THEN 1 END) / NULLIF(COUNT(f.FINANCING_ID), 0) * 100, 2) AS REGULAR_PERCENTAGE
            FROM 
                EMPLOYEES e
                LEFT JOIN FINANCING_CONTRACTS f ON e.EMPLOYEE_ID = f.CREATED_BY
                    AND f.CONTRACT_DATE BETWEEN p_start_date AND p_end_date
            WHERE 
                e.DEPARTMENT = 'SALES'
            GROUP BY 
                e.FULL_NAME
            ORDER BY 
                ROUND(COUNT(CASE WHEN NOT EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.FINANCING_ID = f.FINANCING_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                ) THEN 1 END) / NULLIF(COUNT(f.FINANCING_ID), 0) * 100, 2) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.EMPLOYEE_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.TOTAL_CONTRACTS || '</td>';
            v_report_data := v_report_data || '<td>' || rec.REGULAR_CONTRACTS || '</td>';
            v_report_data := v_report_data || '<td>' || rec.OVERDUE_CONTRACTS || '</td>';
            v_report_data := v_report_data || '<td>' || rec.REGULAR_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_TITLE, REPORT_DESCRIPTION, 
            REPORT_CONTENT, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'EMPLOYEE_PERFORMANCE', 'تقرير أداء الموظفين', 
            'تقرير أداء الموظفين للفترة من ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(p_end_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_start_date, p_end_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_EMPLOYEE_PERFORMANCE_REPORT;
    */
    -- استرجاع تقرير
    FUNCTION GET_REPORT(p_report_id IN NUMBER) RETURN CLOB IS
        v_report_content CLOB;
    BEGIN
        SELECT REPORT_QUERY
        INTO v_report_content
        FROM REPORTS
        WHERE REPORT_ID = p_report_id;
        
        RETURN v_report_content;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN '<html><body><h1>خطأ</h1><p>التقرير غير موجود</p></body></html>';
    END GET_REPORT;
    
    -- إنشاء تقرير تحليل المحفظة
    PROCEDURE GENERATE_PORTFOLIO_ANALYSIS_REPORT(
        p_as_of_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_portfolio NUMBER := 0;
        v_total_contracts NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- حساب إجمالي المحفظة وعدد العقود
        SELECT 
            SUM(REMAINING_AMOUNT),
            COUNT(*)
        INTO 
            v_total_portfolio, v_total_contracts
        FROM 
            FINANCING_CONTRACTS
        WHERE 
            CONTRACT_STATUS = 'ACTIVE';
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير تحليل المحفظة</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
            .chart-container { width: 100%; height: 400px; margin-bottom: 20px; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير تحليل المحفظة</h2>';
        v_report_data := v_report_data || '<p>كما في: ' || TO_CHAR(p_as_of_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- ملخص المحفظة
        v_report_data := v_report_data || '<h3>ملخص المحفظة</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>البند</th><th>القيمة</th></tr>';
        v_report_data := v_report_data || '<tr><td>إجمالي قيمة المحفظة</td><td>' || TO_CHAR(v_total_portfolio, '999,999,999.99') || '</td></tr>';
        v_report_data := v_report_data || '<tr><td>عدد العقود النشطة</td><td>' || v_total_contracts || '</td></tr>';
        v_report_data := v_report_data || '<tr><td>متوسط قيمة العقد</td><td>' || TO_CHAR(v_total_portfolio / NULLIF(v_total_contracts, 0), '999,999,999.99') || '</td></tr>';
        
        -- استعلام عن إحصائيات المحفظة
        FOR rec IN (
            SELECT 
                'نسبة العقود المنتظمة' AS ITEM,
                ROUND(COUNT(CASE WHEN NOT EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_as_of_date
                ) THEN 1 END) / NULLIF(COUNT(*), 0) * 100, 2) || '%' AS VALUE
            FROM 
                FINANCING_CONTRACTS f
            WHERE 
                f.CONTRACT_STATUS = 'ACTIVE'
            UNION ALL
            SELECT 
                'متوسط مدة التمويل (شهر)',
                TO_CHAR(ROUND(AVG(FINANCING_PERIOD), 1))
            FROM 
                FINANCING_CONTRACTS
            WHERE 
                CONTRACT_STATUS = 'ACTIVE'
            UNION ALL
            SELECT 
                'معدل الربح المتوسط',
                TO_CHAR(ROUND(AVG(PROFIT_RATE), 2)) || '%'
            FROM 
                FINANCING_CONTRACTS
            WHERE 
                CONTRACT_STATUS = 'ACTIVE'
        ) LOOP
            v_report_data := v_report_data || '<tr><td>' || rec.ITEM || '</td><td>' || rec.VALUE || '</td></tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- توزيع المحفظة حسب نوع التمويل
        v_report_data := v_report_data || '<h3>توزيع المحفظة حسب نوع التمويل</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>نوع التمويل</th><th>عدد العقود</th><th>النسبة من الإجمالي</th><th>قيمة المحفظة</th><th>النسبة من الإجمالي</th><th>متوسط قيمة العقد</th></tr>';
        
        -- استعلام عن توزيع المحفظة حسب نوع التمويل
        FOR rec IN (
            SELECT 
                FINANCING_TYPE,
                COUNT(*) AS CONTRACT_COUNT,
                ROUND(COUNT(*) / NULLIF(v_total_contracts, 0) * 100, 2) AS CONTRACT_PERCENTAGE,
                SUM(REMAINING_AMOUNT) AS PORTFOLIO_VALUE,
                ROUND(SUM(REMAINING_AMOUNT) / NULLIF(v_total_portfolio, 0) * 100, 2) AS PORTFOLIO_PERCENTAGE,
                ROUND(SUM(REMAINING_AMOUNT) / NULLIF(COUNT(*), 0), 2) AS AVG_CONTRACT_VALUE
            FROM 
                FINANCING_CONTRACTS
            WHERE 
                CONTRACT_STATUS = 'ACTIVE'
            GROUP BY 
                FINANCING_TYPE
            ORDER BY 
                SUM(REMAINING_AMOUNT) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_TYPE || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.PORTFOLIO_VALUE, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PORTFOLIO_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_CONTRACT_VALUE, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- توزيع المحفظة حسب مدة التمويل
        v_report_data := v_report_data || '<h3>توزيع المحفظة حسب مدة التمويل</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>مدة التمويل</th><th>عدد العقود</th><th>النسبة من الإجمالي</th><th>قيمة المحفظة</th><th>النسبة من الإجمالي</th><th>متوسط معدل الربح</th></tr>';
        
        -- استعلام عن توزيع المحفظة حسب مدة التمويل
        FOR rec IN (
            SELECT 
                CASE 
                    WHEN FINANCING_PERIOD <= 12 THEN 'حتى سنة'
                    WHEN FINANCING_PERIOD BETWEEN 13 AND 24 THEN 'سنة إلى سنتين'
                    WHEN FINANCING_PERIOD BETWEEN 25 AND 36 THEN 'سنتين إلى 3 سنوات'
                    WHEN FINANCING_PERIOD BETWEEN 37 AND 48 THEN '3 إلى 4 سنوات'
                    WHEN FINANCING_PERIOD BETWEEN 49 AND 60 THEN '4 إلى 5 سنوات'
                    ELSE 'أكثر من 5 سنوات'
                END AS PERIOD_RANGE,
                COUNT(*) AS CONTRACT_COUNT,
                ROUND(COUNT(*) / NULLIF(v_total_contracts, 0) * 100, 2) AS CONTRACT_PERCENTAGE,
                SUM(REMAINING_AMOUNT) AS PORTFOLIO_VALUE,
                ROUND(SUM(REMAINING_AMOUNT) / NULLIF(v_total_portfolio, 0) * 100, 2) AS PORTFOLIO_PERCENTAGE,
                ROUND(AVG(PROFIT_RATE), 2) AS AVG_PROFIT_RATE
            FROM 
                FINANCING_CONTRACTS
            WHERE 
                CONTRACT_STATUS = 'ACTIVE'
            GROUP BY 
                CASE 
                    WHEN FINANCING_PERIOD <= 12 THEN 'حتى سنة'
                    WHEN FINANCING_PERIOD BETWEEN 13 AND 24 THEN 'سنة إلى سنتين'
                    WHEN FINANCING_PERIOD BETWEEN 25 AND 36 THEN 'سنتين إلى 3 سنوات'
                    WHEN FINANCING_PERIOD BETWEEN 37 AND 48 THEN '3 إلى 4 سنوات'
                    WHEN FINANCING_PERIOD BETWEEN 49 AND 60 THEN '4 إلى 5 سنوات'
                    ELSE 'أكثر من 5 سنوات'
                END
            ORDER BY 
                MIN(FINANCING_PERIOD)
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.PERIOD_RANGE || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.PORTFOLIO_VALUE, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PORTFOLIO_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || rec.AVG_PROFIT_RATE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- توزيع المحفظة حسب معدل الربح
        v_report_data := v_report_data || '<h3>توزيع المحفظة حسب معدل الربح</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>معدل الربح</th><th>عدد العقود</th><th>النسبة من الإجمالي</th><th>قيمة المحفظة</th><th>النسبة من الإجمالي</th></tr>';
        
        -- استعلام عن توزيع المحفظة حسب معدل الربح
        FOR rec IN (
            SELECT 
                CASE 
                    WHEN PROFIT_RATE < 5 THEN 'أقل من 5%'
                    WHEN PROFIT_RATE BETWEEN 5 AND 7.99 THEN '5% - 7.99%'
                    WHEN PROFIT_RATE BETWEEN 8 AND 9.99 THEN '8% - 9.99%'
                    WHEN PROFIT_RATE BETWEEN 10 AND 12.99 THEN '10% - 12.99%'
                    WHEN PROFIT_RATE BETWEEN 13 AND 15.99 THEN '13% - 15.99%'
                    ELSE '16% فأكثر'
                END AS RATE_RANGE,
                COUNT(*) AS CONTRACT_COUNT,
                ROUND(COUNT(*) / NULLIF(v_total_contracts, 0) * 100, 2) AS CONTRACT_PERCENTAGE,
                SUM(REMAINING_AMOUNT) AS PORTFOLIO_VALUE,
                ROUND(SUM(REMAINING_AMOUNT) / NULLIF(v_total_portfolio, 0) * 100, 2) AS PORTFOLIO_PERCENTAGE
            FROM 
                FINANCING_CONTRACTS
            WHERE 
                CONTRACT_STATUS = 'ACTIVE'
            GROUP BY 
                CASE 
                    WHEN PROFIT_RATE < 5 THEN 'أقل من 5%'
                    WHEN PROFIT_RATE BETWEEN 5 AND 7.99 THEN '5% - 7.99%'
                    WHEN PROFIT_RATE BETWEEN 8 AND 9.99 THEN '8% - 9.99%'
                    WHEN PROFIT_RATE BETWEEN 10 AND 12.99 THEN '10% - 12.99%'
                    WHEN PROFIT_RATE BETWEEN 13 AND 15.99 THEN '13% - 15.99%'
                    ELSE '16% فأكثر'
                END
            ORDER BY 
                MIN(PROFIT_RATE)
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.RATE_RANGE || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.PORTFOLIO_VALUE, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PORTFOLIO_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل جودة المحفظة
        v_report_data := v_report_data || '<h3>تحليل جودة المحفظة</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>حالة التأخير</th><th>عدد العقود</th><th>النسبة من الإجمالي</th><th>قيمة المحفظة</th><th>النسبة من الإجمالي</th></tr>';
        
        -- استعلام عن جودة المحفظة
        FOR rec IN (
            WITH CONTRACT_STATUS AS (
                SELECT 
                    f.REQUEST_ID,
                    f.REMAINING_AMOUNT,
                    CASE 
                        WHEN NOT EXISTS (
                            SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                            WHERE i.REQUEST_ID = f.REQUEST_ID 
                            AND i.INSTALLMENT_STATUS = 'OVERDUE'
                            AND i.DUE_DATE <= p_as_of_date
                        ) THEN 'منتظم'
                        WHEN EXISTS (
                            SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                            WHERE i.REQUEST_ID = f.REQUEST_ID 
                            AND i.INSTALLMENT_STATUS = 'OVERDUE'
                            AND i.DUE_DATE <= p_as_of_date
                            AND TRUNC(p_as_of_date) - TRUNC(i.DUE_DATE) BETWEEN 1 AND 30
                        ) AND NOT EXISTS (
                            SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                            WHERE i.REQUEST_ID = f.REQUEST_ID 
                            AND i.INSTALLMENT_STATUS = 'OVERDUE'
                            AND i.DUE_DATE <= p_as_of_date
                            AND TRUNC(p_as_of_date) - TRUNC(i.DUE_DATE) > 30
                        ) THEN 'متأخر (1-30 يوم)'
                        WHEN EXISTS (
                            SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                            WHERE i.REQUEST_ID = f.REQUEST_ID 
                            AND i.INSTALLMENT_STATUS = 'OVERDUE'
                            AND i.DUE_DATE <= p_as_of_date
                            AND TRUNC(p_as_of_date) - TRUNC(i.DUE_DATE) BETWEEN 31 AND 90
                        ) AND NOT EXISTS (
                            SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                            WHERE i.REQUEST_ID = f.REQUEST_ID 
                            AND i.INSTALLMENT_STATUS = 'OVERDUE'
                            AND i.DUE_DATE <= p_as_of_date
                            AND TRUNC(p_as_of_date) - TRUNC(i.DUE_DATE) > 90
                        ) THEN 'متأخر (31-90 يوم)'
                        WHEN EXISTS (
                            SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                            WHERE i.REQUEST_ID = f.REQUEST_ID 
                            AND i.INSTALLMENT_STATUS = 'OVERDUE'
                            AND i.DUE_DATE <= p_as_of_date
                            AND TRUNC(p_as_of_date) - TRUNC(i.DUE_DATE) BETWEEN 91 AND 180
                        ) THEN 'متأخر (91-180 يوم)'
                        ELSE 'متأخر (أكثر من 180 يوم)'
                    END AS DELINQUENCY_STATUS
                FROM 
                    FINANCING_CONTRACTS f
                WHERE 
                    f.CONTRACT_STATUS = 'ACTIVE'
            )
            SELECT 
                DELINQUENCY_STATUS,
                COUNT(*) AS CONTRACT_COUNT,
                ROUND(COUNT(*) / NULLIF(v_total_contracts, 0) * 100, 2) AS CONTRACT_PERCENTAGE,
                SUM(REMAINING_AMOUNT) AS PORTFOLIO_VALUE,
                ROUND(SUM(REMAINING_AMOUNT) / NULLIF(v_total_portfolio, 0) * 100, 2) AS PORTFOLIO_PERCENTAGE
            FROM 
                CONTRACT_STATUS
            GROUP BY 
                DELINQUENCY_STATUS
            ORDER BY 
                CASE DELINQUENCY_STATUS
                    WHEN 'منتظم' THEN 1
                    WHEN 'متأخر (1-30 يوم)' THEN 2
                    WHEN 'متأخر (31-90 يوم)' THEN 3
                    WHEN 'متأخر (91-180 يوم)' THEN 4
                    ELSE 5
                END
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.DELINQUENCY_STATUS || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.PORTFOLIO_VALUE, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PORTFOLIO_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- توزيع المحفظة حسب العمر المتبقي
        v_report_data := v_report_data || '<h3>توزيع المحفظة حسب العمر المتبقي</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>العمر المتبقي</th><th>عدد العقود</th><th>النسبة من الإجمالي</th><th>قيمة المحفظة</th><th>النسبة من الإجمالي</th></tr>';
        
        -- استعلام عن توزيع المحفظة حسب العمر المتبقي
        FOR rec IN (
            WITH REMAINING_TERM AS (
                SELECT 
                    FINANCING_ID,
                    REMAINING_AMOUNT,
                    CASE 
                        WHEN MONTHS_BETWEEN(END_DATE, p_as_of_date) <= 6 THEN 'أقل من 6 أشهر'
                        WHEN MONTHS_BETWEEN(END_DATE, p_as_of_date) BETWEEN 7 AND 12 THEN '6-12 شهر'
                        WHEN MONTHS_BETWEEN(END_DATE, p_as_of_date) BETWEEN 13 AND 24 THEN '13-24 شهر'
                        WHEN MONTHS_BETWEEN(END_DATE, p_as_of_date) BETWEEN 25 AND 36 THEN '25-36 شهر'
                        WHEN MONTHS_BETWEEN(END_DATE, p_as_of_date) BETWEEN 37 AND 48 THEN '37-48 شهر'
                        WHEN MONTHS_BETWEEN(END_DATE, p_as_of_date) BETWEEN 49 AND 60 THEN '49-60 شهر'
                        ELSE 'أكثر من 60 شهر'
                    END AS REMAINING_TERM
                FROM 
                    FINANCING_CONTRACTS
                WHERE 
                    CONTRACT_STATUS = 'ACTIVE'
            )
            SELECT 
                REMAINING_TERM,
                COUNT(*) AS CONTRACT_COUNT,
                ROUND(COUNT(*) / NULLIF(v_total_contracts, 0) * 100, 2) AS CONTRACT_PERCENTAGE,
                SUM(REMAINING_AMOUNT) AS PORTFOLIO_VALUE,
                ROUND(SUM(REMAINING_AMOUNT) / NULLIF(v_total_portfolio, 0) * 100, 2) AS PORTFOLIO_PERCENTAGE
            FROM 
                REMAINING_TERM
            GROUP BY 
                REMAINING_TERM
            ORDER BY 
                CASE REMAINING_TERM
                    WHEN 'أقل من 6 أشهر' THEN 1
                    WHEN '6-12 شهر' THEN 2
                    WHEN '13-24 شهر' THEN 3
                    WHEN '25-36 شهر' THEN 4
                    WHEN '37-48 شهر' THEN 5
                    WHEN '49-60 شهر' THEN 6
                    ELSE 7
                END
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.REMAINING_TERM || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.PORTFOLIO_VALUE, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PORTFOLIO_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- أكبر 10 عقود في المحفظة
        v_report_data := v_report_data || '<h3>أكبر 10 عقود في المحفظة</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>رقم العقد</th><th>اسم العميل</th><th>نوع التمويل</th><th>قيمة التمويل</th><th>المبلغ المتبقي</th><th>نسبة السداد</th><th>تاريخ انتهاء العقد</th></tr>';
        
        -- استعلام عن أكبر 10 عقود في المحفظة
        FOR rec IN (
            SELECT 
                f.FINANCING_ID,
                c.FULL_NAME AS CUSTOMER_NAME,
                f.FINANCING_TYPE,
                f.FINANCING_AMOUNT,
                f.REMAINING_AMOUNT,
                ROUND((1 - (f.REMAINING_AMOUNT / NULLIF(f.FINANCING_AMOUNT, 0))) * 100, 2) AS REPAYMENT_PERCENTAGE,
                f.END_DATE
            FROM 
                FINANCING_CONTRACTS f
                JOIN CUSTOMERS c ON f.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE 
                f.CONTRACT_STATUS = 'ACTIVE'
            ORDER BY 
                f.REMAINING_AMOUNT DESC
            FETCH FIRST 10 ROWS ONLY
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_ID || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.FINANCING_TYPE || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.FINANCING_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.REMAINING_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.REPAYMENT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.END_DATE, 'DD/MM/YYYY') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_NAME, REPORT_DESCRIPTION, 
            REPORT_QUERY, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'PORTFOLIO_ANALYSIS', 'تقرير تحليل المحفظة', 
            'تقرير تحليل المحفظة كما في ' || TO_CHAR(p_as_of_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_as_of_date, p_as_of_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_PORTFOLIO_ANALYSIS_REPORT;
    /*
    -- إنشاء تقرير الأرباح والخسائر
    PROCEDURE GENERATE_PROFIT_LOSS_REPORT(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_revenue NUMBER := 0;
        v_total_expenses NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير الأرباح والخسائر</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
            .revenue { color: green; }
            .expense { color: red; }
            .profit { font-weight: bold; }
            .loss { font-weight: bold; color: red; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير الأرباح والخسائر</h2>';
        v_report_data := v_report_data || '<p>للفترة من: ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى: ' || TO_CHAR(p_end_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- الإيرادات
        v_report_data := v_report_data || '<h3>الإيرادات</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>مصدر الإيراد</th><th>المبلغ</th><th>النسبة من إجمالي الإيرادات</th></tr>';
        
        -- استعلام عن الإيرادات
        FOR rec IN (
            WITH REVENUE_SOURCES AS (
                -- إيرادات الأرباح من التمويل
                SELECT 
                    'أرباح التمويل' AS REVENUE_SOURCE,
                    SUM(PROFIT_AMOUNT) AS AMOUNT
                FROM 
                    PAYMENTS
                WHERE 
                    PAYMENT_DATE BETWEEN p_start_date AND p_end_date
                
                UNION ALL
                
                -- إيرادات رسوم الخدمات
                SELECT 
                    'رسوم الخدمات' AS REVENUE_SOURCE,
                    SUM(FEE_AMOUNT) AS AMOUNT
                FROM 
                    PAYMENTS
                WHERE 
                    PAYMENT_DATE BETWEEN p_start_date AND p_end_date
                
                UNION ALL
                
                -- إيرادات غرامات التأخير
                SELECT 
                    'غرامات التأخير' AS REVENUE_SOURCE,
                    SUM(LATE_PAYMENT_FEES) AS AMOUNT
                FROM 
                    PAYMENTS
                WHERE 
                    PAYMENT_DATE BETWEEN p_start_date AND p_end_date
                
                UNION ALL
                
                -- إيرادات أخرى
                SELECT 
                    'إيرادات أخرى' AS REVENUE_SOURCE,
                    SUM(AMOUNT) AS AMOUNT
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'REVENUE'
                    AND CATEGORY NOT IN ('PROFIT', 'FEES', 'LATE_FEES')
            )
            SELECT 
                REVENUE_SOURCE,
                AMOUNT,
                ROUND(AMOUNT / (SELECT SUM(AMOUNT) FROM REVENUE_SOURCES) * 100, 2) AS PERCENTAGE
            FROM 
                REVENUE_SOURCES
            WHERE 
                AMOUNT > 0
            ORDER BY 
                AMOUNT DESC
        ) LOOP
            v_total_revenue := v_total_revenue + rec.AMOUNT;
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.REVENUE_SOURCE || '</td>';
            v_report_data := v_report_data || '<td class="revenue">' || TO_CHAR(rec.AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '<tr class="summary">';
        v_report_data := v_report_data || '<td>إجمالي الإيرادات</td>';
        v_report_data := v_report_data || '<td class="revenue">' || TO_CHAR(v_total_revenue, '999,999,999.99') || '</td>';
        v_report_data := v_report_data || '<td>100%</td>';
        v_report_data := v_report_data || '</tr>';
        v_report_data := v_report_data || '</table>';
        
        -- المصروفات
        v_report_data := v_report_data || '<h3>المصروفات</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>نوع المصروف</th><th>المبلغ</th><th>النسبة من إجمالي المصروفات</th></tr>';
        
        -- استعلام عن المصروفات
        FOR rec IN (
            WITH EXPENSE_TYPES AS (
                -- مصروفات الرواتب
                SELECT 
                    'رواتب الموظفين' AS EXPENSE_TYPE,
                    SUM(AMOUNT) AS AMOUNT
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'EXPENSE'
                    AND CATEGORY = 'SALARIES'
                
                UNION ALL
                
                -- مصروفات الإيجارات
                SELECT 
                    'إيجارات' AS EXPENSE_TYPE,
                    SUM(AMOUNT) AS AMOUNT
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'EXPENSE'
                    AND CATEGORY = 'RENT'
                
                UNION ALL
                
                -- مصروفات التسويق
                SELECT 
                    'تسويق وإعلان' AS EXPENSE_TYPE,
                    SUM(AMOUNT) AS AMOUNT
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'EXPENSE'
                    AND CATEGORY = 'MARKETING'
                
                UNION ALL
                
                -- مصروفات تقنية المعلومات
                SELECT 
                    'تقنية المعلومات' AS EXPENSE_TYPE,
                    SUM(AMOUNT) AS AMOUNT
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'EXPENSE'
                    AND CATEGORY = 'IT'
                
                UNION ALL
                
                -- مصروفات الخدمات
                SELECT 
                    'خدمات ومرافق' AS EXPENSE_TYPE,
                    SUM(AMOUNT) AS AMOUNT
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'EXPENSE'
                    AND CATEGORY = 'UTILITIES'
                
                UNION ALL
                
                -- مخصصات الديون المشكوك فيها
                SELECT 
                    'مخصصات الديون المشكوك فيها' AS EXPENSE_TYPE,
                    SUM(AMOUNT) AS AMOUNT
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'EXPENSE'
                    AND CATEGORY = 'PROVISIONS'
                
                UNION ALL
                
                -- مصروفات أخرى
                SELECT 
                    'مصروفات أخرى' AS EXPENSE_TYPE,
                    SUM(AMOUNT) AS AMOUNT
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'EXPENSE'
                    AND CATEGORY NOT IN ('SALARIES', 'RENT', 'MARKETING', 'IT', 'UTILITIES', 'PROVISIONS')
            )
            SELECT 
                EXPENSE_TYPE,
                AMOUNT,
                ROUND(AMOUNT / (SELECT SUM(AMOUNT) FROM EXPENSE_TYPES) * 100, 2) AS PERCENTAGE
            FROM 
                EXPENSE_TYPES
            WHERE 
                AMOUNT > 0
            ORDER BY 
                AMOUNT DESC
        ) LOOP
            v_total_expenses := v_total_expenses + rec.AMOUNT;
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.EXPENSE_TYPE || '</td>';
            v_report_data := v_report_data || '<td class="expense">' || TO_CHAR(rec.AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '<tr class="summary">';
        v_report_data := v_report_data || '<td>إجمالي المصروفات</td>';
        v_report_data := v_report_data || '<td class="expense">' || TO_CHAR(v_total_expenses, '999,999,999.99') || '</td>';
        v_report_data := v_report_data || '<td>100%</td>';
        v_report_data := v_report_data || '</tr>';
        v_report_data := v_report_data || '</table>';
        
        -- ملخص الأرباح والخسائر
        v_report_data := v_report_data || '<h3>ملخص الأرباح والخسائر</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>البند</th><th>المبلغ</th></tr>';
        v_report_data := v_report_data || '<tr><td>إجمالي الإيرادات</td><td class="revenue">' || TO_CHAR(v_total_revenue, '999,999,999.99') || '</td></tr>';
        v_report_data := v_report_data || '<tr><td>إجمالي المصروفات</td><td class="expense">' || TO_CHAR(v_total_expenses, '999,999,999.99') || '</td></tr>';
        
        IF v_total_revenue - v_total_expenses >= 0 THEN
            v_report_data := v_report_data || '<tr><td>صافي الربح</td><td class="profit">' || TO_CHAR(v_total_revenue - v_total_expenses, '999,999,999.99') || '</td></tr>';
            v_report_data := v_report_data || '<tr><td>هامش الربح</td><td class="profit">' || TO_CHAR(ROUND((v_total_revenue - v_total_expenses) / NULLIF(v_total_revenue, 0) * 100, 2)) || '%</td></tr>';
        ELSE
            v_report_data := v_report_data || '<tr><td>صافي الخسارة</td><td class="loss">' || TO_CHAR(v_total_revenue - v_total_expenses, '999,999,999.99') || '</td></tr>';
            v_report_data := v_report_data || '<tr><td>هامش الخسارة</td><td class="loss">' || TO_CHAR(ROUND((v_total_revenue - v_total_expenses) / NULLIF(v_total_revenue, 0) * 100, 2)) || '%</td></tr>';
        END IF;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل الإيرادات والمصروفات شهرياً
        v_report_data := v_report_data || '<h3>تحليل الإيرادات والمصروفات شهرياً</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>الشهر</th><th>الإيرادات</th><th>المصروفات</th><th>صافي الربح/الخسارة</th><th>هامش الربح</th></tr>';
        
        -- استعلام عن الإيرادات والمصروفات شهرياً
        FOR rec IN (
            WITH MONTHS AS (
                SELECT 
                    ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1) AS MONTH_START,
                    LAST_DAY(ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1)) AS MONTH_END,
                    TO_CHAR(ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1), 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ARABIC') AS MONTH_NAME
                FROM DUAL
                CONNECT BY LEVEL <= MONTHS_BETWEEN(TRUNC(p_end_date, 'MM'), TRUNC(p_start_date, 'MM')) + 1
            ),
            MONTHLY_REVENUE AS (
                SELECT 
                    TRUNC(PAYMENT_DATE, 'MM') AS MONTH_START,
                    SUM(PROFIT_AMOUNT + FEE_AMOUNT + LATE_PAYMENT_FEES) AS REVENUE
                FROM 
                    PAYMENTS
                WHERE 
                    PAYMENT_DATE BETWEEN p_start_date AND p_end_date
                GROUP BY 
                    TRUNC(PAYMENT_DATE, 'MM')
                
                UNION ALL
                
                SELECT 
                    TRUNC(TRANSACTION_DATE, 'MM') AS MONTH_START,
                    SUM(AMOUNT) AS REVENUE
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'REVENUE'
                GROUP BY 
                    TRUNC(TRANSACTION_DATE, 'MM')
            ),
            MONTHLY_EXPENSE AS (
                SELECT 
                    TRUNC(TRANSACTION_DATE, 'MM') AS MONTH_START,
                    SUM(AMOUNT) AS EXPENSE
                FROM 
                    FINANCIAL_TRANSACTIONS
                WHERE 
                    TRANSACTION_DATE BETWEEN p_start_date AND p_end_date
                    AND TRANSACTION_TYPE = 'EXPENSE'
                GROUP BY 
                    TRUNC(TRANSACTION_DATE, 'MM')
            )
            SELECT 
                m.MONTH_NAME,
                NVL(SUM(r.REVENUE), 0) AS REVENUE,
                NVL(SUM(e.EXPENSE), 0) AS EXPENSE,
                NVL(SUM(r.REVENUE), 0) - NVL(SUM(e.EXPENSE), 0) AS NET_PROFIT,
                CASE 
                    WHEN NVL(SUM(r.REVENUE), 0) = 0 THEN 0
                    ELSE ROUND((NVL(SUM(r.REVENUE), 0) - NVL(SUM(e.EXPENSE), 0)) / NVL(SUM(r.REVENUE), 0) * 100, 2)
                END AS PROFIT_MARGIN
            FROM 
                MONTHS m
                LEFT JOIN MONTHLY_REVENUE r ON m.MONTH_START = r.MONTH_START
                LEFT JOIN MONTHLY_EXPENSE e ON m.MONTH_START = e.MONTH_START
            GROUP BY 
                m.MONTH_NAME, m.MONTH_START
            ORDER BY 
                m.MONTH_START
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.MONTH_NAME || '</td>';
            v_report_data := v_report_data || '<td class="revenue">' || TO_CHAR(rec.REVENUE, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td class="expense">' || TO_CHAR(rec.EXPENSE, '999,999,999.99') || '</td>';
            
            IF rec.NET_PROFIT >= 0 THEN
                v_report_data := v_report_data || '<td class="profit">' || TO_CHAR(rec.NET_PROFIT, '999,999,999.99') || '</td>';
            ELSE
                v_report_data := v_report_data || '<td class="loss">' || TO_CHAR(rec.NET_PROFIT, '999,999,999.99') || '</td>';
            END IF;
            
            IF rec.PROFIT_MARGIN >= 0 THEN
                v_report_data := v_report_data || '<td class="profit">' || rec.PROFIT_MARGIN || '%</td>';
            ELSE
                v_report_data := v_report_data || '<td class="loss">' || rec.PROFIT_MARGIN || '%</td>';
            END IF;
            
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_TITLE, REPORT_DESCRIPTION, 
            REPORT_CONTENT, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'PROFIT_LOSS', 'تقرير الأرباح والخسائر', 
            'تقرير الأرباح والخسائر للفترة من ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(p_end_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_start_date, p_end_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_PROFIT_LOSS_REPORT;
    */
    -- إنشاء تقرير تحليل العملاء
    PROCEDURE GENERATE_CUSTOMER_ANALYSIS_REPORT(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_total_customers NUMBER := 0;
        v_active_customers NUMBER := 0;
        v_new_customers NUMBER := 0;
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- حساب إحصائيات العملاء
        SELECT COUNT(*) INTO v_total_customers FROM CUSTOMERS;
        
        SELECT COUNT(*) INTO v_active_customers 
        FROM CUSTOMERS c
        WHERE EXISTS (
            SELECT 1 FROM FINANCING_CONTRACTS f
            WHERE f.CUSTOMER_ID = c.CUSTOMER_ID
            AND f.CONTRACT_STATUS = 'ACTIVE'
        );
        
        SELECT COUNT(*) INTO v_new_customers 
        FROM CUSTOMERS
        WHERE CREATION_DATE BETWEEN p_start_date AND p_end_date;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>تقرير تحليل العملاء</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
            .summary { background-color: #f9f9f9; font-weight: bold; }
            .chart-container { width: 100%; height: 400px; margin-bottom: 20px; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>تقرير تحليل العملاء</h2>';
        v_report_data := v_report_data || '<p>للفترة من: ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى: ' || TO_CHAR(p_end_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- ملخص العملاء
        v_report_data := v_report_data || '<h3>ملخص العملاء</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>البند</th><th>العدد</th><th>النسبة</th></tr>';
        v_report_data := v_report_data || '<tr><td>إجمالي العملاء</td><td>' || v_total_customers || '</td><td>100%</td></tr>';
        v_report_data := v_report_data || '<tr><td>العملاء النشطين</td><td>' || v_active_customers || '</td><td>' || 
                          ROUND(v_active_customers / NULLIF(v_total_customers, 0) * 100, 2) || '%</td></tr>';
        v_report_data := v_report_data || '<tr><td>العملاء الجدد خلال الفترة</td><td>' || v_new_customers || '</td><td>' || 
                          ROUND(v_new_customers / NULLIF(v_total_customers, 0) * 100, 2) || '%</td></tr>';
        
        -- استعلام عن إحصائيات إضافية للعملاء
        FOR rec IN (
            SELECT 
                'متوسط عدد العقود للعميل' AS ITEM,
                TO_CHAR(ROUND(COUNT(f.FINANCING_ID) / COUNT(DISTINCT f.CUSTOMER_ID), 2)) AS VALUE
            FROM 
                FINANCING_CONTRACTS f
            
            UNION ALL
            
            SELECT 
                'متوسط قيمة التمويل للعميل',
                TO_CHAR(ROUND(SUM(FINANCING_AMOUNT) / COUNT(DISTINCT CUSTOMER_ID), 2), '999,999,999.99')
            FROM 
                FINANCING_CONTRACTS
            
            UNION ALL
            
            SELECT 
                'نسبة العملاء المتأخرين في السداد',
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / NULLIF(v_active_customers, 0) * 100, 2) || '%'
            FROM 
                CUSTOMERS c
                JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
                JOIN INSTALLMENT_SCHEDULE i ON f.REQUEST_ID = i.REQUEST_ID
            WHERE 
                i.INSTALLMENT_STATUS = 'OVERDUE'
                AND i.DUE_DATE <= p_end_date
                AND f.CONTRACT_STATUS = 'ACTIVE'
        ) LOOP
            v_report_data := v_report_data || '<tr><td>' || rec.ITEM || '</td><td colspan="2">' || rec.VALUE || '</td></tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- توزيع العملاء حسب الفئة العمرية
        v_report_data := v_report_data || '<h3>توزيع العملاء حسب الفئة العمرية</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>الفئة العمرية</th><th>عدد العملاء</th><th>النسبة</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th></tr>';
        
        -- استعلام عن توزيع العملاء حسب الفئة العمرية
        FOR rec IN (
            WITH CUSTOMER_AGE AS (
                SELECT 
                    c.CUSTOMER_ID,
                    TRUNC(MONTHS_BETWEEN(SYSDATE, c.DATE_OF_BIRTH) / 12) AS AGE,
                    SUM(f.FINANCING_AMOUNT) AS TOTAL_FINANCING,
                    COUNT(f.FINANCING_ID) AS CONTRACT_COUNT
                FROM 
                    CUSTOMERS c
                    LEFT JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
                GROUP BY 
                    c.CUSTOMER_ID, TRUNC(MONTHS_BETWEEN(SYSDATE, c.DATE_OF_BIRTH) / 12)
            )
            SELECT 
                CASE 
                    WHEN AGE < 25 THEN 'أقل من 25 سنة'
                    WHEN AGE BETWEEN 25 AND 34 THEN '25-34 سنة'
                    WHEN AGE BETWEEN 35 AND 44 THEN '35-44 سنة'
                    WHEN AGE BETWEEN 45 AND 54 THEN '45-54 سنة'
                    WHEN AGE BETWEEN 55 AND 64 THEN '55-64 سنة'
                    ELSE '65 سنة فأكثر'
                END AS AGE_GROUP,
                COUNT(*) AS CUSTOMER_COUNT,
                ROUND(COUNT(*) / NULLIF(v_total_customers, 0) * 100, 2) AS PERCENTAGE,
                SUM(TOTAL_FINANCING) AS TOTAL_FINANCING,
                ROUND(SUM(TOTAL_FINANCING) / NULLIF(SUM(CONTRACT_COUNT), 0), 2) AS AVG_FINANCING
            FROM 
                CUSTOMER_AGE
            GROUP BY 
                CASE 
                    WHEN AGE < 25 THEN 'أقل من 25 سنة'
                    WHEN AGE BETWEEN 25 AND 34 THEN '25-34 سنة'
                    WHEN AGE BETWEEN 35 AND 44 THEN '35-44 سنة'
                    WHEN AGE BETWEEN 45 AND 54 THEN '45-54 سنة'
                    WHEN AGE BETWEEN 55 AND 64 THEN '55-64 سنة'
                    ELSE '65 سنة فأكثر'
                END
            ORDER BY 
                MIN(AGE)
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.AGE_GROUP || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        -- توزيع العملاء حسب الجنس
        v_report_data := v_report_data || '<h3>توزيع العملاء حسب الجنس</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>الجنس</th><th>عدد العملاء</th><th>النسبة</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th></tr>';
        
        -- استعلام عن توزيع العملاء حسب الجنس
        FOR rec IN (
            SELECT 
                CASE GENDER 
                    WHEN 'M' THEN 'ذكر'
                    WHEN 'F' THEN 'أنثى'
                    ELSE 'غير محدد'
                END AS GENDER_DESC,
                COUNT(DISTINCT c.CUSTOMER_ID) AS CUSTOMER_COUNT,
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / NULLIF(v_total_customers, 0) * 100, 2) AS PERCENTAGE,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_FINANCING,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(COUNT(f.FINANCING_ID), 0), 2) AS AVG_FINANCING
            FROM 
                CUSTOMERS c
                LEFT JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
            GROUP BY 
                c.GENDER
            ORDER BY 
                COUNT(DISTINCT c.CUSTOMER_ID) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.GENDER_DESC || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- توزيع العملاء حسب المنطقة الجغرافية
        v_report_data := v_report_data || '<h3>توزيع العملاء حسب المنطقة الجغرافية</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>المنطقة</th><th>عدد العملاء</th><th>النسبة</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th></tr>';
        
        -- استعلام عن توزيع العملاء حسب المنطقة الجغرافية
        FOR rec IN (
            SELECT 
                c.CITY,
                COUNT(DISTINCT c.CUSTOMER_ID) AS CUSTOMER_COUNT,
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / NULLIF(v_total_customers, 0) * 100, 2) AS PERCENTAGE,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_FINANCING,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(COUNT(f.FINANCING_ID), 0), 2) AS AVG_FINANCING
            FROM 
                CUSTOMERS c
                LEFT JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
            GROUP BY 
                c.CITY
            ORDER BY 
                COUNT(DISTINCT c.CUSTOMER_ID) DESC
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.CITY || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- توزيع العملاء حسب الدخل الشهري
        v_report_data := v_report_data || '<h3>توزيع العملاء حسب الدخل الشهري</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>فئة الدخل</th><th>عدد العملاء</th><th>النسبة</th><th>إجمالي قيمة التمويل</th><th>متوسط قيمة التمويل</th></tr>';
        
        -- استعلام عن توزيع العملاء حسب الدخل الشهري
        FOR rec IN (
            SELECT 
                CASE 
                    WHEN c.MONTHLY_INCOME < 5000 THEN 'أقل من 5,000'
                    WHEN c.MONTHLY_INCOME BETWEEN 5000 AND 9999 THEN '5,000 - 9,999'
                    WHEN c.MONTHLY_INCOME BETWEEN 10000 AND 14999 THEN '10,000 - 14,999'
                    WHEN c.MONTHLY_INCOME BETWEEN 15000 AND 19999 THEN '15,000 - 19,999'
                    WHEN c.MONTHLY_INCOME BETWEEN 20000 AND 29999 THEN '20,000 - 29,999'
                    WHEN c.MONTHLY_INCOME BETWEEN 30000 AND 49999 THEN '30,000 - 49,999'
                    ELSE '50,000 فأكثر'
                END AS INCOME_RANGE,
                COUNT(DISTINCT c.CUSTOMER_ID) AS CUSTOMER_COUNT,
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / NULLIF(v_total_customers, 0) * 100, 2) AS PERCENTAGE,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_FINANCING,
                ROUND(SUM(f.FINANCING_AMOUNT) / NULLIF(COUNT(f.FINANCING_ID), 0), 2) AS AVG_FINANCING
            FROM 
                CUSTOMERS c
                LEFT JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
            GROUP BY 
                CASE 
                    WHEN c.MONTHLY_INCOME < 5000 THEN 'أقل من 5,000'
                    WHEN c.MONTHLY_INCOME BETWEEN 5000 AND 9999 THEN '5,000 - 9,999'
                    WHEN c.MONTHLY_INCOME BETWEEN 10000 AND 14999 THEN '10,000 - 14,999'
                    WHEN c.MONTHLY_INCOME BETWEEN 15000 AND 19999 THEN '15,000 - 19,999'
                    WHEN c.MONTHLY_INCOME BETWEEN 20000 AND 29999 THEN '20,000 - 29,999'
                    WHEN c.MONTHLY_INCOME BETWEEN 30000 AND 49999 THEN '30,000 - 49,999'
                    ELSE '50,000 فأكثر'
                END
            ORDER BY 
                MIN(c.MONTHLY_INCOME)
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.INCOME_RANGE || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.AVG_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- تحليل سلوك العملاء
        v_report_data := v_report_data || '<h3>تحليل سلوك العملاء</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>نوع السلوك</th><th>عدد العملاء</th><th>النسبة</th></tr>';
        
        -- استعلام عن سلوك العملاء
        FOR rec IN (
            -- العملاء المنتظمين في السداد
            SELECT 
                'عملاء منتظمين في السداد' AS BEHAVIOR_TYPE,
                COUNT(DISTINCT c.CUSTOMER_ID) AS CUSTOMER_COUNT,
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / NULLIF(v_active_customers, 0) * 100, 2) AS PERCENTAGE
            FROM 
                CUSTOMERS c
                JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
            WHERE 
                f.CONTRACT_STATUS = 'ACTIVE'
                AND NOT EXISTS (
                    SELECT 1 FROM INSTALLMENT_SCHEDULE i 
                    WHERE i.REQUEST_ID = f.REQUEST_ID 
                    AND i.INSTALLMENT_STATUS = 'OVERDUE'
                    AND i.DUE_DATE <= p_end_date
                )
            
            UNION ALL
            
            -- العملاء المتأخرين في السداد
            SELECT 
                'عملاء متأخرين في السداد' AS BEHAVIOR_TYPE,
                COUNT(DISTINCT c.CUSTOMER_ID) AS CUSTOMER_COUNT,
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / NULLIF(v_active_customers, 0) * 100, 2) AS PERCENTAGE
            FROM 
                CUSTOMERS c
                JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
                JOIN INSTALLMENT_SCHEDULE i ON f.REQUEST_ID = i.REQUEST_ID
            WHERE 
                f.CONTRACT_STATUS = 'ACTIVE'
                AND i.INSTALLMENT_STATUS = 'OVERDUE'
                AND i.DUE_DATE <= p_end_date
            
            UNION ALL
            
            -- العملاء الذين سددوا قبل الموعد
            SELECT 
                'عملاء سددوا قبل الموعد' AS BEHAVIOR_TYPE,
                COUNT(DISTINCT c.CUSTOMER_ID) AS CUSTOMER_COUNT,
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / NULLIF(v_active_customers, 0) * 100, 2) AS PERCENTAGE
            FROM 
                CUSTOMERS c
                JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
                JOIN PAYMENTS p ON f.FINANCING_ID = p.FINANCING_ID
                JOIN INSTALLMENT_SCHEDULE i ON p.INSTALLMENT_ID = i.INSTALLMENT_ID
            WHERE 
                p.PAYMENT_DATE < i.DUE_DATE
                AND p.PAYMENT_DATE BETWEEN p_start_date AND p_end_date
            
            UNION ALL
            
            -- العملاء الذين لديهم أكثر من عقد تمويل
            SELECT 
                'عملاء لديهم أكثر من عقد تمويل' AS BEHAVIOR_TYPE,
                COUNT(DISTINCT c.CUSTOMER_ID) AS CUSTOMER_COUNT,
                ROUND(COUNT(DISTINCT c.CUSTOMER_ID) / NULLIF(v_active_customers, 0) * 100, 2) AS PERCENTAGE
            FROM 
                CUSTOMERS c
                JOIN (
                    SELECT 
                        CUSTOMER_ID, COUNT(*) AS CONTRACT_COUNT
                    FROM 
                        FINANCING_CONTRACTS
                    WHERE 
                        CONTRACT_STATUS = 'ACTIVE'
                    GROUP BY 
                        CUSTOMER_ID
                    HAVING 
                        COUNT(*) > 1
                ) multi ON c.CUSTOMER_ID = multi.CUSTOMER_ID
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.BEHAVIOR_TYPE || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- أكثر 10 عملاء من حيث قيمة التمويل
        v_report_data := v_report_data || '<h3>أكثر 10 عملاء من حيث قيمة التمويل</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>اسم العميل</th><th>عدد العقود</th><th>إجمالي قيمة التمويل</th><th>المبلغ المتبقي</th><th>نسبة السداد</th></tr>';
        
        -- استعلام عن أكثر 10 عملاء من حيث قيمة التمويل
        FOR rec IN (
            SELECT 
                c.FULL_NAME,
                COUNT(f.FINANCING_ID) AS CONTRACT_COUNT,
                SUM(f.FINANCING_AMOUNT) AS TOTAL_FINANCING,
                SUM(f.REMAINING_AMOUNT) AS REMAINING_AMOUNT,
                ROUND((1 - (SUM(f.REMAINING_AMOUNT) / NULLIF(SUM(f.FINANCING_AMOUNT), 0))) * 100, 2) AS REPAYMENT_PERCENTAGE
            FROM 
                CUSTOMERS c
                JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
            GROUP BY 
                c.FULL_NAME, c.CUSTOMER_ID
            ORDER BY 
                SUM(f.FINANCING_AMOUNT) DESC
            FETCH FIRST 10 ROWS ONLY
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.FULL_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CONTRACT_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.TOTAL_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.REMAINING_AMOUNT, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '<td>' || rec.REPAYMENT_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- نمو العملاء خلال الفترة
        v_report_data := v_report_data || '<h3>نمو العملاء خلال الفترة</h3>';
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr><th>الشهر</th><th>العملاء الجدد</th><th>النسبة التراكمية</th><th>إجمالي قيمة التمويل للعملاء الجدد</th></tr>';
        
        -- استعلام عن نمو العملاء خلال الفترة
        FOR rec IN (
            WITH MONTHS AS (
                SELECT 
                    ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1) AS MONTH_START,
                    LAST_DAY(ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1)) AS MONTH_END,
                    TO_CHAR(ADD_MONTHS(TRUNC(p_start_date, 'MM'), LEVEL-1), 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ARABIC') AS MONTH_NAME
                FROM DUAL
                CONNECT BY LEVEL <= MONTHS_BETWEEN(TRUNC(p_end_date, 'MM'), TRUNC(p_start_date, 'MM')) + 1
            ),
            NEW_CUSTOMERS AS (
                SELECT 
                    TRUNC(c.CREATION_DATE, 'MM') AS MONTH_START,
                    COUNT(*) AS NEW_CUSTOMER_COUNT,
                    SUM(f.FINANCING_AMOUNT) AS NEW_CUSTOMER_FINANCING
                FROM 
                    CUSTOMERS c
                    LEFT JOIN FINANCING_CONTRACTS f ON c.CUSTOMER_ID = f.CUSTOMER_ID
                WHERE 
                    c.CREATION_DATE BETWEEN p_start_date AND p_end_date
                GROUP BY 
                    TRUNC(c.CREATION_DATE, 'MM')
            ),
            CUMULATIVE AS (
                SELECT 
                    m.MONTH_START,
                    m.MONTH_NAME,
                    NVL(nc.NEW_CUSTOMER_COUNT, 0) AS NEW_CUSTOMER_COUNT,
                    NVL(nc.NEW_CUSTOMER_FINANCING, 0) AS NEW_CUSTOMER_FINANCING,
                    SUM(NVL(nc.NEW_CUSTOMER_COUNT, 0)) OVER (ORDER BY m.MONTH_START) AS CUMULATIVE_COUNT
                FROM 
                    MONTHS m
                    LEFT JOIN NEW_CUSTOMERS nc ON m.MONTH_START = nc.MONTH_START
            )
            SELECT 
                MONTH_NAME,
                NEW_CUSTOMER_COUNT,
                ROUND(CUMULATIVE_COUNT / NULLIF(SUM(NEW_CUSTOMER_COUNT) OVER (), 0) * 100, 2) AS CUMULATIVE_PERCENTAGE,
                NEW_CUSTOMER_FINANCING
            FROM 
                CUMULATIVE
            ORDER BY 
                MONTH_START
        ) LOOP
            v_report_data := v_report_data || '<tr>';
            v_report_data := v_report_data || '<td>' || rec.MONTH_NAME || '</td>';
            v_report_data := v_report_data || '<td>' || rec.NEW_CUSTOMER_COUNT || '</td>';
            v_report_data := v_report_data || '<td>' || rec.CUMULATIVE_PERCENTAGE || '%</td>';
            v_report_data := v_report_data || '<td>' || TO_CHAR(rec.NEW_CUSTOMER_FINANCING, '999,999,999.99') || '</td>';
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_NAME, REPORT_DESCRIPTION, 
            REPORT_QUERY, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'CUSTOMER_ANALYSIS', 'تقرير تحليل العملاء', 
            'تقرير تحليل العملاء للفترة من ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى ' || TO_CHAR(p_end_date, 'DD/MM/YYYY'),
            v_report_data, 'HTML', 1, SYSDATE,
            p_start_date, p_end_date
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END GENERATE_CUSTOMER_ANALYSIS_REPORT;
    
    -- استرجاع قائمة التقارير
    FUNCTION GET_REPORT_LIST(
        p_start_date IN DATE DEFAULT NULL,
        p_end_date IN DATE DEFAULT NULL,
        p_report_type IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                REPORT_ID, REPORT_TYPE, REPORT_NAME, REPORT_DESCRIPTION,
                REPORT_FORMAT, CREATED_BY, CREATION_DATE, START_DATE, END_DATE
            FROM 
                REPORTS
            WHERE 
                (p_start_date IS NULL OR CREATION_DATE >= p_start_date)
                AND (p_end_date IS NULL OR CREATION_DATE <= p_end_date)
                AND (p_report_type IS NULL OR REPORT_TYPE = p_report_type)
            ORDER BY 
                CREATION_DATE DESC;
        
        RETURN v_cursor;
    END GET_REPORT_LIST;
    
    -- حذف تقرير
    PROCEDURE DELETE_REPORT(p_report_id IN NUMBER) IS
    BEGIN
        DELETE FROM REPORTS WHERE REPORT_ID = p_report_id;
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END DELETE_REPORT;
    
    -- تصدير تقرير إلى ملف
    PROCEDURE EXPORT_REPORT_TO_FILE(
        p_report_id IN NUMBER,
        p_directory_name IN VARCHAR2,
        p_file_name IN VARCHAR2
    ) IS
        v_report_content CLOB;
        v_file UTL_FILE.FILE_TYPE;
        v_buffer VARCHAR2(32767);
        v_amount NUMBER := 32767;
        v_pos NUMBER := 1;
        v_clob_len NUMBER;
    BEGIN
        -- استرجاع محتوى التقرير
        SELECT REPORT_QUERY INTO v_report_content
        FROM REPORTS
        WHERE REPORT_ID = p_report_id;
        
        -- فتح الملف للكتابة
        v_file := UTL_FILE.FOPEN(p_directory_name, p_file_name, 'W', 32767);
        
        -- كتابة محتوى التقرير إلى الملف
        v_clob_len := DBMS_LOB.GETLENGTH(v_report_content);
        
        WHILE v_pos <= v_clob_len LOOP
            v_buffer := DBMS_LOB.SUBSTR(v_report_content, v_amount, v_pos);
            UTL_FILE.PUT(v_file, v_buffer);
            v_pos := v_pos + v_amount;
        END LOOP;
        
        -- إغلاق الملف
        UTL_FILE.FCLOSE(v_file);
    EXCEPTION
        WHEN OTHERS THEN
            IF UTL_FILE.IS_OPEN(v_file) THEN
                UTL_FILE.FCLOSE(v_file);
            END IF;
            RAISE;
    END EXPORT_REPORT_TO_FILE;
    
    -- إنشاء تقرير مخصص
    PROCEDURE GENERATE_CUSTOM_REPORT(
        p_report_title IN VARCHAR2,
        p_report_description IN VARCHAR2,
        p_sql_query IN CLOB,
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_report_id OUT NUMBER
    ) IS
        v_report_data CLOB;
        v_cursor SYS_REFCURSOR;
        v_column_count NUMBER;
        v_column_desc DBMS_SQL.DESC_TAB;
        v_cursor_id NUMBER;
        v_dummy NUMBER;
        v_column_value VARCHAR2(4000);
    BEGIN
        -- إنشاء معرف التقرير
        SELECT SEQ_REPORT_ID.NEXTVAL INTO p_report_id FROM DUAL;
        
        -- بناء محتوى التقرير
        v_report_data := '<html><head><title>' || p_report_title || '</title>';
        v_report_data := v_report_data || '<style>
            body { font-family: Arial, sans-serif; direction: rtl; }
            table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
            th { background-color: #f2f2f2; }
            .header { background-color: #4CAF50; color: white; padding: 10px; }
        </style></head><body>';
        
        v_report_data := v_report_data || '<div class="header"><h2>' || p_report_title || '</h2>';
        v_report_data := v_report_data || '<p>' || p_report_description || '</p>';
        v_report_data := v_report_data || '<p>للفترة من: ' || TO_CHAR(p_start_date, 'DD/MM/YYYY') || ' إلى: ' || TO_CHAR(p_end_date, 'DD/MM/YYYY') || '</p></div>';
        
        -- تنفيذ الاستعلام المخصص
        OPEN v_cursor FOR p_sql_query;
        
        -- تحويل الاستعلام إلى جدول HTML
        v_cursor_id := DBMS_SQL.TO_CURSOR_NUMBER(v_cursor);
        DBMS_SQL.DESCRIBE_COLUMNS(v_cursor_id, v_column_count, v_column_desc);
        
        -- إنشاء رأس الجدول
        v_report_data := v_report_data || '<table>';
        v_report_data := v_report_data || '<tr>';
        
        FOR i IN 1..v_column_count LOOP
            v_report_data := v_report_data || '<th>' || v_column_desc(i).col_name || '</th>';
        END LOOP;
        
        v_report_data := v_report_data || '</tr>';
        
        -- إضافة بيانات الجدول
        LOOP
            v_dummy := DBMS_SQL.FETCH_ROWS(v_cursor_id);
            EXIT WHEN v_dummy = 0;
            
            v_report_data := v_report_data || '<tr>';
            
            FOR i IN 1..v_column_count LOOP
                DBMS_SQL.COLUMN_VALUE(v_cursor_id, i, v_column_value);
                v_report_data := v_report_data || '<td>' || NVL(v_column_value, '') || '</td>';
            END LOOP;
            
            v_report_data := v_report_data || '</tr>';
        END LOOP;
        
        v_report_data := v_report_data || '</table>';
        
        -- إغلاق التقرير
        v_report_data := v_report_data || '</body></html>';
        
        -- حفظ التقرير في قاعدة البيانات
        INSERT INTO REPORTS (
            REPORT_ID, REPORT_TYPE, REPORT_NAME, REPORT_DESCRIPTION, 
            REPORT_QUERY, REPORT_FORMAT, CREATED_BY, CREATION_DATE,
            START_DATE, END_DATE
        ) VALUES (
            p_report_id, 'CUSTOM', p_report_title, p_report_description,
            v_report_data, 'HTML', 1, SYSDATE,
            p_start_date, p_end_date
        );
        
        COMMIT;
        
        DBMS_SQL.CLOSE_CURSOR(v_cursor_id);
    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_SQL.IS_OPEN(v_cursor_id) THEN
                DBMS_SQL.CLOSE_CURSOR(v_cursor_id);
            END IF;
            ROLLBACK;
            RAISE;
    END GENERATE_CUSTOM_REPORT;
 -------
   -- تقرير ملخص الطلبات
    FUNCTION REPORT_REQUESTS_SUMMARY(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_product_id IN NUMBER DEFAULT NULL,
        p_request_status IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                COUNT(*) AS TOTAL_REQUESTS,
                SUM(CASE WHEN REQUEST_STATUS = 'NEW' THEN 1 ELSE 0 END) AS NEW_REQUESTS,
                SUM(CASE WHEN REQUEST_STATUS = 'IN_PROGRESS' THEN 1 ELSE 0 END) AS IN_PROGRESS_REQUESTS,
                SUM(CASE WHEN REQUEST_STATUS = 'APPROVED' THEN 1 ELSE 0 END) AS APPROVED_REQUESTS,
                SUM(CASE WHEN REQUEST_STATUS = 'REJECTED' THEN 1 ELSE 0 END) AS REJECTED_REQUESTS,
                SUM(CASE WHEN REQUEST_STATUS = 'CANCELLED' THEN 1 ELSE 0 END) AS CANCELLED_REQUESTS,
                SUM(CASE WHEN REQUEST_STATUS = 'COMPLETED' THEN 1 ELSE 0 END) AS COMPLETED_REQUESTS,
                SUM(REQUESTED_AMOUNT) AS TOTAL_FINANCING_AMOUNT,
                SUM(CASE WHEN REQUEST_STATUS = 'APPROVED' THEN APPROVED_AMOUNT ELSE 0 END) AS APPROVED_FINANCING_AMOUNT,
                AVG(CASE WHEN REQUEST_STATUS IN ('APPROVED', 'COMPLETED') THEN 
                    (APPROVAL_DATE - REQUEST_DATE) ELSE NULL END) AS AVG_APPROVAL_DAYS,
                p.PRODUCT_NAME,
                p.PRODUCT_TYPE
            FROM FINANCING_REQUESTS r
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            WHERE r.REQUEST_DATE BETWEEN p_start_date AND p_end_date
            AND (p_product_id IS NULL OR r.PRODUCT_ID = p_product_id)
            AND (p_request_status IS NULL OR r.REQUEST_STATUS = p_request_status)
            GROUP BY p.PRODUCT_NAME, p.PRODUCT_TYPE
            ORDER BY COUNT(*) DESC;
        
        RETURN v_cursor;
    END REPORT_REQUESTS_SUMMARY;
  ---
  -- تقرير الطلبات حسب المراحل
    FUNCTION REPORT_REQUESTS_BY_STAGE(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                r.CURRENT_STAGE_ID,
                COUNT(*) AS TOTAL_REQUESTS,
                AVG(SYSDATE - r.STAGE_START_DATE) AS AVG_DAYS_IN_STAGE,
                MAX(SYSDATE - r.STAGE_START_DATE) AS MAX_DAYS_IN_STAGE,
                COUNT(CASE WHEN (SYSDATE - r.STAGE_START_DATE) > 
                    (SELECT MAX_DAYS_IN_STAGE FROM REQUEST_STAGES WHERE STAGE_ID = r.CURRENT_STAGE_ID)
                    THEN 1 ELSE NULL END) AS OVERDUE_REQUESTS,
                s.MAX_DAYS_IN_STAGE AS STAGE_SLA
            FROM FINANCING_REQUESTS r
            JOIN REQUEST_STAGES s ON r.CURRENT_STAGE_ID = s.STAGE_ID
            WHERE r.REQUEST_DATE BETWEEN p_start_date AND p_end_date
            AND r.REQUEST_STATUS IN ('NEW', 'IN_PROGRESS')
            GROUP BY r.CURRENT_STAGE_ID, s.MAX_DAYS_IN_STAGE
            ORDER BY COUNT(*) DESC;
        
        RETURN v_cursor;
    END REPORT_REQUESTS_BY_STAGE;
 ---
 
    -- تقرير أداء الموظفين
    FUNCTION REPORT_EMPLOYEE_PERFORMANCE(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_department IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                u.USER_ID,
                u.FULL_NAME AS EMPLOYEE_NAME,
                u.DEPARTMENT,
                u.POSITION,
                COUNT(r.REQUEST_ID) AS TOTAL_ASSIGNED_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS = 'APPROVED' THEN 1 ELSE 0 END) AS APPROVED_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS = 'REJECTED' THEN 1 ELSE 0 END) AS REJECTED_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS IN ('NEW', 'IN_PROGRESS') THEN 1 ELSE 0 END) AS PENDING_REQUESTS,
                AVG(CASE WHEN r.REQUEST_STATUS IN ('APPROVED', 'REJECTED', 'COMPLETED') 
                    THEN (r.UPDATED_DATE - r.ASSIGNED_DATE) ELSE NULL END) AS AVG_PROCESSING_DAYS,
                COUNT(CASE WHEN r.REQUEST_STATUS IN ('NEW', 'IN_PROGRESS') 
                    AND (SYSDATE - r.STAGE_START_DATE) > 
                    (SELECT MAX_DAYS_IN_STAGE FROM REQUEST_STAGES WHERE STAGE_ID = r.CURRENT_STAGE_ID)
                    THEN 1 ELSE NULL END) AS OVERDUE_REQUESTS
            FROM USERS u
            LEFT JOIN FINANCING_REQUESTS r ON u.USER_ID = r.ASSIGNED_TO
                AND r.ASSIGNED_DATE BETWEEN p_start_date AND p_end_date
            WHERE u.USER_ROLE IN ('CREDIT_ANALYST', 'RELATIONSHIP_MANAGER', 'BRANCH_MANAGER', 'LOAN_OFFICER')
            AND (p_department IS NULL OR u.DEPARTMENT = p_department)
            GROUP BY u.USER_ID, u.FULL_NAME, u.DEPARTMENT, u.POSITION
            ORDER BY COUNT(r.REQUEST_ID) DESC;
        
        RETURN v_cursor;
    END REPORT_EMPLOYEE_PERFORMANCE;
 ---
     -- تقرير الأقساط المستحقة
    FUNCTION REPORT_DUE_INSTALLMENTS(
        p_start_date IN DATE,
        p_end_date IN DATE,
        p_product_id IN NUMBER DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                i.DUE_DATE,
                COUNT(*) AS TOTAL_INSTALLMENTS,
                SUM(i.PRINCIPAL_AMOUNT) AS TOTAL_PRINCIPAL,
                SUM(i.PROFIT_AMOUNT) AS TOTAL_PROFIT,
                SUM(i.TOTAL_AMOUNT) AS TOTAL_AMOUNT,
                p.PRODUCT_NAME,
                COUNT(CASE WHEN i.INSTALLMENT_STATUS = 'PAID' THEN 1 ELSE NULL END) AS PAID_INSTALLMENTS,
                COUNT(CASE WHEN i.INSTALLMENT_STATUS = 'PARTIAL' THEN 1 ELSE NULL END) AS PARTIAL_INSTALLMENTS,
                COUNT(CASE WHEN i.INSTALLMENT_STATUS = 'SCHEDULED' THEN 1 ELSE NULL END) AS SCHEDULED_INSTALLMENTS,
                COUNT(CASE WHEN i.INSTALLMENT_STATUS = 'OVERDUE' THEN 1 ELSE NULL END) AS OVERDUE_INSTALLMENTS,
                SUM(CASE WHEN i.INSTALLMENT_STATUS = 'PAID' THEN i.TOTAL_AMOUNT ELSE 0 END) AS PAID_AMOUNT,
                SUM(CASE WHEN i.INSTALLMENT_STATUS = 'PARTIAL' THEN i.PAID_AMOUNT ELSE 0 END) AS PARTIAL_PAID_AMOUNT,
                SUM(CASE WHEN i.INSTALLMENT_STATUS IN ('SCHEDULED', 'OVERDUE') THEN i.TOTAL_AMOUNT 
                    WHEN i.INSTALLMENT_STATUS = 'PARTIAL' THEN (i.TOTAL_AMOUNT - i.PAID_AMOUNT)
                    ELSE 0 END) AS REMAINING_AMOUNT
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            WHERE i.DUE_DATE BETWEEN p_start_date AND p_end_date
            AND (p_product_id IS NULL OR r.PRODUCT_ID = p_product_id)
            GROUP BY i.DUE_DATE, p.PRODUCT_NAME
            ORDER BY i.DUE_DATE;
        
        RETURN v_cursor;
    END REPORT_DUE_INSTALLMENTS;
 ---
 -- تقرير المستندات المنتهية
    FUNCTION REPORT_EXPIRED_DOCUMENTS(
        p_days_before_expiry IN NUMBER DEFAULT 30
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                cd.DOCUMENT_ID,
                cd.DOCUMENT_TYPE,
                cd.DOCUMENT_NUMBER,
                cd.ISSUE_DATE,
                cd.EXPIRY_DATE,
                TRUNC(cd.EXPIRY_DATE - SYSDATE) AS DAYS_TO_EXPIRY,
                c.CUSTOMER_ID,
                c.FULL_NAME AS CUSTOMER_NAME,
                c.MOBILE_NUMBER,
                c.EMAIL,
                c.CUSTOMER_TYPE,
                u.FULL_NAME AS RELATIONSHIP_MANAGER
            FROM CUSTOMER_DOCUMENTS cd
            JOIN CUSTOMERS c ON cd.CUSTOMER_ID = c.CUSTOMER_ID
            LEFT JOIN USERS u ON c.RELATIONSHIP_MANAGER = u.USER_ID
            WHERE cd.EXPIRY_DATE BETWEEN SYSDATE AND (SYSDATE + p_days_before_expiry)
            AND cd.DOCUMENT_STATUS = 'ACTIVE'
            ORDER BY cd.EXPIRY_DATE;
        
        RETURN v_cursor;
    END REPORT_EXPIRED_DOCUMENTS;
 ---
 -- تقرير العملاء النشطين
    FUNCTION REPORT_ACTIVE_CUSTOMERS(
        p_segment IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                c.CUSTOMER_ID,
                c.FULL_NAME,
                c.CUSTOMER_TYPE,
                c.CREATION_DATE,
                COUNT(r.REQUEST_ID) AS TOTAL_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS = 'APPROVED' THEN 1 ELSE 0 END) AS APPROVED_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS = 'COMPLETED' THEN 1 ELSE 0 END) AS COMPLETED_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS = 'REJECTED' THEN 1 ELSE 0 END) AS REJECTED_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS IN ('NEW', 'IN_PROGRESS') THEN 1 ELSE 0 END) AS PENDING_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS IN ('APPROVED', 'COMPLETED') THEN r.REQUESTED_AMOUNT ELSE 0 END) AS TOTAL_FINANCING_AMOUNT,
                MAX(r.REQUEST_DATE) AS LAST_REQUEST_DATE,
                u.FULL_NAME AS RELATIONSHIP_MANAGER
            FROM CUSTOMERS c
            LEFT JOIN FINANCING_REQUESTS r ON c.CUSTOMER_ID = r.CUSTOMER_ID
            LEFT JOIN USERS u ON c.RELATIONSHIP_MANAGER = u.USER_ID
            WHERE c.CUSTOMER_STATUS = 'ACTIVE'
            AND (p_segment IS NULL OR c.CUSTOMER_TYPE = p_segment)
            GROUP BY c.CUSTOMER_ID, c.FULL_NAME, c.CUSTOMER_TYPE, c.CREATION_DATE, u.FULL_NAME
            ORDER BY COUNT(r.REQUEST_ID) DESC;
        
        RETURN v_cursor;
    END REPORT_ACTIVE_CUSTOMERS;
 ---
 
    -- تقرير المنتجات الأكثر طلباً
    FUNCTION REPORT_POPULAR_PRODUCTS(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                p.PRODUCT_ID,
                p.PRODUCT_NAME,
                p.PRODUCT_TYPE,
                COUNT(r.REQUEST_ID) AS TOTAL_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS = 'APPROVED' THEN 1 ELSE 0 END) AS APPROVED_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS = 'REJECTED' THEN 1 ELSE 0 END) AS REJECTED_REQUESTS,
                SUM(CASE WHEN r.REQUEST_STATUS = 'COMPLETED' THEN 1 ELSE 0 END) AS COMPLETED_REQUESTS,
                SUM(r.REQUESTED_AMOUNT) AS TOTAL_REQUESTED_AMOUNT,
                SUM(CASE WHEN r.REQUEST_STATUS IN ('APPROVED', 'COMPLETED') THEN r.REQUESTED_AMOUNT ELSE 0 END) AS TOTAL_APPROVED_AMOUNT,
                ROUND(SUM(CASE WHEN r.REQUEST_STATUS IN ('APPROVED', 'COMPLETED') THEN 1 ELSE 0 END) / 
                    NULLIF(COUNT(r.REQUEST_ID), 0) * 100, 2) AS APPROVAL_RATE,
                COUNT(DISTINCT r.CUSTOMER_ID) AS UNIQUE_CUSTOMERS
            FROM ISLAMIC_PRODUCTS p
            LEFT JOIN FINANCING_REQUESTS r ON p.PRODUCT_ID = r.PRODUCT_ID
                AND r.REQUEST_DATE BETWEEN p_start_date AND p_end_date
            GROUP BY p.PRODUCT_ID, p.PRODUCT_NAME, p.PRODUCT_TYPE
            ORDER BY COUNT(r.REQUEST_ID) DESC;
        
        RETURN v_cursor;
    END REPORT_POPULAR_PRODUCTS;
 ---
 
    -- تقرير الطلبات المتأخرة
    FUNCTION REPORT_OVERDUE_REQUESTS(
        p_days_overdue IN NUMBER DEFAULT 0
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                r.REQUEST_ID,
                r.REQUEST_NUMBER,
                r.CURRENT_STAGE_ID,
                r.STAGE_START_DATE,
                TRUNC(SYSDATE - r.STAGE_START_DATE) AS DAYS_IN_STAGE,
                s.MAX_DAYS_IN_STAGE AS STAGE_SLA,
                TRUNC(SYSDATE - r.STAGE_START_DATE) - s.MAX_DAYS_IN_STAGE AS DAYS_OVERDUE,
                r.REQUEST_DATE,
                r.REQUESTED_AMOUNT,
                r.PRODUCT_ID,
                p.PRODUCT_NAME,
                r.CUSTOMER_ID,
                c.FULL_NAME AS CUSTOMER_NAME,
                c.MOBILE_NUMBER,
                c.EMAIL,
                r.ASSIGNED_TO,
                u.FULL_NAME AS ASSIGNED_TO_NAME,
                u.DEPARTMENT AS ASSIGNED_TO_DEPARTMENT
            FROM FINANCING_REQUESTS r
            JOIN REQUEST_STAGES s ON r.CURRENT_STAGE_ID = s.STAGE_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            LEFT JOIN USERS u ON r.ASSIGNED_TO = u.USER_ID
            WHERE r.REQUEST_STATUS IN ('NEW', 'IN_PROGRESS')
            AND (SYSDATE - r.STAGE_START_DATE) > s.MAX_DAYS_IN_STAGE
            AND (SYSDATE - r.STAGE_START_DATE) - s.MAX_DAYS_IN_STAGE >= p_days_overdue
            ORDER BY (SYSDATE - r.STAGE_START_DATE) - s.MAX_DAYS_IN_STAGE DESC;
        
        RETURN v_cursor;
    END REPORT_OVERDUE_REQUESTS;
 ---
 
    -- تقرير الأقساط المتأخرة
    FUNCTION REPORT_OVERDUE_INSTALLMENTS(
        p_days_overdue IN NUMBER DEFAULT 0
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                i.INSTALLMENT_ID,
                i.REQUEST_ID,
                r.REQUEST_NUMBER,
                i.INSTALLMENT_SEQ,
                i.DUE_DATE,
                TRUNC(SYSDATE - i.DUE_DATE) AS DAYS_OVERDUE,
                i.PRINCIPAL_AMOUNT,
                i.PROFIT_AMOUNT,
                i.TOTAL_AMOUNT,
                i.PAID_AMOUNT,
                i.TOTAL_AMOUNT - NVL(i.PAID_AMOUNT, 0) AS REMAINING_AMOUNT,
                i.INSTALLMENT_STATUS,
                r.CUSTOMER_ID,
                c.FULL_NAME AS CUSTOMER_NAME,
                c.MOBILE_NUMBER,
                c.EMAIL,
                c.CUSTOMER_TYPE,
                p.PRODUCT_ID,
                p.PRODUCT_NAME,
                p.PRODUCT_TYPE,
                u.FULL_NAME AS RELATIONSHIP_MANAGER
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            LEFT JOIN USERS u ON c.RELATIONSHIP_MANAGER = u.USER_ID
            WHERE i.INSTALLMENT_STATUS IN ('OVERDUE', 'PARTIAL')
            AND i.DUE_DATE < SYSDATE
            AND TRUNC(SYSDATE - i.DUE_DATE) >= p_days_overdue
            ORDER BY TRUNC(SYSDATE - i.DUE_DATE) DESC;
        
        RETURN v_cursor;
    END REPORT_OVERDUE_INSTALLMENTS;
 ---
 -- تقرير تحليل الرفض
    FUNCTION REPORT_REJECTION_ANALYSIS(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                R.REJECT_REASONS,
                COUNT(*) AS TOTAL_REJECTIONS,
                ROUND(COUNT(*) / (SELECT COUNT(*) FROM FINANCING_REQUESTS 
                                  WHERE REQUEST_STATUS = 'REJECTED'
                                  AND REQUEST_DATE BETWEEN p_start_date AND p_end_date) * 100, 2) AS PERCENTAGE,
                p.PRODUCT_NAME,
                p.PRODUCT_TYPE,
                AVG(r.REQUESTED_AMOUNT) AS AVG_FINANCING_AMOUNT,
                COUNT(DISTINCT r.CUSTOMER_ID) AS UNIQUE_CUSTOMERS,
                COUNT(DISTINCT CASE WHEN c.CUSTOMER_TYPE = 'INDIVIDUAL' THEN r.CUSTOMER_ID ELSE NULL END) AS INDIVIDUAL_CUSTOMERS,
                COUNT(DISTINCT CASE WHEN c.CUSTOMER_TYPE = 'CORPORATE' THEN r.CUSTOMER_ID ELSE NULL END) AS CORPORATE_CUSTOMERS,
                COUNT(DISTINCT CASE WHEN c.CUSTOMER_TYPE = 'SME' THEN r.CUSTOMER_ID ELSE NULL END) AS SME_CUSTOMERS
            FROM ----FINANCING_NOTES rn JOIN
             FINANCING_REQUESTS r ---ON rn.REQUEST_ID = r.REQUEST_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE r.REQUEST_STATUS = 'REJECTED'
            AND r.REQUEST_DATE BETWEEN p_start_date AND p_end_date
            ---AND rn.NOTE_TYPE = 'REJECTION_REASON'
            GROUP BY r.REJECT_REASONS, p.PRODUCT_NAME, p.PRODUCT_TYPE
            ORDER BY COUNT(*) DESC;
        
        RETURN v_cursor;
    END REPORT_REJECTION_ANALYSIS;                        
 ---
 
   -- تقرير ملخص الطلبات حسب المنتج
    FUNCTION REPORT_REQUESTS_BY_PRODUCT(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT p.PRODUCT_ID, p.PRODUCT_NAME, p.PRODUCT_TYPE,
                   COUNT(r.REQUEST_ID) AS TOTAL_REQUESTS,
                   SUM(CASE WHEN r.REQUEST_STATUS = 'APPROVED' THEN 1 ELSE 0 END) AS APPROVED_REQUESTS,
                   SUM(CASE WHEN r.REQUEST_STATUS = 'REJECTED' THEN 1 ELSE 0 END) AS REJECTED_REQUESTS,
                   SUM(CASE WHEN r.REQUEST_STATUS = 'DISBURSED' THEN 1 ELSE 0 END) AS DISBURSED_REQUESTS,
                   SUM(r.REQUESTED_AMOUNT) AS TOTAL_REQUESTED_AMOUNT,
                   SUM(r.APPROVED_AMOUNT) AS TOTAL_APPROVED_AMOUNT
            FROM ISLAMIC_PRODUCTS p
            LEFT JOIN FINANCING_REQUESTS r ON p.PRODUCT_ID = r.PRODUCT_ID
                AND r.REQUEST_DATE BETWEEN p_start_date AND p_end_date
            GROUP BY p.PRODUCT_ID, p.PRODUCT_NAME, p.PRODUCT_TYPE
            ORDER BY p.PRODUCT_TYPE, p.PRODUCT_NAME;
        RETURN v_cursor;
    END REPORT_REQUESTS_BY_PRODUCT;
    ---
    
    -- تقرير ملخص الطلبات حسب الحالة
    FUNCTION REPORT_REQUESTS_BY_STATUS(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT r.REQUEST_STATUS,
                   COUNT(r.REQUEST_ID) AS TOTAL_REQUESTS,
                   SUM(r.REQUESTED_AMOUNT) AS TOTAL_REQUESTED_AMOUNT,
                   SUM(r.APPROVED_AMOUNT) AS TOTAL_APPROVED_AMOUNT,
                   AVG(r.PROFIT_RATE) AS AVG_PROFIT_RATE
            FROM FINANCING_REQUESTS r
            WHERE r.REQUEST_DATE BETWEEN p_start_date AND p_end_date
            GROUP BY r.REQUEST_STATUS
            ORDER BY r.REQUEST_STATUS;
        RETURN v_cursor;
    END REPORT_REQUESTS_BY_STATUS;
    ---
    -- تقرير الأقساط المستحقة
    FUNCTION REPORT_DUE_INSTALLMENTS(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT i.DUE_DATE, 
                   COUNT(i.INSTALLMENT_ID) AS TOTAL_INSTALLMENTS,
                   SUM(i.PRINCIPAL_AMOUNT) AS TOTAL_PRINCIPAL,
                   SUM(i.PROFIT_AMOUNT) AS TOTAL_PROFIT,
                   SUM(i.TOTAL_AMOUNT) AS TOTAL_AMOUNT,
                   p.PRODUCT_NAME
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
            WHERE i.DUE_DATE BETWEEN p_start_date AND p_end_date
            AND i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED')
            GROUP BY i.DUE_DATE, p.PRODUCT_NAME
            ORDER BY i.DUE_DATE, p.PRODUCT_NAME;
        RETURN v_cursor;
    END REPORT_DUE_INSTALLMENTS;
 ---
 -- تقرير المخصصات
    FUNCTION REPORT_PROVISIONS RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT dc.CLASSIFICATION_NAME, dc.PROVISION_PERCENTAGE,
                   COUNT(p.PROVISION_ID) AS TOTAL_PROVISIONS,
                   SUM(p.PROVISION_AMOUNT) AS TOTAL_PROVISION_AMOUNT,
                   ip.PRODUCT_NAME
            FROM PROVISIONS p
            JOIN DEBT_CLASSIFICATIONS dc ON p.CLASSIFICATION_ID = dc.CLASSIFICATION_ID
            JOIN FINANCING_REQUESTS r ON p.REQUEST_ID = r.REQUEST_ID
            JOIN ISLAMIC_PRODUCTS ip ON r.PRODUCT_ID = ip.PRODUCT_ID
            GROUP BY dc.CLASSIFICATION_NAME, dc.PROVISION_PERCENTAGE, ip.PRODUCT_NAME
            ORDER BY dc.PROVISION_PERCENTAGE DESC, ip.PRODUCT_NAME;
        RETURN v_cursor;
    END REPORT_PROVISIONS;
    
    -- تقرير محفظة التمويل
    FUNCTION REPORT_FINANCING_PORTFOLIO RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT p.PRODUCT_NAME, p.PRODUCT_TYPE,
                   COUNT(r.REQUEST_ID) AS TOTAL_ACTIVE_REQUESTS,
                   SUM(r.APPROVED_AMOUNT) AS TOTAL_PORTFOLIO_AMOUNT,
                   AVG(r.PROFIT_RATE) AS AVG_PROFIT_RATE,
                   AVG(r.FINANCING_PERIOD) AS AVG_FINANCING_PERIOD,
                   SUM(CASE WHEN i.INSTALLMENT_STATUS = 'PAID' THEN i.PAID_AMOUNT ELSE 0 END) AS TOTAL_COLLECTED_AMOUNT,
                   SUM(CASE WHEN i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED') AND i.DUE_DATE < SYSDATE THEN i.TOTAL_AMOUNT ELSE 0 END) AS TOTAL_OVERDUE_AMOUNT
            FROM ISLAMIC_PRODUCTS p
            JOIN FINANCING_REQUESTS r ON p.PRODUCT_ID = r.PRODUCT_ID
            LEFT JOIN INSTALLMENT_SCHEDULE i ON r.REQUEST_ID = i.REQUEST_ID
            WHERE r.REQUEST_STATUS IN ('DISBURSED', 'ACTIVE')
            GROUP BY p.PRODUCT_NAME, p.PRODUCT_TYPE
            ORDER BY p.PRODUCT_TYPE, p.PRODUCT_NAME;
        RETURN v_cursor;
    END REPORT_FINANCING_PORTFOLIO;
    ---
        -- تقرير أداء المنتجات
    FUNCTION REPORT_PRODUCT_PERFORMANCE(
        p_start_date IN DATE,
        p_end_date IN DATE
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT p.PRODUCT_NAME, p.PRODUCT_TYPE,
                   COUNT(r.REQUEST_ID) AS TOTAL_REQUESTS,
                   SUM(r.APPROVED_AMOUNT) AS TOTAL_APPROVED_AMOUNT,
                   AVG(r.PROFIT_RATE) AS AVG_PROFIT_RATE,
                   SUM(CASE WHEN i.INSTALLMENT_STATUS = 'PAID' THEN i.PAID_AMOUNT ELSE 0 END) AS TOTAL_COLLECTED_AMOUNT,
                   SUM(CASE WHEN i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED') AND i.DUE_DATE < SYSDATE THEN i.TOTAL_AMOUNT ELSE 0 END) AS TOTAL_OVERDUE_AMOUNT,
                   COUNT(DISTINCT CASE WHEN i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED') AND i.DUE_DATE < SYSDATE THEN r.REQUEST_ID END) AS TOTAL_OVERDUE_REQUESTS,
                   (COUNT(DISTINCT CASE WHEN i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED') AND i.DUE_DATE < SYSDATE THEN r.REQUEST_ID END) / 
                    NULLIF(COUNT(r.REQUEST_ID), 0) * 100) AS OVERDUE_PERCENTAGE
            FROM ISLAMIC_PRODUCTS p
            JOIN FINANCING_REQUESTS r ON p.PRODUCT_ID = r.PRODUCT_ID
            LEFT JOIN INSTALLMENT_SCHEDULE i ON r.REQUEST_ID = i.REQUEST_ID
            WHERE r.REQUEST_DATE BETWEEN p_start_date AND p_end_date
            AND r.REQUEST_STATUS IN ('DISBURSED', 'ACTIVE')
            GROUP BY p.PRODUCT_NAME, p.PRODUCT_TYPE
            ORDER BY p.PRODUCT_TYPE, p.PRODUCT_NAME;
        RETURN v_cursor;
    END REPORT_PRODUCT_PERFORMANCE;
    ---
        -- تقرير تصنيف العملاء
    FUNCTION REPORT_CUSTOMER_RATINGS RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            WITH customer_rating AS (
                SELECT c.CUSTOMER_ID, c.FULL_NAME, c.NATIONAL_ID,
                       PKG_CREDIT_RATING.CALCULATE_CUSTOMER_RATING(c.CUSTOMER_ID) AS CREDIT_RATING
                FROM CUSTOMERS c
            )
            SELECT cr.CREDIT_RATING,
                   COUNT(cr.CUSTOMER_ID) AS TOTAL_CUSTOMERS,
                   COUNT(r.REQUEST_ID) AS TOTAL_REQUESTS,
                   SUM(r.APPROVED_AMOUNT) AS TOTAL_APPROVED_AMOUNT,
                   SUM(CASE WHEN i.INSTALLMENT_STATUS IN ('SCHEDULED', 'POSTPONED') AND i.DUE_DATE < SYSDATE THEN i.TOTAL_AMOUNT ELSE 0 END) AS TOTAL_OVERDUE_AMOUNT
            FROM customer_rating cr
            LEFT JOIN FINANCING_REQUESTS r ON cr.CUSTOMER_ID = r.CUSTOMER_ID
            LEFT JOIN INSTALLMENT_SCHEDULE i ON r.REQUEST_ID = i.REQUEST_ID
            GROUP BY cr.CREDIT_RATING
            ORDER BY cr.CREDIT_RATING DESC;
        RETURN v_cursor;
    END REPORT_CUSTOMER_RATINGS;
    ---   
 -----   
END PKG_REPORTS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_SCHEDULED_JOBS AS
    -- تشغيل الوظائف اليومية
    PROCEDURE RUN_DAILY_JOBS IS
    P_ERR_MSG VARCHAR2(1001);
    BEGIN
        -- تسجيل بدء تنفيذ الوظائف اليومية
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'بدء تنفيذ الوظائف اليومية', 
            'تشغيل الوظائف المجدولة اليومية: ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS'),
            1
        );
        
        -- تنفيذ الوظائف اليومية
        BEGIN
            UPDATE_INSTALLMENT_STATUSES;
        EXCEPTION
            WHEN OTHERS THEN
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ----
                INSERT INTO SYSTEM_LOGS (
                    LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
                ) VALUES (
                    'ERROR', 'خطأ في تحديث حالة الأقساط', 
                    P_ERR_MSG,
                    1
                );
        END;
        
        BEGIN
            CREATE_FOLLOW_UP_TASKS;
        EXCEPTION
            WHEN OTHERS THEN
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
                INSERT INTO SYSTEM_LOGS (
                    LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
                ) VALUES (
                    'ERROR', 'خطأ في إنشاء مهام المتابعة', 
                    P_ERR_MSG,
                    1
                );
        END;
        
        BEGIN
            SEND_SCHEDULED_NOTIFICATIONS;
        EXCEPTION
            WHEN OTHERS THEN
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
                INSERT INTO SYSTEM_LOGS (
                    LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
                ) VALUES (
                    'ERROR', 'خطأ في إرسال الإشعارات المجدولة', 
                    P_ERR_MSG,
                    1
                );
        END;
        
        -- تسجيل انتهاء تنفيذ الوظائف اليومية
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'انتهاء تنفيذ الوظائف اليومية', 
            'اكتمال تنفيذ الوظائف المجدولة اليومية: ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS'),
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'ERROR', 'خطأ عام في تنفيذ الوظائف اليومية', 
                P_ERR_MSG,
                1
            );
            
            COMMIT;
    END RUN_DAILY_JOBS;
    
    -- تشغيل الوظائف الأسبوعية
    PROCEDURE RUN_WEEKLY_JOBS IS
    P_ERR_MSG VARCHAR2(1001);
    BEGIN
        -- تسجيل بدء تنفيذ الوظائف الأسبوعية
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'بدء تنفيذ الوظائف الأسبوعية', 
            'تشغيل الوظائف المجدولة الأسبوعية: ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS'),
            1
        );
        
        -- تنفيذ الوظائف الأسبوعية
        BEGIN
            UPDATE_PERFORMANCE_METRICS;
        EXCEPTION
            WHEN OTHERS THEN
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
                INSERT INTO SYSTEM_LOGS (
                    LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
                ) VALUES (
                    'ERROR', 'خطأ في تحديث مؤشرات الأداء', 
                    P_ERR_MSG,
                    1
                );
        END;
        
        -- تسجيل انتهاء تنفيذ الوظائف الأسبوعية
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'انتهاء تنفيذ الوظائف الأسبوعية', 
            'اكتمال تنفيذ الوظائف المجدولة الأسبوعية: ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS'),
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'ERROR', 'خطأ عام في تنفيذ الوظائف الأسبوعية', 
                P_ERR_MSG,
                1
            );
            
            COMMIT;
    END RUN_WEEKLY_JOBS;
    
    -- تشغيل الوظائف الشهرية
    PROCEDURE RUN_MONTHLY_JOBS IS
    P_ERR_MSG VARCHAR2(1001);
    BEGIN
        -- تسجيل بدء تنفيذ الوظائف الشهرية
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'بدء تنفيذ الوظائف الشهرية', 
            'تشغيل الوظائف المجدولة الشهرية: ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS'),
            1
        );
        
        -- تنفيذ الوظائف الشهرية
        BEGIN
            CLEANUP_TEMPORARY_DATA;
        EXCEPTION
            WHEN OTHERS THEN
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
                INSERT INTO SYSTEM_LOGS (
                    LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
                ) VALUES (
                    'ERROR', 'خطأ في تنظيف البيانات المؤقتة', 
                   P_ERR_MSG ,
                    1
                );
        END;
        
        -- تسجيل انتهاء تنفيذ الوظائف الشهرية
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'انتهاء تنفيذ الوظائف الشهرية', 
            'اكتمال تنفيذ الوظائف المجدولة الشهرية: ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS'),
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'ERROR', 'خطأ عام في تنفيذ الوظائف الشهرية', 
                P_ERR_MSG,
                1
            );
            
            COMMIT;
    END RUN_MONTHLY_JOBS;
    
    -- تحديث حالة الأقساط
    PROCEDURE UPDATE_INSTALLMENT_STATUSES IS
        v_count_overdue NUMBER := 0;
        v_count_paid NUMBER := 0;
    BEGIN
        -- تحديث الأقساط المتأخرة
        UPDATE INSTALLMENT_SCHEDULE
        SET INSTALLMENT_STATUS = 'OVERDUE'
        WHERE INSTALLMENT_STATUS = 'SCHEDULED'
        AND DUE_DATE < TRUNC(SYSDATE)
        AND (TOTAL_AMOUNT > NVL(PAID_AMOUNT, 0));
        
        v_count_overdue := SQL%ROWCOUNT;
        
        -- تحديث الأقساط المدفوعة جزئياً
        UPDATE INSTALLMENT_SCHEDULE
        SET INSTALLMENT_STATUS = 'PARTIAL'
        WHERE INSTALLMENT_STATUS IN ('SCHEDULED', 'OVERDUE')
        AND PAID_AMOUNT > 0
        AND PAID_AMOUNT < TOTAL_AMOUNT;
        
        -- تحديث الأقساط المدفوعة بالكامل
        UPDATE INSTALLMENT_SCHEDULE
        SET INSTALLMENT_STATUS = 'PAID',
            PAYMENT_DATE = SYSDATE
        WHERE INSTALLMENT_STATUS IN ('SCHEDULED', 'OVERDUE', 'PARTIAL')
        AND PAID_AMOUNT >= TOTAL_AMOUNT;
        
        v_count_paid := SQL%ROWCOUNT;
        
        -- تسجيل نتيجة التحديث
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'تحديث حالة الأقساط', 
            'تم تحديث ' || v_count_overdue || ' قسط إلى حالة متأخر و ' || 
            v_count_paid || ' قسط إلى حالة مدفوع.',
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_INSTALLMENT_STATUSES;
    
    -- إنشاء مهام المتابعة
    PROCEDURE CREATE_FOLLOW_UP_TASKS IS
    BEGIN
        -- إنشاء مهام متابعة للأقساط المتأخرة
        PKG_TASKS.CREATE_OVERDUE_INSTALLMENT_TASKS;
        
        -- إنشاء مهام متابعة للمستندات التي قاربت على الانتهاء
        PKG_TASKS.CREATE_DOCUMENT_RENEWAL_TASKS(30); -- 30 يوم قبل الانتهاء
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_FOLLOW_UP_TASKS;
    
    -- إرسال الإشعارات المجدولة
    PROCEDURE SEND_SCHEDULED_NOTIFICATIONS IS
    BEGIN
        -- إرسال إشعارات للطلبات المتأخرة
        PKG_NOTIFICATIONS.NOTIFY_OVERDUE_REQUESTS;
        
        -- إرسال إشعارات للأقساط المستحقة قريباً
        PKG_NOTIFICATIONS.NOTIFY_DUE_INSTALLMENTS(5); -- 5 أيام قبل الاستحقاق
        
        -- إرسال إشعارات للمستندات التي قاربت على الانتهاء
        PKG_NOTIFICATIONS.NOTIFY_EXPIRING_DOCUMENTS(30); -- 30 يوم قبل الانتهاء
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END SEND_SCHEDULED_NOTIFICATIONS;
    
    -- تحديث مؤشرات الأداء
    PROCEDURE UPDATE_PERFORMANCE_METRICS IS
        v_week_start_date DATE;
        v_week_end_date DATE;
        P_SEQ_METRIC_ID NUMBER;
    BEGIN
        -- تحديد بداية ونهاية الأسبوع الحالي
        v_week_start_date := TRUNC(SYSDATE, 'IW'); -- بداية الأسبوع (الأحد)
        v_week_end_date := v_week_start_date + 6; -- نهاية الأسبوع (السبت)
        
        -- حذف مؤشرات الأداء الأسبوعية السابقة إذا وجدت
        DELETE FROM PERFORMANCE_METRICS
        WHERE METRIC_PERIOD = 'WEEKLY'
        AND PERIOD_START_DATE = v_week_start_date;
        
        P_SEQ_METRIC_ID:=SEQ_METRIC_ID.NEXTVAL;
        -- إدخال مؤشرات أداء الطلبات الجديدة
        INSERT INTO PERFORMANCE_METRICS (
            METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_PERIOD,
            PERIOD_START_DATE, PERIOD_END_DATE, CREATED_BY
        )
        SELECT 
            P_SEQ_METRIC_ID, 'NEW_REQUESTS', COUNT(*), 'WEEKLY',
            v_week_start_date, v_week_end_date, 1
        FROM FINANCING_REQUESTS
        WHERE CREATED_DATE BETWEEN v_week_start_date AND v_week_end_date;
        P_SEQ_METRIC_ID:=SEQ_METRIC_ID.NEXTVAL;
        -- إدخال مؤشرات أداء الطلبات المعتمدة
        INSERT INTO PERFORMANCE_METRICS (
            METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_PERIOD,
            PERIOD_START_DATE, PERIOD_END_DATE, CREATED_BY
        )
        SELECT 
            P_SEQ_METRIC_ID, 'APPROVED_REQUESTS', COUNT(*), 'WEEKLY',
            v_week_start_date, v_week_end_date, 1
        FROM FINANCING_REQUESTS
        WHERE REQUEST_STATUS = 'APPROVED'
        AND APPROVAL_DATE BETWEEN v_week_start_date AND v_week_end_date;
        P_SEQ_METRIC_ID:=SEQ_METRIC_ID.NEXTVAL;
        -- إدخال مؤشرات أداء الطلبات المرفوضة
        INSERT INTO PERFORMANCE_METRICS (
            METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_PERIOD,
            PERIOD_START_DATE, PERIOD_END_DATE, CREATED_BY
        )
        SELECT 
            P_SEQ_METRIC_ID, 'REJECTED_REQUESTS', COUNT(*), 'WEEKLY',
            v_week_start_date, v_week_end_date, 1
        FROM FINANCING_REQUESTS
        WHERE REQUEST_STATUS = 'REJECTED'
        AND UPDATED_DATE BETWEEN v_week_start_date AND v_week_end_date;
        P_SEQ_METRIC_ID:=SEQ_METRIC_ID.NEXTVAL;
        -- إدخال مؤشرات أداء متوسط وقت معالجة الطلبات
        INSERT INTO PERFORMANCE_METRICS (
            METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_PERIOD,
            PERIOD_START_DATE, PERIOD_END_DATE, CREATED_BY
        )
        SELECT 
            P_SEQ_METRIC_ID, 'AVG_PROCESSING_TIME', 
            NVL(AVG(APPROVAL_DATE - CREATED_DATE), 0), 'WEEKLY',
            v_week_start_date, v_week_end_date, 1
        FROM FINANCING_REQUESTS
        WHERE REQUEST_STATUS = 'APPROVED'
        AND APPROVAL_DATE BETWEEN v_week_start_date AND v_week_end_date;
        P_SEQ_METRIC_ID:=SEQ_METRIC_ID.NEXTVAL;
        -- إدخال مؤشرات أداء الأقساط المتأخرة
        INSERT INTO PERFORMANCE_METRICS (
            METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_PERIOD,
            PERIOD_START_DATE, PERIOD_END_DATE, CREATED_BY
        )
        SELECT 
            P_SEQ_METRIC_ID, 'OVERDUE_INSTALLMENTS', COUNT(*), 'WEEKLY',
            v_week_start_date, v_week_end_date, 1
        FROM INSTALLMENT_SCHEDULE
        WHERE INSTALLMENT_STATUS = 'OVERDUE';
        P_SEQ_METRIC_ID:=SEQ_METRIC_ID.NEXTVAL;
        -- إدخال مؤشرات أداء نسبة التحصيل
        INSERT INTO PERFORMANCE_METRICS (
            METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_PERIOD,
            PERIOD_START_DATE, PERIOD_END_DATE, CREATED_BY
        )
        SELECT 
            P_SEQ_METRIC_ID, 'COLLECTION_RATE', 
            CASE 
                WHEN SUM(TOTAL_AMOUNT) = 0 THEN 0
                ELSE (SUM(PAID_AMOUNT) / SUM(TOTAL_AMOUNT)) * 100
            END, 
            'WEEKLY',
            v_week_start_date, v_week_end_date, 1
        FROM INSTALLMENT_SCHEDULE
        WHERE DUE_DATE BETWEEN v_week_start_date AND v_week_end_date;
        P_SEQ_METRIC_ID:=SEQ_METRIC_ID.NEXTVAL;
        -- إدخال مؤشرات أداء العملاء الجدد
        INSERT INTO PERFORMANCE_METRICS (
            METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_PERIOD,
            PERIOD_START_DATE, PERIOD_END_DATE, CREATED_BY
        )
        SELECT 
            P_SEQ_METRIC_ID, 'NEW_CUSTOMERS', COUNT(*), 'WEEKLY',
            v_week_start_date, v_week_end_date, 1
        FROM CUSTOMERS
        WHERE CREATION_DATE BETWEEN v_week_start_date AND v_week_end_date;
        
        -- تسجيل نتيجة التحديث
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'تحديث مؤشرات الأداء', 
            'تم تحديث مؤشرات الأداء الأسبوعية للفترة من ' || 
            TO_CHAR(v_week_start_date, 'DD/MM/YYYY') || ' إلى ' || 
            TO_CHAR(v_week_end_date, 'DD/MM/YYYY'),
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_PERFORMANCE_METRICS;
    
    -- تنظيف البيانات المؤقتة
    PROCEDURE CLEANUP_TEMPORARY_DATA IS
        v_deleted_count NUMBER := 0;
        v_retention_days NUMBER := 90; -- الاحتفاظ بالبيانات لمدة 90 يوم
    BEGIN
        -- حذف سجلات الإشعارات القديمة المقروءة
        DELETE FROM NOTIFICATIONS
        WHERE IS_READ = 'Y'
        AND CREATION_DATE < (SYSDATE - v_retention_days);
        
        v_deleted_count := SQL%ROWCOUNT;
        
        -- حذف سجلات المهام المكتملة القديمة
        DELETE FROM TASKS
        WHERE TASK_STATUS = 'COMPLETED'
        AND COMPLETION_DATE < (SYSDATE - v_retention_days);
        
        v_deleted_count := v_deleted_count + SQL%ROWCOUNT;
        
        -- حذف سجلات السجل القديمة
        DELETE FROM SYSTEM_LOGS
        WHERE CREATION_DATE < (SYSDATE - v_retention_days);
        
        v_deleted_count := v_deleted_count + SQL%ROWCOUNT;
        
        -- تسجيل نتيجة التنظيف
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'تنظيف البيانات المؤقتة', 
            'تم حذف ' || v_deleted_count || ' سجل من البيانات المؤقتة القديمة.',
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CLEANUP_TEMPORARY_DATA;
END PKG_SCHEDULED_JOBS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_SYSTEM_ADMIN AS
    -- مراقبة حالة الوظائف المجدولة
    PROCEDURE MONITOR_SCHEDULED_JOBS IS
        v_job_count NUMBER := 0;
        v_failed_count NUMBER := 0;
        v_disabled_count NUMBER := 0;
        v_details CLOB;
        P_ERR_MSG VARCHAR2(1001);
    BEGIN
        -- عدد الوظائف المجدولة
        SELECT COUNT(*) INTO v_job_count
        FROM user_scheduler_jobs;
        
        -- عدد الوظائف المتوقفة
        SELECT COUNT(*) INTO v_failed_count
        FROM user_scheduler_jobs
        WHERE state = 'BROKEN';
        
        -- عدد الوظائف المعطلة
        SELECT COUNT(*) INTO v_disabled_count
        FROM user_scheduler_jobs
        WHERE enabled = 'FALSE';
        
        -- تفاصيل الوظائف المتوقفة
        v_details := 'إجمالي الوظائف المجدولة: ' || v_job_count || CHR(10) ||
                     'الوظائف المتوقفة: ' || v_failed_count || CHR(10) ||
                     'الوظائف المعطلة: ' || v_disabled_count || CHR(10) || CHR(10);
        
        -- إضافة تفاصيل الوظائف المتوقفة
        IF v_failed_count > 0 THEN
            v_details := v_details || 'تفاصيل الوظائف المتوقفة:' || CHR(10);
            
            FOR job_rec IN (
                SELECT job_name, state, last_start_date, last_run_duration, failure_count, 
                       TO_CHAR(next_run_date, 'DD/MM/YYYY HH24:MI:SS') AS next_run
                FROM user_scheduler_jobs
                WHERE state = 'BROKEN'
            ) LOOP
                v_details := v_details || 'الوظيفة: ' || job_rec.job_name || 
                             ', الحالة: ' || job_rec.state || 
                             ', آخر تشغيل: ' || TO_CHAR(job_rec.last_start_date, 'DD/MM/YYYY HH24:MI:SS') || 
                             ', مدة التشغيل: ' || job_rec.last_run_duration || 
                             ', عدد مرات الفشل: ' || job_rec.failure_count ||
                             ', التشغيل القادم: ' || job_rec.next_run || CHR(10);
            END LOOP;
        END IF;
        
        -- تسجيل نتيجة المراقبة
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'مراقبة الوظائف المجدولة', 
            v_details,
            1
        );
        
        -- إذا كان هناك وظائف متوقفة، حاول إعادة تشغيلها
        IF v_failed_count > 0 THEN
            RESTART_FAILED_JOBS;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'ERROR', 'خطأ في مراقبة الوظائف المجدولة', 
                P_ERR_MSG,
                1
            );
            
            COMMIT;
    END MONITOR_SCHEDULED_JOBS;
    
    -- إيقاف جميع الوظائف المجدولة
    PROCEDURE STOP_ALL_SCHEDULED_JOBS IS
    BEGIN
        STOP_ALL_JOBS;
    END STOP_ALL_SCHEDULED_JOBS;
    
    -- تشغيل جميع الوظائف المجدولة
    PROCEDURE START_ALL_SCHEDULED_JOBS IS
    BEGIN
        START_ALL_JOBS;
    END START_ALL_SCHEDULED_JOBS;
    
    -- إعادة تشغيل وظيفة مجدولة محددة
    PROCEDURE RESTART_SCHEDULED_JOB(p_job_name IN VARCHAR2) IS
    P_ERR_MSG VARCHAR2(1001);
    BEGIN
        -- التحقق من وجود الوظيفة المجدولة
        DECLARE
            v_count NUMBER;            
        BEGIN
            SELECT COUNT(*) INTO v_count
            FROM user_scheduler_jobs
            WHERE job_name = p_job_name;
            
            IF v_count = 0 THEN
                RAISE_APPLICATION_ERROR(-20001, 'الوظيفة المجدولة غير موجودة: ' || p_job_name);
            END IF;
        END;
        
        -- إيقاف الوظيفة المجدولة
        BEGIN
            DBMS_SCHEDULER.STOP_JOB(p_job_name, force => TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                NULL; -- تجاهل الأخطاء في حالة كانت الوظيفة متوقفة بالفعل
        END;
        
        -- إعادة تشغيل الوظيفة المجدولة
        DBMS_SCHEDULER.ENABLE(p_job_name);
        
        -- تسجيل إعادة تشغيل الوظيفة المجدولة
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'إعادة تشغيل وظيفة مجدولة', 
            'تم إعادة تشغيل الوظيفة المجدولة: ' || p_job_name,
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ---
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'ERROR', 'خطأ في إعادة تشغيل وظيفة مجدولة', 
                'الوظيفة المجدولة: ' || p_job_name || CHR(10) || 
                P_ERR_MSG,
                1
            );
            
            COMMIT;
            RAISE;
    END RESTART_SCHEDULED_JOB;
    
    -- تغيير جدول تنفيذ وظيفة مجدولة
    PROCEDURE CHANGE_JOB_SCHEDULE(
        p_job_name IN VARCHAR2,
        p_start_date IN TIMESTAMP WITH TIME ZONE,
        p_repeat_interval IN VARCHAR2
    ) IS
    P_ERR_MSG VARCHAR2(1001);
    BEGIN
        -- التحقق من وجود الوظيفة المجدولة
        DECLARE
            v_count NUMBER;
        BEGIN
            SELECT COUNT(*) INTO v_count
            FROM user_scheduler_jobs
            WHERE job_name = p_job_name;
            
            IF v_count = 0 THEN
                RAISE_APPLICATION_ERROR(-20001, 'الوظيفة المجدولة غير موجودة: ' || p_job_name);
            END IF;
        END;
        
        -- تغيير جدول تنفيذ الوظيفة المجدولة
        DBMS_SCHEDULER.SET_ATTRIBUTE(
            name      => p_job_name,
            attribute => 'start_date',
            value     => p_start_date
        );
        
        DBMS_SCHEDULER.SET_ATTRIBUTE(
            name      => p_job_name,
            attribute => 'repeat_interval',
            value     => p_repeat_interval
        );
        
        -- تسجيل تغيير جدول تنفيذ الوظيفة المجدولة
        INSERT INTO SYSTEM_LOGS (
            LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
        ) VALUES (
            'SCHEDULED_JOB', 'تغيير جدول تنفيذ وظيفة مجدولة', 
            'تم تغيير جدول تنفيذ الوظيفة المجدولة: ' || p_job_name || CHR(10) || 
            'تاريخ البدء الجديد: ' || TO_CHAR(p_start_date, 'DD/MM/YYYY HH24:MI:SS') || CHR(10) || 
            'الفاصل الزمني الجديد: ' || p_repeat_interval,
            1
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            P_ERR_MSG:='الخطأ: ' || SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
            ----
            INSERT INTO SYSTEM_LOGS (
                LOG_TYPE, LOG_MESSAGE, LOG_DETAILS, USER_ID
            ) VALUES (
                'ERROR', 'خطأ في تغيير جدول تنفيذ وظيفة مجدولة', 
                'الوظيفة المجدولة: ' || p_job_name || CHR(10) || 
                P_ERR_MSG,
                1
            );
            
            COMMIT;
            RAISE;
    END CHANGE_JOB_SCHEDULE;
END PKG_SYSTEM_ADMIN;
/


CREATE OR REPLACE PACKAGE BODY                PKG_TASKS AS
    -- إنشاء مهمة جديدة
    PROCEDURE CREATE_TASK(
        p_task_title IN VARCHAR2,
        p_task_description IN VARCHAR2,
        p_assigned_to IN NUMBER,
        p_due_date IN DATE,
        p_priority IN VARCHAR2,
        p_related_entity IN VARCHAR2,
        p_related_entity_id IN NUMBER,
        p_created_by IN NUMBER,
        p_task_id OUT NUMBER
    ) IS
        v_notification_id NUMBER;
    BEGIN
        -- إنشاء معرف المهمة
        SELECT SEQ_TASK_ID.NEXTVAL INTO p_task_id FROM DUAL;
        
        -- إدخال بيانات المهمة
        INSERT INTO TASKS (
            TASK_ID, TASK_TITLE, TASK_DESCRIPTION, ASSIGNED_TO,
            DUE_DATE, PRIORITY, TASK_STATUS, REFERENCE_TYPE,
            REFERENCE_ID, CREATED_BY, CREATION_DATE
        ) VALUES (
            p_task_id, p_task_title, p_task_description, p_assigned_to,
            p_due_date, p_priority, 'PENDING', p_related_entity,
            p_related_entity_id, p_created_by, SYSDATE
        );
        
        -- إرسال إشعار للمستخدم المسند إليه المهمة
        PKG_NOTIFICATIONS.SEND_USER_NOTIFICATION(
            p_user_id => p_assigned_to,
            p_notification_type => 'NEW_TASK',
            p_notification_title => 'مهمة جديدة: ' || p_task_title,
            p_notification_text => 'تم إسناد مهمة جديدة إليك: ' || p_task_title || 
                                  '. تاريخ الاستحقاق: ' || TO_CHAR(p_due_date, 'DD/MM/YYYY') || 
                                  '. الأولوية: ' || p_priority,
            p_related_entity => 'TASKS',
            p_related_entity_id => p_task_id,
            p_notification_id => v_notification_id
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_TASK;
    
    -- تحديث حالة المهمة
    PROCEDURE UPDATE_TASK_STATUS(
        p_task_id IN NUMBER,
        p_task_status IN VARCHAR2,
        p_completion_notes IN VARCHAR2 DEFAULT NULL,
        p_updated_by IN NUMBER
    ) IS
        v_notification_id NUMBER;
        v_task_title VARCHAR2(200);
        v_created_by NUMBER;
        v_assigned_to NUMBER;
        v_old_status VARCHAR2(20);
    BEGIN
        -- الحصول على بيانات المهمة الحالية
        SELECT TASK_TITLE, CREATED_BY, ASSIGNED_TO, TASK_STATUS
        INTO v_task_title, v_created_by, v_assigned_to, v_old_status
        FROM TASKS
        WHERE TASK_ID = p_task_id;
        
        -- تحديث حالة المهمة
        UPDATE TASKS
        SET TASK_STATUS = p_task_status,
            COMPLETION_NOTES = p_completion_notes,
            COMPLETION_DATE = CASE WHEN p_task_status = 'COMPLETED' THEN SYSDATE ELSE NULL END,
            UPDATED_BY = p_updated_by,
            LAST_UPDATE_DATE = SYSDATE
        WHERE TASK_ID = p_task_id;
        
        -- إرسال إشعار لمنشئ المهمة إذا كان مختلفاً عن المحدث
        IF v_created_by != p_updated_by THEN
            PKG_NOTIFICATIONS.SEND_USER_NOTIFICATION(
                p_user_id => v_created_by,
                p_notification_type => 'TASK_STATUS_UPDATED',
                p_notification_title => 'تحديث حالة المهمة: ' || v_task_title,
                p_notification_text => 'تم تحديث حالة المهمة "' || v_task_title || '" من "' || 
                                      v_old_status || '" إلى "' || p_task_status || '".',
                p_related_entity => 'TASKS',
                p_related_entity_id => p_task_id,
                p_notification_id => v_notification_id
            );
        END IF;
        
        -- إرسال إشعار للمستخدم المسند إليه المهمة إذا كان مختلفاً عن المحدث
        IF v_assigned_to != p_updated_by THEN
            PKG_NOTIFICATIONS.SEND_USER_NOTIFICATION(
                p_user_id => v_assigned_to,
                p_notification_type => 'TASK_STATUS_UPDATED',
                p_notification_title => 'تحديث حالة المهمة: ' || v_task_title,
                p_notification_text => 'تم تحديث حالة المهمة "' || v_task_title || '" من "' || 
                                      v_old_status || '" إلى "' || p_task_status || '".',
                p_related_entity => 'TASKS',
                p_related_entity_id => p_task_id,
                p_notification_id => v_notification_id
            );
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_TASK_STATUS;
    
    -- إعادة تعيين المهمة
    PROCEDURE REASSIGN_TASK(
        p_task_id IN NUMBER,
        p_assigned_to IN NUMBER,
        p_reassignment_reason IN VARCHAR2,
        p_updated_by IN NUMBER
    ) IS
        v_notification_id NUMBER;
        v_task_title VARCHAR2(200);
        v_old_assigned_to NUMBER;
        v_old_assigned_name VARCHAR2(100);
        v_new_assigned_name VARCHAR2(100);
    BEGIN
        -- الحصول على بيانات المهمة الحالية
        SELECT t.TASK_TITLE, t.ASSIGNED_TO, u1.FULL_NAME, u2.FULL_NAME
        INTO v_task_title, v_old_assigned_to, v_old_assigned_name, v_new_assigned_name
        FROM TASKS t
        JOIN USERS u1 ON t.ASSIGNED_TO = u1.USER_ID
        JOIN USERS u2 ON p_assigned_to = u2.USER_ID
        WHERE t.TASK_ID = p_task_id;
        
        -- إدخال سجل إعادة التعيين
        INSERT INTO TASK_REASSIGNMENTS (
            TASK_ID, OLD_ASSIGNED_TO, NEW_ASSIGNED_TO,
            REASSIGNMENT_REASON, REASSIGNED_BY, REASSIGNMENT_DATE
        ) VALUES (
            p_task_id, v_old_assigned_to, p_assigned_to,
            p_reassignment_reason, p_updated_by, SYSDATE
        );
        
        -- تحديث المهمة
        UPDATE TASKS
        SET ASSIGNED_TO = p_assigned_to,
            UPDATED_BY = p_updated_by,
            LAST_UPDATE_DATE = SYSDATE
        WHERE TASK_ID = p_task_id;
        
        -- إرسال إشعار للمستخدم الجديد المسند إليه المهمة
        PKG_NOTIFICATIONS.SEND_USER_NOTIFICATION(
            p_user_id => p_assigned_to,
            p_notification_type => 'TASK_ASSIGNED',
            p_notification_title => 'تم إسناد مهمة إليك: ' || v_task_title,
            p_notification_text => 'تم إعادة تعيين المهمة "' || v_task_title || '" إليك. ' ||
                                  'كانت مسندة سابقاً إلى ' || v_old_assigned_name || '.',
            p_related_entity => 'TASKS',
            p_related_entity_id => p_task_id,
            p_notification_id => v_notification_id
        );
        
        -- إرسال إشعار للمستخدم السابق المسند إليه المهمة
        PKG_NOTIFICATIONS.SEND_USER_NOTIFICATION(
            p_user_id => v_old_assigned_to,
            p_notification_type => 'TASK_REASSIGNED',
            p_notification_title => 'تم إعادة تعيين مهمة: ' || v_task_title,
            p_notification_text => 'تم إعادة تعيين المهمة "' || v_task_title || '" من قائمة مهامك ' ||
                                  'إلى ' || v_new_assigned_name || '.',
            p_related_entity => 'TASKS',
            p_related_entity_id => p_task_id,
            p_notification_id => v_notification_id
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END REASSIGN_TASK;
    
    -- الحصول على المهام المسندة للمستخدم
    FUNCTION GET_USER_TASKS(
        p_user_id IN NUMBER,
        p_task_status IN VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                t.TASK_ID, t.TASK_TITLE, t.TASK_DESCRIPTION, t.ASSIGNED_TO,
                u.FULL_NAME AS ASSIGNED_TO_NAME, t.DUE_DATE, t.PRIORITY,
                t.TASK_STATUS, t.REFERENCE_TYPE, t.REFERENCE_ID,
                CASE 
                    WHEN t.REFERENCE_TYPE = 'FINANCING_REQUESTS' THEN 
                        (SELECT REQUEST_NUMBER FROM FINANCING_REQUESTS WHERE REQUEST_ID = t.REFERENCE_ID)
                    WHEN t.REFERENCE_TYPE = 'CUSTOMERS' THEN 
                        (SELECT FULL_NAME FROM CUSTOMERS WHERE CUSTOMER_ID = t.REFERENCE_ID)
                    WHEN t.REFERENCE_TYPE = 'INSTALLMENT_SCHEDULE' THEN 
                        (SELECT 'قسط رقم ' || INSTALLMENT_SEQ || ' للطلب ' || 
                         (SELECT REQUEST_NUMBER FROM FINANCING_REQUESTS WHERE REQUEST_ID = i.REQUEST_ID)
                         FROM INSTALLMENT_SCHEDULE i WHERE INSTALLMENT_ID = t.REFERENCE_ID)
                    WHEN t.REFERENCE_TYPE = 'CUSTOMER_DOCUMENTS' THEN 
                        (SELECT DOCUMENT_TYPE || ' - ' || DOCUMENT_NUMBER FROM CUSTOMER_DOCUMENTS 
                         WHERE DOCUMENT_ID = t.REFERENCE_ID)
                    ELSE TO_CHAR(t.REFERENCE_ID)
                END AS RELATED_ENTITY_DESCRIPTION,
                t.CREATED_BY, c.FULL_NAME AS CREATED_BY_NAME,
                t.CREATION_DATE, t.COMPLETION_DATE, t.COMPLETION_NOTES,
                t.UPDATED_BY, t.LAST_UPDATE_DATE,
                CASE 
                    WHEN t.DUE_DATE < SYSDATE AND t.TASK_STATUS != 'COMPLETED' THEN 'OVERDUE'
                    WHEN t.DUE_DATE = TRUNC(SYSDATE) AND t.TASK_STATUS != 'COMPLETED' THEN 'DUE_TODAY'
                    WHEN t.DUE_DATE BETWEEN TRUNC(SYSDATE) + 1 AND TRUNC(SYSDATE) + 3 
                         AND t.TASK_STATUS != 'COMPLETED' THEN 'DUE_SOON'
                    ELSE 'NORMAL'
                END AS TASK_URGENCY
            FROM TASKS t
            JOIN USERS u ON t.ASSIGNED_TO = u.USER_ID
            JOIN USERS c ON t.CREATED_BY = c.USER_ID
            WHERE t.ASSIGNED_TO = p_user_id
            AND (p_task_status IS NULL OR t.TASK_STATUS = p_task_status)
            ORDER BY 
                CASE 
                    WHEN t.TASK_STATUS = 'PENDING' THEN 1
                    WHEN t.TASK_STATUS = 'IN_PROGRESS' THEN 2
                    WHEN t.TASK_STATUS = 'COMPLETED' THEN 3
                    ELSE 4
                END,
                CASE 
                    WHEN t.PRIORITY = 'HIGH' THEN 1
                    WHEN t.PRIORITY = 'MEDIUM' THEN 2
                    WHEN t.PRIORITY = 'LOW' THEN 3
                    ELSE 4
                END,
                t.DUE_DATE;
        
        RETURN v_cursor;
    END GET_USER_TASKS;
    
    -- الحصول على المهام المتعلقة بكيان معين
    FUNCTION GET_ENTITY_TASKS(
        p_related_entity IN VARCHAR2,
        p_related_entity_id IN NUMBER
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                t.TASK_ID, t.TASK_TITLE, t.TASK_DESCRIPTION, t.ASSIGNED_TO,
                u.FULL_NAME AS ASSIGNED_TO_NAME, t.DUE_DATE, t.PRIORITY,
                t.TASK_STATUS, t.REFERENCE_TYPE, t.REFERENCE_ID,
                t.CREATED_BY, c.FULL_NAME AS CREATED_BY_NAME,
                t.CREATION_DATE, t.COMPLETION_DATE, t.COMPLETION_NOTES,
                t.UPDATED_BY, t.LAST_UPDATE_DATE,
                CASE 
                    WHEN t.DUE_DATE < SYSDATE AND t.TASK_STATUS != 'COMPLETED' THEN 'OVERDUE'
                    WHEN t.DUE_DATE = TRUNC(SYSDATE) AND t.TASK_STATUS != 'COMPLETED' THEN 'DUE_TODAY'
                    WHEN t.DUE_DATE BETWEEN TRUNC(SYSDATE) + 1 AND TRUNC(SYSDATE) + 3 
                         AND t.TASK_STATUS != 'COMPLETED' THEN 'DUE_SOON'
                    ELSE 'NORMAL'
                END AS TASK_URGENCY
            FROM TASKS t
            JOIN USERS u ON t.ASSIGNED_TO = u.USER_ID
            JOIN USERS c ON t.CREATED_BY = c.USER_ID
            WHERE t.REFERENCE_TYPE = p_related_entity
            AND t.REFERENCE_ID = p_related_entity_id
            ORDER BY 
                CASE 
                    WHEN t.TASK_STATUS = 'PENDING' THEN 1
                    WHEN t.TASK_STATUS = 'IN_PROGRESS' THEN 2
                    WHEN t.TASK_STATUS = 'COMPLETED' THEN 3
                    ELSE 4
                END,
                CASE 
                    WHEN t.PRIORITY = 'HIGH' THEN 1
                    WHEN t.PRIORITY = 'MEDIUM' THEN 2
                    WHEN t.PRIORITY = 'LOW' THEN 3
                    ELSE 4
                END,
                t.DUE_DATE;
        
        RETURN v_cursor;
    END GET_ENTITY_TASKS;
    
    -- إنشاء مهام آلية للطلب الجديد
    PROCEDURE CREATE_REQUEST_TASKS(
        p_request_id IN NUMBER,
        p_created_by IN NUMBER
    ) IS
        v_task_id NUMBER;
        v_request_number VARCHAR2(50);
        v_customer_id NUMBER;
        v_customer_name VARCHAR2(100);
        v_product_id NUMBER;
        v_product_name VARCHAR2(100);
        v_assigned_to NUMBER;
        v_relationship_manager NUMBER;
        v_credit_analyst NUMBER;
        v_current_stage VARCHAR2(50);
    BEGIN
        -- الحصول على بيانات الطلب
        SELECT 
            r.REQUEST_NUMBER, r.CUSTOMER_ID, c.FULL_NAME, r.PRODUCT_ID, 
            p.PRODUCT_NAME, r.ASSIGNED_TO, c.RELATIONSHIP_MANAGER, r.CURRENT_STAGE_ID
        INTO 
            v_request_number, v_customer_id, v_customer_name, v_product_id, 
            v_product_name, v_assigned_to, v_relationship_manager, v_current_stage
        FROM FINANCING_REQUESTS r
        JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
        JOIN ISLAMIC_PRODUCTS p ON r.PRODUCT_ID = p.PRODUCT_ID
        WHERE r.REQUEST_ID = p_request_id;
        
        -- تعيين محلل ائتمان للطلب إذا كان في مرحلة التحليل الائتماني
        IF v_current_stage = 'CREDIT_ANALYSIS' THEN
            -- الحصول على محلل ائتمان متاح (يمكن تطوير منطق أكثر تعقيداً لتوزيع العمل)
            BEGIN
                SELECT USER_ID INTO v_credit_analyst
                FROM (
                    SELECT u.USER_ID
                    FROM USERS u
                    WHERE u.USER_ROLE = 'CREDIT_ANALYST'
                    AND u.USER_STATUS = 'ACTIVE'
                    ORDER BY (
                        SELECT COUNT(*)
                        FROM TASKS t
                        WHERE t.ASSIGNED_TO = u.USER_ID
                        AND t.TASK_STATUS IN ('PENDING', 'IN_PROGRESS')
                    ) ASC
                )
                WHERE ROWNUM = 1;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    v_credit_analyst := NULL;
            END;
            
            -- إنشاء مهمة تحليل ائتماني
            IF v_credit_analyst IS NOT NULL THEN
                CREATE_TASK(
                    p_task_title => 'تحليل ائتماني للطلب ' || v_request_number,
                    p_task_description => 'إجراء تحليل ائتماني للعميل ' || v_customer_name || 
                                         ' للطلب رقم ' || v_request_number || ' - منتج ' || v_product_name,
                    p_assigned_to => v_credit_analyst,
                    p_due_date => SYSDATE + 3, -- 3 أيام للتحليل الائتماني
                    p_priority => 'HIGH',
                    p_related_entity => 'FINANCING_REQUESTS',
                    p_related_entity_id => p_request_id,
                    p_created_by => p_created_by,
                    p_task_id => v_task_id
                );
                
                -- تحديث الطلب بمحلل الائتمان المعين
                UPDATE FINANCING_REQUESTS
                SET ASSIGNED_TO = v_credit_analyst
                WHERE REQUEST_ID = p_request_id;
            END IF;
        END IF;
        
        -- إنشاء مهمة لمدير العلاقة للمتابعة مع العميل
        IF v_relationship_manager IS NOT NULL THEN
            CREATE_TASK(
                p_task_title => 'متابعة طلب التمويل ' || v_request_number,
                p_task_description => 'متابعة طلب التمويل رقم ' || v_request_number || 
                                     ' للعميل ' || v_customer_name || ' والتأكد من اكتمال المستندات المطلوبة',
                p_assigned_to => v_relationship_manager,
                p_due_date => SYSDATE + 2, -- يومان للمتابعة
                p_priority => 'MEDIUM',
                p_related_entity => 'FINANCING_REQUESTS',
                p_related_entity_id => p_request_id,
                p_created_by => p_created_by,
                p_task_id => v_task_id
            );
        END IF;
        
        -- إنشاء مهمة للتحقق من المستندات
        CREATE_TASK(
            p_task_title => 'التحقق من مستندات الطلب ' || v_request_number,
            p_task_description => 'التحقق من اكتمال وصحة جميع المستندات المطلوبة للطلب رقم ' || 
                                 v_request_number || ' للعميل ' || v_customer_name,
            p_assigned_to => v_assigned_to,
            p_due_date => SYSDATE + 1, -- يوم واحد للتحقق
            p_priority => 'HIGH',
            p_related_entity => 'FINANCING_REQUESTS',
            p_related_entity_id => p_request_id,
            p_created_by => p_created_by,
            p_task_id => v_task_id
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_REQUEST_TASKS;
    
    -- إنشاء مهام المتابعة للأقساط المتأخرة
    PROCEDURE CREATE_OVERDUE_INSTALLMENT_TASKS IS
        v_task_id NUMBER;
        
        CURSOR c_overdue_installments IS
            SELECT 
                i.INSTALLMENT_ID, i.REQUEST_ID, r.REQUEST_NUMBER, i.INSTALLMENT_SEQ,
                i.DUE_DATE, TRUNC(SYSDATE - i.DUE_DATE) AS DAYS_OVERDUE,
                i.TOTAL_AMOUNT, r.CUSTOMER_ID, c.FULL_NAME AS CUSTOMER_NAME,
                c.RELATIONSHIP_MANAGER, c.CUSTOMER_TYPE
            FROM INSTALLMENT_SCHEDULE i
            JOIN FINANCING_REQUESTS r ON i.REQUEST_ID = r.REQUEST_ID
            JOIN CUSTOMERS c ON r.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE i.INSTALLMENT_STATUS IN ('OVERDUE')
            AND i.DUE_DATE < SYSDATE
            AND NOT EXISTS (
                SELECT 1 FROM TASKS t
                WHERE t.REFERENCE_TYPE = 'INSTALLMENT_SCHEDULE'
                AND t.REFERENCE_ID = i.INSTALLMENT_ID
                AND t.TASK_STATUS IN ('PENDING', 'IN_PROGRESS')
            );
    BEGIN
        FOR i IN c_overdue_installments LOOP
            -- تحديد المستخدم المسؤول عن المتابعة
            DECLARE
                v_assigned_to NUMBER;
                v_priority VARCHAR2(10);
                v_due_date DATE;
            BEGIN
                -- تحديد الأولوية بناءً على عدد أيام التأخير
                IF i.DAYS_OVERDUE > 30 THEN
                    v_priority := 'HIGH';
                    v_due_date := SYSDATE + 1; -- متابعة خلال يوم واحد
                ELSIF i.DAYS_OVERDUE > 15 THEN
                    v_priority := 'MEDIUM';
                    v_due_date := SYSDATE + 2; -- متابعة خلال يومين
                ELSE
                    v_priority := 'LOW';
                    v_due_date := SYSDATE + 3; -- متابعة خلال ثلاثة أيام
                END IF;
                
                -- تعيين المهمة لمدير العلاقة إذا كان موجوداً، وإلا لمسؤول التحصيل
                IF i.RELATIONSHIP_MANAGER IS NOT NULL THEN
                    v_assigned_to := i.RELATIONSHIP_MANAGER;
                ELSE
                    -- الحصول على مسؤول تحصيل متاح
                    BEGIN
                        SELECT USER_ID INTO v_assigned_to
                        FROM (
                            SELECT u.USER_ID
                            FROM USERS u
                            WHERE u.USER_ROLE = 'COLLECTION_OFFICER'
                            AND u.USER_STATUS = 'ACTIVE'
                            ORDER BY (
                                SELECT COUNT(*)
                                FROM TASKS t
                                WHERE t.ASSIGNED_TO = u.USER_ID
                                AND t.TASK_STATUS IN ('PENDING', 'IN_PROGRESS')
                            ) ASC
                        )
                        WHERE ROWNUM = 1;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            -- إذا لم يتم العثور على مسؤول تحصيل، استخدم مدير النظام
                            SELECT USER_ID INTO v_assigned_to
                            FROM USERS
                            WHERE USER_ROLE = 'ADMIN'
                            AND ROWNUM = 1;
                    END;
                END IF;
                
                -- إنشاء مهمة متابعة القسط المتأخر
                CREATE_TASK(
                    p_task_title => 'متابعة قسط متأخر - ' || i.CUSTOMER_NAME || ' - ' || i.DAYS_OVERDUE || ' يوم',
                    p_task_description => 'متابعة القسط المتأخر رقم ' || i.INSTALLMENT_SEQ || 
                                         ' للطلب رقم ' || i.REQUEST_NUMBER || ' للعميل ' || i.CUSTOMER_NAME || 
                                         '. تاريخ الاستحقاق: ' || TO_CHAR(i.DUE_DATE, 'DD/MM/YYYY') || 
                                         '. مدة التأخير: ' || i.DAYS_OVERDUE || ' يوم. ' ||
                                         'المبلغ المستحق: ' || TO_CHAR(i.TOTAL_AMOUNT, '999,999,999.99') || ' ريال.',
                    p_assigned_to => v_assigned_to,
                    p_due_date => v_due_date,
                    p_priority => v_priority,
                    p_related_entity => 'INSTALLMENT_SCHEDULE',
                    p_related_entity_id => i.INSTALLMENT_ID,
                    p_created_by => 1, -- مدير النظام
                    p_task_id => v_task_id
                );
            END;
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_OVERDUE_INSTALLMENT_TASKS;
    
    -- إنشاء مهام تجديد المستندات
    PROCEDURE CREATE_DOCUMENT_RENEWAL_TASKS(p_days_before_expiry IN NUMBER DEFAULT 30) IS
        v_task_id NUMBER;
        
        CURSOR c_expiring_documents IS
            SELECT 
                cd.DOCUMENT_ID, cd.DOCUMENT_TYPE, cd.DOCUMENT_NUMBER,
                cd.EXPIRY_DATE, TRUNC(cd.EXPIRY_DATE - SYSDATE) AS DAYS_TO_EXPIRY,
                c.CUSTOMER_ID, c.FULL_NAME AS CUSTOMER_NAME,
                c.RELATIONSHIP_MANAGER
            FROM CUSTOMER_DOCUMENTS cd
            JOIN CUSTOMERS c ON cd.CUSTOMER_ID = c.CUSTOMER_ID
            WHERE cd.EXPIRY_DATE BETWEEN SYSDATE AND (SYSDATE + p_days_before_expiry)
            AND cd.DOCUMENT_STATUS = 'ACTIVE'
            AND NOT EXISTS (
                SELECT 1 FROM TASKS t
                WHERE t.REFERENCE_TYPE = 'CUSTOMER_DOCUMENTS'
                AND t.REFERENCE_ID = cd.DOCUMENT_ID
                AND t.TASK_STATUS IN ('PENDING', 'IN_PROGRESS')
            );
    BEGIN
        FOR d IN c_expiring_documents LOOP
            -- تحديد المستخدم المسؤول عن المتابعة
            DECLARE
                v_assigned_to NUMBER;
                v_priority VARCHAR2(10);
                v_due_date DATE;
            BEGIN
                -- تحديد الأولوية بناءً على عدد أيام قبل الانتهاء
                IF d.DAYS_TO_EXPIRY <= 7 THEN
                    v_priority := 'HIGH';
                    v_due_date := SYSDATE + 1; -- متابعة خلال يوم واحد
                ELSIF d.DAYS_TO_EXPIRY <= 15 THEN
                    v_priority := 'MEDIUM';
                    v_due_date := SYSDATE + 3; -- متابعة خلال ثلاثة أيام
                ELSE
                    v_priority := 'LOW';
                    v_due_date := SYSDATE + 7; -- متابعة خلال أسبوع
                END IF;
                
                -- تعيين المهمة لمدير العلاقة إذا كان موجوداً، وإلا لمسؤول خدمة العملاء
                IF d.RELATIONSHIP_MANAGER IS NOT NULL THEN
                    v_assigned_to := d.RELATIONSHIP_MANAGER;
                ELSE
                    -- الحصول على مسؤول خدمة عملاء متاح
                    BEGIN
                        SELECT USER_ID INTO v_assigned_to
                        FROM (
                            SELECT u.USER_ID
                            FROM USERS u
                            WHERE u.USER_ROLE = 'CUSTOMER_SERVICE'
                            AND u.USER_STATUS = 'ACTIVE'
                            ORDER BY (
                                SELECT COUNT(*)
                                FROM TASKS t
                                WHERE t.ASSIGNED_TO = u.USER_ID
                                AND t.TASK_STATUS IN ('PENDING', 'IN_PROGRESS')
                            ) ASC
                        )
                        WHERE ROWNUM = 1;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            -- إذا لم يتم العثور على مسؤول خدمة عملاء، استخدم مدير النظام
                            SELECT USER_ID INTO v_assigned_to
                            FROM USERS
                            WHERE USER_ROLE = 'ADMIN'
                            AND ROWNUM = 1;
                    END;
                END IF;
                
                -- إنشاء مهمة متابعة تجديد المستند
                CREATE_TASK(
                    p_task_title => 'متابعة تجديد مستند: ' || d.DOCUMENT_TYPE || ' - ' || d.CUSTOMER_NAME,
                    p_task_description => 'متابعة تجديد مستند ' || d.DOCUMENT_TYPE || ' رقم ' || d.DOCUMENT_NUMBER || 
                                         ' للعميل ' || d.CUSTOMER_NAME || '. ' ||
                                         'تاريخ انتهاء المستند: ' || TO_CHAR(d.EXPIRY_DATE, 'DD/MM/YYYY') || 
                                         ' (متبقي ' || d.DAYS_TO_EXPIRY || ' يوم). ' ||
                                         'يرجى التواصل مع العميل لتذكيره بتجديد المستند وتحديث بياناته في النظام.',
                    p_assigned_to => v_assigned_to,
                    p_due_date => v_due_date,
                    p_priority => v_priority,
                    p_related_entity => 'CUSTOMER_DOCUMENTS',
                    p_related_entity_id => d.DOCUMENT_ID,
                    p_created_by => 1, -- مدير النظام
                    p_task_id => v_task_id
                );
            END;
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_DOCUMENT_RENEWAL_TASKS;
END PKG_TASKS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_USERS AS
    -- إنشاء مستخدم جديد
    PROCEDURE CREATE_USER(
        p_username IN VARCHAR2,
        p_password IN VARCHAR2,
        p_full_name IN VARCHAR2,
        p_email IN VARCHAR2,
        p_mobile_number IN VARCHAR2,
        p_department IN VARCHAR2,
        p_job_title IN VARCHAR2,
        p_user_role IN VARCHAR2,
        p_created_by IN VARCHAR2,
        p_user_id OUT NUMBER
    ) IS
        v_hashed_password VARCHAR2(100);
        v_count NUMBER;
    BEGIN
        -- التحقق من عدم وجود مستخدم بنفس اسم المستخدم
        SELECT COUNT(*) INTO v_count
        FROM USERS
        WHERE USERNAME = p_username;
        
        IF v_count > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'اسم المستخدم موجود بالفعل');
        END IF;
        
        -- تشفير كلمة المرور
        v_hashed_password :=p_password;--- DBMS_CRYPTO.HASH(UTL_RAW.CAST_TO_RAW(p_password), DBMS_CRYPTO.HASH_SH1);
        
        -- إنشاء معرف المستخدم
        SELECT SEQ_USER_ID.NEXTVAL INTO p_user_id FROM DUAL;
        
        -- إدخال بيانات المستخدم
        INSERT INTO USERS (
            USER_ID, USERNAME, PASSWORD, FULL_NAME, EMAIL, MOBILE_NUMBER,
            DEPARTMENT, POSITION, USER_ROLE, USER_STATUS, CREATION_DATE, CREATED_BY
        ) VALUES (
            p_user_id, p_username, v_hashed_password, p_full_name, p_email, p_mobile_number,
            p_department, p_job_title, p_user_role, 1, SYSDATE, p_created_by
        );
        
        -- إضافة صلاحيات المستخدم بناءً على دوره
        INSERT INTO USER_PERMISSIONS (
            USER_ID, PERMISSION_ID, GRANTED_BY, GRANTED_DATE
        )
        SELECT p_user_id, rp.PERMISSION_ID, p_created_by, SYSDATE
        FROM ROLE_PERMISSIONS rp
        WHERE rp.ROLE_ID = (SELECT ROLE_ID FROM ROLES WHERE ROLE_NAME = p_user_role);
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CREATE_USER;
    
    -- تحديث بيانات المستخدم
    PROCEDURE UPDATE_USER(
        p_user_id IN NUMBER,
        p_full_name IN VARCHAR2,
        p_email IN VARCHAR2,
        p_mobile_number IN VARCHAR2,
        p_department IN VARCHAR2,
        p_job_title IN VARCHAR2,
        p_user_role IN VARCHAR2,
        p_updated_by IN VARCHAR2
    ) IS
        v_old_role VARCHAR2(50);
    BEGIN
        -- الحصول على الدور الحالي للمستخدم
        SELECT USER_ROLE INTO v_old_role
        FROM USERS
        WHERE USER_ID = p_user_id;
        
        -- تحديث بيانات المستخدم
        UPDATE USERS
        SET FULL_NAME = p_full_name,
            EMAIL = p_email,
            MOBILE_NUMBER = p_mobile_number,
            DEPARTMENT = p_department,
            POSITION = p_job_title,
            USER_ROLE = p_user_role,
            LAST_UPDATE_DATE = SYSDATE,
            LAST_UPDATED_BY = p_updated_by
        WHERE USER_ID = p_user_id;
        
        -- إذا تغير دور المستخدم، قم بتحديث الصلاحيات
        IF v_old_role <> p_user_role THEN
            -- حذف الصلاحيات الحالية
            DELETE FROM USER_PERMISSIONS
            WHERE USER_ID = p_user_id;
            
            -- إضافة الصلاحيات الجديدة بناءً على الدور الجديد
            INSERT INTO USER_PERMISSIONS (
                USER_ID, PERMISSION_ID, GRANTED_BY, GRANTED_DATE
            )
            SELECT p_user_id, rp.PERMISSION_ID, p_updated_by, SYSDATE
            FROM ROLE_PERMISSIONS rp
            WHERE rp.ROLE_ID = (SELECT ROLE_ID FROM ROLES WHERE ROLE_NAME = p_user_role);
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END UPDATE_USER;
    
    -- تغيير كلمة المرور
    PROCEDURE CHANGE_PASSWORD(
        p_user_id IN NUMBER,
        p_old_password IN VARCHAR2,
        p_new_password IN VARCHAR2,
        p_updated_by IN VARCHAR2
    ) IS
        v_stored_password VARCHAR2(100);
        v_old_hashed_password VARCHAR2(100);
        v_new_hashed_password VARCHAR2(100);
    BEGIN
        -- الحصول على كلمة المرور المخزنة
        SELECT PASSWORD INTO v_stored_password
        FROM USERS
        WHERE USER_ID = p_user_id;
        
        -- تشفير كلمة المرور القديمة للمقارنة
        v_old_hashed_password := p_old_password;---DBMS_CRYPTO.HASH(UTL_RAW.CAST_TO_RAW(p_old_password), DBMS_CRYPTO.HASH_SH1);
        
        -- التحقق من صحة كلمة المرور القديمة
        IF v_stored_password <> v_old_hashed_password THEN
            RAISE_APPLICATION_ERROR(-20002, 'كلمة المرور القديمة غير صحيحة');
        END IF;
        
        -- تشفير كلمة المرور الجديدة
        v_new_hashed_password := p_new_password;---DBMS_CRYPTO.HASH(UTL_RAW.CAST_TO_RAW(p_new_password), DBMS_CRYPTO.HASH_SH1);
        
        -- تحديث كلمة المرور
        UPDATE USERS
        SET PASSWORD = v_new_hashed_password,
            PASSWORD_CHANGE_DATE = SYSDATE,
            LAST_UPDATE_DATE = SYSDATE,
            LAST_UPDATED_BY = p_updated_by
        WHERE USER_ID = p_user_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END CHANGE_PASSWORD;
    
    -- تعطيل/تفعيل المستخدم
    PROCEDURE TOGGLE_USER_STATUS(
        p_user_id IN NUMBER,
        p_is_active IN NUMBER,
        p_updated_by IN VARCHAR2
    ) IS
    BEGIN
        UPDATE USERS
        SET USER_STATUS ='ACTIVE',--- p_is_active,
            LAST_UPDATE_DATE = SYSDATE,
            LAST_UPDATED_BY = p_updated_by
        WHERE USER_ID = p_user_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END TOGGLE_USER_STATUS;
    
    -- التحقق من صحة بيانات الدخول
    FUNCTION VALIDATE_LOGIN(
        p_username IN VARCHAR2,
        p_password IN VARCHAR2
    ) RETURN NUMBER IS
        v_user_id NUMBER;
        v_stored_password VARCHAR2(100);
        v_hashed_password VARCHAR2(100);
        v_is_active NUMBER;
    BEGIN
        -- البحث عن المستخدم
        BEGIN
            SELECT USER_ID, PASSWORD, USER_STATUS
            INTO v_user_id, v_stored_password, v_is_active
            FROM USERS
            WHERE USERNAME = p_username;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RETURN 0; -- المستخدم غير موجود
        END;
        
        -- التحقق من حالة المستخدم
        IF v_is_active = 0 THEN
            RETURN -1; -- المستخدم معطل
        END IF;
        
        -- تشفير كلمة المرور للمقارنة
        v_hashed_password :=p_password;--- DBMS_CRYPTO.HASH(UTL_RAW.CAST_TO_RAW(p_password), DBMS_CRYPTO.HASH_SH1);
        
        -- التحقق من صحة كلمة المرور
        IF v_stored_password = v_hashed_password THEN
            RETURN v_user_id; -- تسجيل الدخول ناجح
        ELSE
            RETURN 0; -- كلمة المرور غير صحيحة
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 0;
    END VALIDATE_LOGIN;
    
    -- الحصول على بيانات المستخدم
    FUNCTION GET_USER_INFO(p_user_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT USER_ID, USERNAME, FULL_NAME, EMAIL, MOBILE_NUMBER,
                   DEPARTMENT, POSITION, USER_ROLE, USER_STATUS,
                   LAST_LOGIN_DATE, CREATION_DATE, CREATED_BY,
                   LAST_UPDATE_DATE, LAST_UPDATED_BY
            FROM USERS
            WHERE USER_ID = p_user_id;
        RETURN v_cursor;
    END GET_USER_INFO;
    
    -- الحصول على قائمة المستخدمين
    FUNCTION GET_USERS_LIST(
        p_department IN VARCHAR2 DEFAULT NULL,
        p_user_role IN VARCHAR2 DEFAULT NULL,
        p_is_active IN NUMBER DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT USER_ID, USERNAME, FULL_NAME, EMAIL, MOBILE_NUMBER,
                   DEPARTMENT, POSITION, USER_ROLE, USER_STATUS,
                   LAST_LOGIN_DATE, CREATION_DATE
            FROM USERS
            WHERE (p_department IS NULL OR DEPARTMENT = p_department)
            AND (p_user_role IS NULL OR USER_ROLE = p_user_role)
            AND (p_is_active IS NULL OR USER_STATUS = 'ACTIVE')
            ORDER BY FULL_NAME;
        RETURN v_cursor;
    END GET_USERS_LIST;
    
    -- الحصول على قائمة المستخدمين حسب الصلاحية
    FUNCTION GET_USERS_BY_PERMISSION(
        p_permission_code IN VARCHAR2
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT u.USER_ID, u.USERNAME, u.FULL_NAME, u.EMAIL, u.MOBILE_NUMBER,
                   u.DEPARTMENT, u.POSITION, u.USER_ROLE, u.USER_STATUS
            FROM USERS u
            JOIN USER_PERMISSIONS up ON u.USER_ID = up.USER_ID
            JOIN PERMISSIONS p ON up.PERMISSION_ID = p.PERMISSION_ID
            WHERE p.PERMISSION_CODE = p_permission_code
            AND u.USER_STATUS = 'ACTIVE'
            ORDER BY u.FULL_NAME;
        RETURN v_cursor;
    END GET_USERS_BY_PERMISSION;
    
    -- تسجيل دخول المستخدم
    PROCEDURE LOG_USER_LOGIN(
        p_user_id IN NUMBER,
        p_login_ip IN VARCHAR2,
        p_user_agent IN VARCHAR2,
        p_login_status IN VARCHAR2,
        p_login_id OUT NUMBER
    ) IS
    BEGIN
        SELECT SEQ_LOGIN_ID.NEXTVAL INTO p_login_id FROM DUAL;
        
        INSERT INTO LOGIN_HISTORY (
            LOGIN_ID, USER_ID, LOGIN_DATE, IP_ADDRESS, USER_AGENT, LOGIN_STATUS
        ) VALUES (
            p_login_id, p_user_id, SYSDATE, p_login_ip, p_user_agent, p_login_status
        );
        
        IF p_login_status = 'SUCCESS' THEN
            UPDATE USERS
            SET LAST_LOGIN_DATE = SYSDATE
            WHERE USER_ID = p_user_id;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END LOG_USER_LOGIN;
    
    -- تسجيل خروج المستخدم
    PROCEDURE LOG_USER_LOGOUT(
        p_login_id IN NUMBER
    ) IS
    BEGIN
        UPDATE LOGIN_HISTORY
        SET LOGOUT_DATE = SYSDATE
        WHERE LOGIN_ID = p_login_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END LOG_USER_LOGOUT;
END PKG_USERS;
/


CREATE OR REPLACE PACKAGE BODY                PKG_WORKFLOW AS
    -- إنشاء سير عمل جديد
    PROCEDURE CREATE_WORKFLOW(
        p_workflow_type IN VARCHAR2,
        p_reference_type IN VARCHAR2,
        p_reference_id IN NUMBER,
        p_priority IN VARCHAR2,
        p_created_by IN NUMBER,
        p_workflow_id OUT NUMBER
    ) IS
    BEGIN
        -- إنشاء سجل سير العمل الجديد
        INSERT INTO WORKFLOWS (
            WORKFLOW_ID, WORKFLOW_TYPE, REFERENCE_TYPE, REFERENCE_ID,
            WORKFLOW_STATUS, PRIORITY, CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_WORKFLOW_ID.NEXTVAL, p_workflow_type, p_reference_type, p_reference_id,
            'PENDING', p_priority, p_created_by, SYSTIMESTAMP
        ) RETURNING WORKFLOW_ID INTO p_workflow_id;
        
        -- تسجيل حدث إنشاء سير العمل
        INSERT INTO WORKFLOW_HISTORY (
            HISTORY_ID, WORKFLOW_ID, ACTION_TYPE, ACTION_BY,
            ACTION_DATE, COMMENTS
        ) VALUES (
            SEQ_HISTORY_ID.NEXTVAL, p_workflow_id, 'CREATE', p_created_by,
            SYSTIMESTAMP, 'تم إنشاء سير العمل'
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END CREATE_WORKFLOW;
    
    -- إضافة مهمة إلى سير العمل
    PROCEDURE ADD_WORKFLOW_TASK(
        p_workflow_id IN NUMBER,
        p_task_type IN VARCHAR2,
        p_task_name IN VARCHAR2,
        p_task_description IN VARCHAR2,
        p_assigned_to IN NUMBER,
        p_due_date IN DATE,
        p_sequence_number IN NUMBER,
        p_created_by IN NUMBER,
        p_task_id OUT NUMBER
    ) IS
    BEGIN
        -- إنشاء سجل المهمة الجديدة
        INSERT INTO WORKFLOW_TASKS (
            TASK_ID, WORKFLOW_ID, TASK_TYPE, TASK_NAME, TASK_DESCRIPTION,
            ASSIGNED_TO, DUE_DATE, SEQUENCE_NUMBER, TASK_STATUS,
            CREATED_BY, CREATION_DATE
        ) VALUES (
            SEQ_TASK_ID.NEXTVAL, p_workflow_id, p_task_type, p_task_name, p_task_description,
            p_assigned_to, p_due_date, p_sequence_number, TASK_STATUS_PENDING,
            p_created_by, SYSTIMESTAMP
        ) RETURNING TASK_ID INTO p_task_id;
        
        -- تسجيل حدث إنشاء المهمة
        INSERT INTO WORKFLOW_HISTORY (
            HISTORY_ID, WORKFLOW_ID, TASK_ID, ACTION_TYPE, ACTION_BY,
            ACTION_DATE, COMMENTS
        ) VALUES (
            SEQ_HISTORY_ID.NEXTVAL, p_workflow_id, p_task_id, 'CREATE_TASK', p_created_by,
            SYSTIMESTAMP, 'تم إنشاء المهمة: ' || p_task_name
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END ADD_WORKFLOW_TASK;
    
    -- تحديث حالة المهمة
    PROCEDURE UPDATE_TASK_STATUS(
        p_task_id IN NUMBER,
        p_task_status IN VARCHAR2,
        p_comments IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
        v_workflow_id NUMBER;
        v_current_status VARCHAR2(30);
        v_sequence_number NUMBER;
        v_next_task_id NUMBER;
    BEGIN
        p_success := FALSE;
        
        -- الحصول على معلومات المهمة الحالية
        SELECT WORKFLOW_ID, TASK_STATUS, SEQUENCE_NUMBER
        INTO v_workflow_id, v_current_status, v_sequence_number
        FROM WORKFLOW_TASKS
        WHERE TASK_ID = p_task_id;
        
        -- التحقق من أن المهمة ليست مكتملة أو مرفوضة بالفعل
        IF v_current_status IN (TASK_STATUS_COMPLETED, TASK_STATUS_REJECTED, TASK_STATUS_CANCELLED) THEN
            p_error_message := 'لا يمكن تحديث حالة المهمة لأنها بالفعل ' || v_current_status;
            RETURN;
        END IF;
        
        -- تحديث حالة المهمة
        UPDATE WORKFLOW_TASKS
        SET TASK_STATUS = p_task_status,
            COMPLETION_DATE = CASE WHEN p_task_status IN (TASK_STATUS_COMPLETED, TASK_STATUS_REJECTED) THEN SYSTIMESTAMP ELSE NULL END,
            LAST_UPDATE_BY = p_updated_by,
            LAST_UPDATE_DATE = SYSTIMESTAMP
        WHERE TASK_ID = p_task_id;
        
        -- تسجيل حدث تحديث المهمة
        INSERT INTO WORKFLOW_HISTORY (
            HISTORY_ID, WORKFLOW_ID, TASK_ID, ACTION_TYPE, ACTION_BY,
            ACTION_DATE, COMMENTS
        ) VALUES (
            SEQ_HISTORY_ID.NEXTVAL, v_workflow_id, p_task_id, 'UPDATE_TASK', p_updated_by,
            SYSTIMESTAMP, 'تم تحديث حالة المهمة إلى: ' || p_task_status || 
                         CASE WHEN p_comments IS NOT NULL THEN ' - ' || p_comments ELSE '' END
        );
        
        -- إذا تم إكمال المهمة، قم بتنشيط المهمة التالية في التسلسل
        IF p_task_status = TASK_STATUS_COMPLETED THEN
            -- البحث عن المهمة التالية في التسلسل
            BEGIN
                SELECT TASK_ID
                INTO v_next_task_id
                FROM WORKFLOW_TASKS
                WHERE WORKFLOW_ID = v_workflow_id
                AND SEQUENCE_NUMBER > v_sequence_number
                AND TASK_STATUS = TASK_STATUS_PENDING
                ORDER BY SEQUENCE_NUMBER
                FETCH FIRST 1 ROW ONLY;
                
                -- تحديث حالة المهمة التالية إلى قيد التنفيذ
                UPDATE WORKFLOW_TASKS
                SET TASK_STATUS = TASK_STATUS_IN_PROGRESS,
                    LAST_UPDATE_BY = p_updated_by,
                    LAST_UPDATE_DATE = SYSTIMESTAMP
                WHERE TASK_ID = v_next_task_id;
                
                -- تسجيل حدث تنشيط المهمة التالية
                INSERT INTO WORKFLOW_HISTORY (
                    HISTORY_ID, WORKFLOW_ID, TASK_ID, ACTION_TYPE, ACTION_BY,
                    ACTION_DATE, COMMENTS
                ) VALUES (
                    SEQ_HISTORY_ID.NEXTVAL, v_workflow_id, v_next_task_id, 'ACTIVATE_TASK', p_updated_by,
                    SYSTIMESTAMP, 'تم تنشيط المهمة التالية في التسلسل'
                );
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    -- لا توجد مهام أخرى، تحقق مما إذا كانت جميع المهام مكتملة
                    IF ARE_ALL_TASKS_COMPLETED(v_workflow_id) THEN
                        -- تحديث حالة سير العمل إلى مكتمل
                        UPDATE WORKFLOWS
                        SET WORKFLOW_STATUS = 'COMPLETED',
                            COMPLETION_DATE = SYSTIMESTAMP,
                            LAST_UPDATE_BY = p_updated_by,
                            LAST_UPDATE_DATE = SYSTIMESTAMP
                        WHERE WORKFLOW_ID = v_workflow_id;
                        
                        -- تسجيل حدث إكمال سير العمل
                        INSERT INTO WORKFLOW_HISTORY (
                            HISTORY_ID, WORKFLOW_ID, ACTION_TYPE, ACTION_BY,
                            ACTION_DATE, COMMENTS
                        ) VALUES (
                            SEQ_HISTORY_ID.NEXTVAL, v_workflow_id, 'COMPLETE_WORKFLOW', p_updated_by,
                            SYSTIMESTAMP, 'تم إكمال جميع المهام في سير العمل'
                        );
                    END IF;
            END;
        ELSIF p_task_status = TASK_STATUS_REJECTED THEN
            -- إذا تم رفض المهمة، قم بتحديث حالة سير العمل إلى مرفوض
            UPDATE WORKFLOWS
            SET WORKFLOW_STATUS = 'REJECTED',
                COMPLETION_DATE = SYSTIMESTAMP,
                LAST_UPDATE_BY = p_updated_by,
                LAST_UPDATE_DATE = SYSTIMESTAMP
            WHERE WORKFLOW_ID = v_workflow_id;
            
            -- تسجيل حدث رفض سير العمل
            INSERT INTO WORKFLOW_HISTORY (
                HISTORY_ID, WORKFLOW_ID, ACTION_TYPE, ACTION_BY,
                ACTION_DATE, COMMENTS
            ) VALUES (
                SEQ_HISTORY_ID.NEXTVAL, v_workflow_id, 'REJECT_WORKFLOW', p_updated_by,
                SYSTIMESTAMP, 'تم رفض سير العمل بسبب رفض المهمة: ' || 
                             CASE WHEN p_comments IS NOT NULL THEN p_comments ELSE 'لا يوجد سبب محدد' END
--- EMAD            );
            );
        END IF;
        
        p_success := TRUE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_error_message := 'المهمة غير موجودة';
        WHEN OTHERS THEN
            p_error_message := 'حدث خطأ: ' || SQLERRM;
    END UPDATE_TASK_STATUS;
    
    -- تحديث حالة سير العمل
    PROCEDURE UPDATE_WORKFLOW_STATUS(
        p_workflow_id IN NUMBER,
        p_workflow_status IN VARCHAR2,
        p_comments IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
        v_current_status VARCHAR2(30);
    BEGIN
        p_success := FALSE;
        
        -- الحصول على الحالة الحالية لسير العمل
        SELECT WORKFLOW_STATUS
        INTO v_current_status
        FROM WORKFLOWS
        WHERE WORKFLOW_ID = p_workflow_id;
        
        -- التحقق من أن سير العمل ليس مكتملاً أو مرفوضاً بالفعل
        IF v_current_status IN ('COMPLETED', 'REJECTED', 'CANCELLED') THEN
            p_error_message := 'لا يمكن تحديث حالة سير العمل لأنه بالفعل ' || v_current_status;
            RETURN;
        END IF;
        
        -- تحديث حالة سير العمل
        UPDATE WORKFLOWS
        SET WORKFLOW_STATUS = p_workflow_status,
            COMPLETION_DATE = CASE WHEN p_workflow_status IN ('COMPLETED', 'REJECTED', 'CANCELLED') THEN SYSTIMESTAMP ELSE NULL END,
            LAST_UPDATE_BY = p_updated_by,
            LAST_UPDATE_DATE = SYSTIMESTAMP
        WHERE WORKFLOW_ID = p_workflow_id;
        
        -- تسجيل حدث تحديث سير العمل
        INSERT INTO WORKFLOW_HISTORY (
            HISTORY_ID, WORKFLOW_ID, ACTION_TYPE, ACTION_BY,
            ACTION_DATE, COMMENTS
        ) VALUES (
            SEQ_HISTORY_ID.NEXTVAL, p_workflow_id, 'UPDATE_WORKFLOW', p_updated_by,
            SYSTIMESTAMP, 'تم تحديث حالة سير العمل إلى: ' || p_workflow_status || 
                         CASE WHEN p_comments IS NOT NULL THEN ' - ' || p_comments ELSE '' END
        );
        
        -- إذا تم إلغاء سير العمل، قم بإلغاء جميع المهام المعلقة
        IF p_workflow_status = 'CANCELLED' THEN
            UPDATE WORKFLOW_TASKS
            SET TASK_STATUS = TASK_STATUS_CANCELLED,
                LAST_UPDATE_BY = p_updated_by,
                LAST_UPDATE_DATE = SYSTIMESTAMP
            WHERE WORKFLOW_ID = p_workflow_id
            AND TASK_STATUS IN (TASK_STATUS_PENDING, TASK_STATUS_IN_PROGRESS);
            
            -- تسجيل حدث إلغاء المهام
            INSERT INTO WORKFLOW_HISTORY (
                HISTORY_ID, WORKFLOW_ID, ACTION_TYPE, ACTION_BY,
                ACTION_DATE, COMMENTS
            ) VALUES (
                SEQ_HISTORY_ID.NEXTVAL, p_workflow_id, 'CANCEL_TASKS', p_updated_by,
                SYSTIMESTAMP, 'تم إلغاء جميع المهام المعلقة'
            );
        END IF;
        
        p_success := TRUE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_error_message := 'سير العمل غير موجود';
        WHEN OTHERS THEN
            p_error_message := 'حدث خطأ: ' || SQLERRM;
    END UPDATE_WORKFLOW_STATUS;
    
    -- إعادة تعيين المهمة لمستخدم آخر
    PROCEDURE REASSIGN_TASK(
        p_task_id IN NUMBER,
        p_new_assignee IN NUMBER,
        p_reassign_reason IN VARCHAR2,
        p_updated_by IN NUMBER,
        p_success OUT BOOLEAN,
        p_error_message OUT VARCHAR2
    ) IS
        v_workflow_id NUMBER;
        v_current_assignee NUMBER;
        v_task_status VARCHAR2(30);
    BEGIN
        p_success := FALSE;
        
        -- الحصول على معلومات المهمة الحالية
        SELECT WORKFLOW_ID, ASSIGNED_TO, TASK_STATUS
        INTO v_workflow_id, v_current_assignee, v_task_status
        FROM WORKFLOW_TASKS
        WHERE TASK_ID = p_task_id;
        
        -- التحقق من أن المهمة ليست مكتملة أو مرفوضة أو ملغاة
        IF v_task_status IN (TASK_STATUS_COMPLETED, TASK_STATUS_REJECTED, TASK_STATUS_CANCELLED) THEN
            p_error_message := 'لا يمكن إعادة تعيين المهمة لأنها بالفعل ' || v_task_status;
            RETURN;
        END IF;
        
        -- التحقق من أن المستخدم الجديد مختلف عن المستخدم الحالي
        IF v_current_assignee = p_new_assignee THEN
            p_error_message := 'المهمة معينة بالفعل للمستخدم المحدد';
            RETURN;
        END IF;
        
        -- تحديث تعيين المهمة
        UPDATE WORKFLOW_TASKS
        SET ASSIGNED_TO = p_new_assignee,
            LAST_UPDATE_BY = p_updated_by,
            LAST_UPDATE_DATE = SYSTIMESTAMP
        WHERE TASK_ID = p_task_id;
        
        -- تسجيل حدث إعادة تعيين المهمة
        INSERT INTO WORKFLOW_HISTORY (
            HISTORY_ID, WORKFLOW_ID, TASK_ID, ACTION_TYPE, ACTION_BY,
            ACTION_DATE, COMMENTS
        ) VALUES (
            SEQ_HISTORY_ID.NEXTVAL, v_workflow_id, p_task_id, 'REASSIGN_TASK', p_updated_by,
            SYSTIMESTAMP, 'تم إعادة تعيين المهمة من المستخدم ' || v_current_assignee || 
                         ' إلى المستخدم ' || p_new_assignee || 
                         CASE WHEN p_reassign_reason IS NOT NULL THEN ' - السبب: ' || p_reassign_reason ELSE '' END
        );
        
        p_success := TRUE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_error_message := 'المهمة غير موجودة';
        WHEN OTHERS THEN
            p_error_message := 'حدث خطأ: ' || SQLERRM;
    END REASSIGN_TASK;
    
    -- الحصول على المهام المعلقة للمستخدم
    FUNCTION GET_USER_PENDING_TASKS(
        p_user_id IN NUMBER
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                wt.TASK_ID,
                wt.WORKFLOW_ID,
                w.WORKFLOW_TYPE,
                w.REFERENCE_TYPE,
                w.REFERENCE_ID,
                wt.TASK_TYPE,
                wt.TASK_NAME,
                wt.TASK_DESCRIPTION,
                wt.SEQUENCE_NUMBER,
                wt.TASK_STATUS,
                wt.DUE_DATE,
                w.PRIORITY,
                CASE 
                    WHEN wt.DUE_DATE < TRUNC(SYSDATE) THEN 'OVERDUE'
                    WHEN wt.DUE_DATE = TRUNC(SYSDATE) THEN 'DUE_TODAY'
                    WHEN wt.DUE_DATE <= TRUNC(SYSDATE) + 3 THEN 'DUE_SOON'
                    ELSE 'NORMAL'
                END AS DUE_STATUS,
                TRUNC(SYSDATE) - TRUNC(wt.DUE_DATE) AS DAYS_OVERDUE,
                wt.CREATION_DATE,
                u.FULL_NAME AS CREATED_BY_NAME
            FROM 
                WORKFLOW_TASKS wt
            JOIN 
                WORKFLOWS w ON wt.WORKFLOW_ID = w.WORKFLOW_ID
            JOIN 
                USERS u ON wt.CREATED_BY = u.USER_ID
            WHERE 
                wt.ASSIGNED_TO = p_user_id
                AND wt.TASK_STATUS IN (TASK_STATUS_PENDING, TASK_STATUS_IN_PROGRESS)
                AND w.WORKFLOW_STATUS NOT IN ('COMPLETED', 'REJECTED', 'CANCELLED')
            ORDER BY 
                CASE w.PRIORITY
                    WHEN 'HIGH' THEN 1
                    WHEN 'MEDIUM' THEN 2
                    WHEN 'LOW' THEN 3
                    ELSE 4
                END,
                CASE 
                    WHEN wt.DUE_DATE < TRUNC(SYSDATE) THEN 1
                    WHEN wt.DUE_DATE = TRUNC(SYSDATE) THEN 2
                    WHEN wt.DUE_DATE <= TRUNC(SYSDATE) + 3 THEN 3
                    ELSE 4
                END,
                wt.DUE_DATE;
        
        RETURN v_cursor;
    END GET_USER_PENDING_TASKS;
    
    -- الحصول على تفاصيل سير العمل
    FUNCTION GET_WORKFLOW_DETAILS(
        p_workflow_id IN NUMBER
    ) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT 
                w.WORKFLOW_ID,
                w.WORKFLOW_TYPE,
                w.REFERENCE_TYPE,
                w.REFERENCE_ID,
                w.WORKFLOW_STATUS,
                w.PRIORITY,
                w.CREATION_DATE,
                w.COMPLETION_DATE,
                creator.FULL_NAME AS CREATED_BY_NAME,
                updater.FULL_NAME AS LAST_UPDATED_BY_NAME,
                (
                    SELECT COUNT(*)
                    FROM WORKFLOW_TASKS wt
                    WHERE wt.WORKFLOW_ID = w.WORKFLOW_ID
                ) AS TOTAL_TASKS,
                (
                    SELECT COUNT(*)
                    FROM WORKFLOW_TASKS wt
                    WHERE wt.WORKFLOW_ID = w.WORKFLOW_ID
                    AND wt.TASK_STATUS = TASK_STATUS_COMPLETED
                ) AS COMPLETED_TASKS,
                (
                    SELECT JSON_ARRAYAGG(
                        JSON_OBJECT(
                            'task_id' VALUE wt.TASK_ID,
                            'task_type' VALUE wt.TASK_TYPE,
                            'task_name' VALUE wt.TASK_NAME,
                            'task_description' VALUE wt.TASK_DESCRIPTION,
                            'sequence_number' VALUE wt.SEQUENCE_NUMBER,
                            'task_status' VALUE wt.TASK_STATUS,
                            'assigned_to' VALUE wt.ASSIGNED_TO,
                            'assignee_name' VALUE (SELECT FULL_NAME FROM USERS WHERE USER_ID = wt.ASSIGNED_TO),
                            'due_date' VALUE TO_CHAR(wt.DUE_DATE, 'YYYY-MM-DD'),
                            'creation_date' VALUE TO_CHAR(wt.CREATION_DATE, 'YYYY-MM-DD HH24:MI:SS'),
                            'completion_date' VALUE TO_CHAR(wt.COMPLETION_DATE, 'YYYY-MM-DD HH24:MI:SS')
                        )
                        ORDER BY wt.SEQUENCE_NUMBER
                    )
                    FROM WORKFLOW_TASKS wt
                    WHERE wt.WORKFLOW_ID = w.WORKFLOW_ID
                ) AS TASKS,
                (
                    SELECT JSON_ARRAYAGG(
                        JSON_OBJECT(
                            'history_id' VALUE wh.HISTORY_ID,
                            'task_id' VALUE wh.TASK_ID,
                            'action_type' VALUE wh.ACTION_TYPE,
                            'action_by' VALUE wh.ACTION_BY,
                            'action_by_name' VALUE (SELECT FULL_NAME FROM USERS WHERE USER_ID = wh.ACTION_BY),
                            'action_date' VALUE TO_CHAR(wh.ACTION_DATE, 'YYYY-MM-DD HH24:MI:SS'),
                            'comments' VALUE wh.COMMENTS
                        )
                        ORDER BY wh.ACTION_DATE DESC
                    )
                    FROM WORKFLOW_HISTORY wh
                    WHERE wh.WORKFLOW_ID = w.WORKFLOW_ID
                ) AS HISTORY
            FROM 
                WORKFLOWS w
            JOIN 
                USERS creator ON w.CREATED_BY = creator.USER_ID
            LEFT JOIN 
                USERS updater ON w.LAST_UPDATE_BY = updater.USER_ID
            WHERE 
                w.WORKFLOW_ID = p_workflow_id;
        
        RETURN v_cursor;
    END GET_WORKFLOW_DETAILS;
    
    -- إنشاء سير عمل لطلب تمويل جديد
    PROCEDURE CREATE_FINANCING_REQUEST_WORKFLOW(
        p_request_id IN NUMBER,
        p_created_by IN NUMBER,
        p_workflow_id OUT NUMBER
    ) IS
        v_product_id NUMBER;
        v_financing_amount NUMBER;
        v_customer_id NUMBER;
        v_customer_segment VARCHAR2(30);
        v_approval_user_id NUMBER;
        v_compliance_user_id NUMBER;
        v_finance_officer_id NUMBER;
        v_due_date DATE;
        p_task_id NUMBER;
    BEGIN
        -- الحصول على معلومات طلب التمويل
        SELECT PRODUCT_ID, REQUESTED_AMOUNT, CUSTOMER_ID
        INTO v_product_id, v_financing_amount, v_customer_id
        FROM FINANCING_REQUESTS
        WHERE REQUEST_ID = p_request_id;
        
        -- الحصول على شريحة العميل
        SELECT CUSTOMER_TYPE
        INTO v_customer_segment
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = v_customer_id;
        
        -- تحديد المستخدمين المسؤولين عن المهام بناءً على المبلغ وشريحة العميل
        -- هذه مجرد أمثلة، يمكن تعديلها حسب قواعد العمل الفعلية
        IF v_financing_amount > 500000 OR v_customer_segment = 'VIP' THEN
            -- للمبالغ الكبيرة أو العملاء المهمين، يتم تعيين مدير أول
            SELECT USER_ID INTO v_approval_user_id
            FROM USERS
            WHERE USER_ROLE = 'SENIOR_MANAGER'
            AND USER_STATUS = 'ACTIVE'
            AND ROWNUM = 1;
        ELSIF v_financing_amount > 100000 THEN
            -- للمبالغ المتوسطة، يتم تعيين مدير
            SELECT USER_ID INTO v_approval_user_id
            FROM USERS
            WHERE USER_ROLE = 'MANAGER'
            AND USER_STATUS = 'ACTIVE'
            AND ROWNUM = 1;
        ELSE
            -- للمبالغ الصغيرة، يتم تعيين مسؤول تمويل
            SELECT USER_ID INTO v_approval_user_id
            FROM USERS
            WHERE USER_ROLE = 'FINANCE_OFFICER'
            AND USER_STATUS = 'ACTIVE'
            AND ROWNUM = 1;
        END IF;
        
        -- تعيين مسؤول الامتثال
        SELECT USER_ID INTO v_compliance_user_id
        FROM USERS
        WHERE USER_ROLE = 'COMPLIANCE_OFFICER'
        AND USER_STATUS = 'ACTIVE'
        AND ROWNUM = 1;
        
        -- تعيين مسؤول التمويل
        SELECT USER_ID INTO v_finance_officer_id
        FROM USERS
        WHERE USER_ROLE = 'FINANCE_OFFICER'
        AND USER_STATUS = 'ACTIVE'
        AND ROWNUM = 1;
        
        -- تحديد تاريخ الاستحقاق (3 أيام عمل من اليوم)
        v_due_date := TRUNC(SYSDATE) + 3;
        
        -- إنشاء سير العمل
        CREATE_WORKFLOW(
            p_workflow_type => 'FINANCING_REQUEST',
            p_reference_type => 'REQUEST',
            p_reference_id => p_request_id,
            p_priority => CASE 
                            WHEN v_customer_segment = 'VIP' THEN 'HIGH'
                            WHEN v_customer_segment = 'PREMIUM' THEN 'MEDIUM'
                            ELSE 'NORMAL'
                          END,
            p_created_by => p_created_by,
            p_workflow_id => p_workflow_id
        );
        
        -- إضافة مهمة مراجعة الطلب
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_REVIEW,
            p_task_name => 'مراجعة طلب التمويل',
            p_task_description => 'مراجعة بيانات طلب التمويل والتحقق من اكتمال المستندات',
            p_assigned_to => v_finance_officer_id,
            p_due_date => v_due_date,
            p_sequence_number => 1,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة التحقق من الامتثال
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_REVIEW,
            p_task_name => 'التحقق من الامتثال',
            p_task_description => 'التحقق من امتثال العميل للوائح مكافحة غسل الأموال وتمويل الإرهاب',
            p_assigned_to => v_compliance_user_id,
            p_due_date => v_due_date + 1,
            p_sequence_number => 2,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة الموافقة النهائية
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_APPROVAL,
            p_task_name => 'الموافقة النهائية على طلب التمويل',
            p_task_description => 'مراجعة واعتماد طلب التمويل بشكل نهائي',
            p_assigned_to => v_approval_user_id,
            p_due_date => v_due_date + 2,
            p_sequence_number => 3,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة إخطار العميل
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_NOTIFICATION,
            p_task_name => 'إخطار العميل بنتيجة الطلب',
            p_task_description => 'إبلاغ العميل بنتيجة طلب التمويل وإرسال العقد للتوقيع في حالة الموافقة',
            p_assigned_to => v_finance_officer_id,
            p_due_date => v_due_date + 3,
            p_sequence_number => 4,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- تحديث حالة طلب التمويل
        UPDATE FINANCING_REQUESTS
        SET REQUEST_STATUS = 'IN_PROGRESS',
            WORKFLOW_ID = p_workflow_id,
            UPDATED_BY = p_created_by,
            UPDATED_DATE = SYSTIMESTAMP
        WHERE REQUEST_ID = p_request_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END CREATE_FINANCING_REQUEST_WORKFLOW;
    
    -- إنشاء سير عمل لإعادة جدولة التمويل
    PROCEDURE CREATE_RESCHEDULE_WORKFLOW(
        p_financing_id IN NUMBER,
        p_reschedule_reason IN VARCHAR2,
        p_created_by IN NUMBER,
        p_workflow_id OUT NUMBER
    ) IS
        v_customer_id NUMBER;
        v_customer_segment VARCHAR2(30);
        v_financing_amount NUMBER;
        v_remaining_amount NUMBER;
        v_approval_user_id NUMBER;
        v_finance_officer_id NUMBER;
        v_due_date DATE;
        p_task_id NUMBER;
    BEGIN
        -- الحصول على معلومات التمويل
        SELECT CUSTOMER_ID, FINANCING_AMOUNT, REMAINING_AMOUNT
        INTO v_customer_id, v_financing_amount, v_remaining_amount
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        -- الحصول على شريحة العميل
        SELECT CUSTOMER_TYPE
        INTO v_customer_segment
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = v_customer_id;
        
        -- تحديد المستخدمين المسؤولين عن المهام بناءً على المبلغ المتبقي وشريحة العميل
        IF v_remaining_amount > 300000 OR v_customer_segment = 'VIP' THEN
            -- للمبالغ الكبيرة أو العملاء المهمين، يتم تعيين مدير أول
            SELECT USER_ID INTO v_approval_user_id
            FROM USERS
            WHERE USER_ROLE = 'SENIOR_MANAGER'
            AND USER_STATUS = 'ACTIVE'
            AND ROWNUM = 1;
        ELSE
            -- للمبالغ الأقل، يتم تعيين مدير
            SELECT USER_ID INTO v_approval_user_id
            FROM USERS
            WHERE USER_ROLE = 'MANAGER'
            AND USER_STATUS = 'ACTIVE'
            AND ROWNUM = 1;
        END IF;
        
        -- تعيين مسؤول التمويل
        SELECT USER_ID INTO v_finance_officer_id
        FROM USERS
        WHERE USER_ROLE = 'FINANCE_OFFICER'
        AND USER_STATUS = 'ACTIVE'
        AND ROWNUM = 1;
        
        -- تحديد تاريخ الاستحقاق (2 أيام عمل من اليوم)
        v_due_date := TRUNC(SYSDATE) + 2;
        
        -- إنشاء سير العمل
        CREATE_WORKFLOW(
            p_workflow_type => 'RESCHEDULE',
            p_reference_type => 'FINANCING',
            p_reference_id => p_financing_id,
            p_priority => CASE 
                            WHEN v_customer_segment = 'VIP' THEN 'HIGH'
                            WHEN v_customer_segment = 'PREMIUM' THEN 'MEDIUM'
                            ELSE 'NORMAL'
                          END,
            p_created_by => p_created_by,
            p_workflow_id => p_workflow_id
        );
        
        -- إضافة مهمة مراجعة طلب إعادة الجدولة
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_REVIEW,
            p_task_name => 'مراجعة طلب إعادة الجدولة',
            p_task_description => 'مراجعة طلب إعادة جدولة التمويل وتقييم الأسباب: ' || p_reschedule_reason,
            p_assigned_to => v_finance_officer_id,
            p_due_date => v_due_date,
            p_sequence_number => 1,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة الموافقة على إعادة الجدولة
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_APPROVAL,
            p_task_name => 'الموافقة على إعادة الجدولة',
            p_task_description => 'مراجعة واعتماد طلب إعادة جدولة التمويل',
            p_assigned_to => v_approval_user_id,
            p_due_date => v_due_date + 1,
            p_sequence_number => 2,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة تنفيذ إعادة الجدولة
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_DOCUMENT,
            p_task_name => 'تنفيذ إعادة الجدولة',
            p_task_description => 'إعداد جدول الأقساط الجديد وتوثيق اتفاقية إعادة الجدولة',
            p_assigned_to => v_finance_officer_id,
            p_due_date => v_due_date + 2,
            p_sequence_number => 3,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة إخطار العميل
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_NOTIFICATION,
            p_task_name => 'إخطار العميل بنتيجة طلب إعادة الجدولة',
            p_task_description => 'إبلاغ العميل بنتيجة طلب إعادة الجدولة وإرسال جدول الأقساط الجديد',
            p_assigned_to => v_finance_officer_id,
            p_due_date => v_due_date + 3,
            p_sequence_number => 4,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END CREATE_RESCHEDULE_WORKFLOW;
    
    -- إنشاء سير عمل للتسوية المبكرة
    PROCEDURE CREATE_EARLY_SETTLEMENT_WORKFLOW(
        p_financing_id IN NUMBER,
        p_settlement_reason IN VARCHAR2,
        p_created_by IN NUMBER,
        p_workflow_id OUT NUMBER
    ) IS
        v_customer_id NUMBER;
        v_customer_segment VARCHAR2(30);
        v_remaining_amount NUMBER;
        v_approval_user_id NUMBER;
        v_finance_officer_id NUMBER;
        v_due_date DATE;p_task_id NUMBER;
    BEGIN
        -- الحصول على معلومات التمويل
        SELECT CUSTOMER_ID, REMAINING_AMOUNT
        INTO v_customer_id, v_remaining_amount
        FROM FINANCING_CONTRACTS
        WHERE FINANCING_ID = p_financing_id;
        
        -- الحصول على شريحة العميل
        SELECT CUSTOMER_TYPE
        INTO v_customer_segment
        FROM CUSTOMERS
        WHERE CUSTOMER_ID = v_customer_id;
        
        -- تحديد المستخدمين المسؤولين عن المهام بناءً على المبلغ المتبقي وشريحة العميل
        IF v_remaining_amount > 200000 OR v_customer_segment = 'VIP' THEN
            -- للمبالغ الكبيرة أو العملاء المهمين، يتم تعيين مدير
            SELECT USER_ID INTO v_approval_user_id
            FROM USERS
            WHERE USER_ROLE = 'MANAGER'
            AND USER_STATUS = 'ACTIVE'
            AND ROWNUM = 1;
        ELSE
            -- للمبالغ الأقل، يتم تعيين مسؤول تمويل أول
            SELECT USER_ID INTO v_approval_user_id
            FROM USERS
            WHERE USER_ROLE = 'SENIOR_FINANCE_OFFICER'
            AND USER_STATUS = 'ACTIVE'
            AND ROWNUM = 1;
        END IF;
        
        -- تعيين مسؤول التمويل
        SELECT USER_ID INTO v_finance_officer_id
        FROM USERS
        WHERE USER_ROLE = 'FINANCE_OFFICER'
        AND USER_STATUS = 'ACTIVE'
        AND ROWNUM = 1;
        

        -- تحديد تاريخ الاستحقاق (1 يوم عمل من اليوم)
        v_due_date := TRUNC(SYSDATE) + 1;
                -- إنشاء سير العمل
        CREATE_WORKFLOW(
            p_workflow_type => 'EARLY_SETTLEMENT',
            p_reference_type => 'FINANCING',
            p_reference_id => p_financing_id,
            p_priority => CASE 
                            WHEN v_customer_segment = 'VIP' THEN 'HIGH'
                            WHEN v_customer_segment = 'PREMIUM' THEN 'MEDIUM'
                            ELSE 'NORMAL'
                          END,
            p_created_by => p_created_by,
            p_workflow_id => p_workflow_id
        );
        
        -- إضافة مهمة حساب مبلغ التسوية
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_REVIEW,
            p_task_name => 'حساب مبلغ التسوية المبكرة',
            p_task_description => 'حساب المبلغ المطلوب للتسوية المبكرة مع تطبيق الخصومات المناسبة',
            p_assigned_to => v_finance_officer_id,
            p_due_date => v_due_date,
            p_sequence_number => 1,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة الموافقة على التسوية المبكرة
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_APPROVAL,
            p_task_name => 'الموافقة على التسوية المبكرة',
            p_task_description => 'مراجعة واعتماد طلب التسوية المبكرة والخصومات المقترحة',
            p_assigned_to => v_approval_user_id,
            p_due_date => v_due_date + 1,
            p_sequence_number => 2,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة إخطار العميل
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_NOTIFICATION,
            p_task_name => 'إخطار العميل بمبلغ التسوية',
            p_task_description => 'إبلاغ العميل بمبلغ التسوية المبكرة وتفاصيل الدفع',
            p_assigned_to => v_finance_officer_id,
            p_due_date => v_due_date + 2,
            p_sequence_number => 3,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
        
        -- إضافة مهمة تنفيذ التسوية
        ADD_WORKFLOW_TASK(
            p_workflow_id => p_workflow_id,
            p_task_type => TASK_TYPE_DOCUMENT,
            p_task_name => 'تنفيذ التسوية المبكرة',
            p_task_description => 'تسجيل الدفعة النهائية وإغلاق التمويل وإصدار مخالصة للعميل',
            p_assigned_to => v_finance_officer_id,
            p_due_date => v_due_date + 3,
            p_sequence_number => 4,
            p_created_by => p_created_by,
            p_task_id => p_task_id
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END CREATE_EARLY_SETTLEMENT_WORKFLOW;
    
    -- التحقق من اكتمال جميع المهام في سير العمل
    FUNCTION ARE_ALL_TASKS_COMPLETED(
        p_workflow_id IN NUMBER
    ) RETURN BOOLEAN IS
        v_total_tasks NUMBER;
        v_completed_tasks NUMBER;
    BEGIN
        -- حساب إجمالي عدد المهام
        SELECT COUNT(*)
        INTO v_total_tasks
        FROM WORKFLOW_TASKS
        WHERE WORKFLOW_ID = p_workflow_id;
        
        -- حساب عدد المهام المكتملة
        SELECT COUNT(*)
        INTO v_completed_tasks
        FROM WORKFLOW_TASKS
        WHERE WORKFLOW_ID = p_workflow_id
        AND TASK_STATUS = TASK_STATUS_COMPLETED;
        
        -- التحقق مما إذا كانت جميع المهام مكتملة
        RETURN (v_total_tasks = v_completed_tasks AND v_total_tasks > 0);
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END ARE_ALL_TASKS_COMPLETED;
    
    -- الحصول على المهمة التالية في سير العمل
    FUNCTION GET_NEXT_TASK(
        p_workflow_id IN NUMBER,
        p_current_task_id IN NUMBER
    ) RETURN NUMBER IS
        v_current_sequence NUMBER;
        v_next_task_id NUMBER;
    BEGIN
        -- الحصول على رقم تسلسل المهمة الحالية
        SELECT SEQUENCE_NUMBER
        INTO v_current_sequence
        FROM WORKFLOW_TASKS
        WHERE TASK_ID = p_current_task_id
        AND WORKFLOW_ID = p_workflow_id;
        
        -- البحث عن المهمة التالية في التسلسل
        SELECT TASK_ID
        INTO v_next_task_id
        FROM WORKFLOW_TASKS
        WHERE WORKFLOW_ID = p_workflow_id
        AND SEQUENCE_NUMBER > v_current_sequence
        AND TASK_STATUS = TASK_STATUS_PENDING
        ORDER BY SEQUENCE_NUMBER
        FETCH FIRST 1 ROW ONLY;
        
        RETURN v_next_task_id;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN OTHERS THEN
            RETURN NULL;
    END GET_NEXT_TASK;
END PKG_WORKFLOW;
/


CREATE OR REPLACE PACKAGE BODY system_management AS
    -- تسجيل حدث نظام
    PROCEDURE log_system_event(
        p_event_type IN VARCHAR2,
        p_event_description IN VARCHAR2,
        p_source IN VARCHAR2,
        p_user_id IN NUMBER DEFAULT NULL,
        p_reference_id IN NUMBER DEFAULT NULL,
        p_reference_type IN VARCHAR2 DEFAULT NULL
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO system_events (
            event_type,
            event_description,
            source,
            user_id,
            reference_id,
            reference_type,
            event_time
        ) VALUES (
            p_event_type,
            p_event_description,
            p_source,
            p_user_id,
            p_reference_id,
            p_reference_type,
            SYSTIMESTAMP
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- في حالة الخطأ، نحاول تسجيل الخطأ في ملف أو مكان آخر
            -- يمكن استخدام DBMS_OUTPUT أو UTL_FILE للتسجيل في ملف
            NULL;
    END log_system_event;
    
    -- تسجيل خطأ نظام
    PROCEDURE log_system_error(
        p_error_code IN VARCHAR2,
        p_error_message IN VARCHAR2,
        p_source IN VARCHAR2,
        p_stack_trace IN VARCHAR2 DEFAULT NULL,
        p_user_id IN NUMBER DEFAULT NULL,
        p_reference_id IN NUMBER DEFAULT NULL,
        p_reference_type IN VARCHAR2 DEFAULT NULL
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO system_errors (
            error_code,
            error_message,
            source,
            stack_trace,
            user_id,
            reference_id,
            reference_type,
            error_time
        ) VALUES (
            p_error_code,
            p_error_message,
            p_source,
            p_stack_trace,
            p_user_id,
            p_reference_id,
            p_reference_type,
            SYSTIMESTAMP
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- في حالة الخطأ، نحاول تسجيل الخطأ في ملف أو مكان آخر
            NULL;
    END log_system_error;
    
    -- تسجيل نشاط مستخدم
    PROCEDURE log_user_activity(
        p_user_id IN NUMBER,
        p_activity_type IN VARCHAR2,
        p_activity_description IN VARCHAR2,
        p_ip_address IN VARCHAR2 DEFAULT NULL,
        p_reference_id IN NUMBER DEFAULT NULL,
        p_reference_type IN VARCHAR2 DEFAULT NULL
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO user_activities (
            user_id,
            activity_type,
            activity_description,
            ip_address,
            reference_id,
            reference_type,
            activity_time
        ) VALUES (
            p_user_id,
            p_activity_type,
            p_activity_description,
            p_ip_address,
            p_reference_id,
            p_reference_type,
            SYSTIMESTAMP
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- في حالة الخطأ، نسجل الخطأ في سجل أخطاء النظام
            log_system_error(
                SQLCODE,
                SQLERRM,
                'system_management.log_user_activity',
                NULL,
                p_user_id,
                p_reference_id,
                p_reference_type
            );
    END log_user_activity;
    
    -- تسجيل دخول مستخدم
    PROCEDURE log_user_login(
        p_user_id IN NUMBER,
        p_ip_address IN VARCHAR2,
        p_user_agent IN VARCHAR2,
        p_status IN VARCHAR2,
        p_failure_reason IN VARCHAR2 DEFAULT NULL
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO login_history (
            user_id,
            ip_address,
            user_agent,
            LOGIN_DATE,
            LOGIN_STATUS,
            failure_reason
        ) VALUES (
            p_user_id,
            p_ip_address,
            p_user_agent,
            SYSTIMESTAMP,
            p_status,
            p_failure_reason
        );
        
        -- إذا كان تسجيل الدخول ناجحاً، نحدث آخر وقت تسجيل دخول للمستخدم
        IF p_status = 'SUCCESS' THEN
            UPDATE users
            SET LAST_LOGIN_DATE = SYSTIMESTAMP
            WHERE user_id = p_user_id;
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            -- في حالة الخطأ، نسجل الخطأ في سجل أخطاء النظام
            log_system_error(
                SQLCODE,
                SQLERRM,
                'system_management.log_user_login',
                NULL,
                p_user_id,
                NULL,
                NULL
            );
    END log_user_login;
    /*
    -- الحصول على إحصائيات النظام
    PROCEDURE get_system_statistics(
        p_result OUT SYS_REFCURSOR
    ) IS
    BEGIN
        OPEN p_result FOR
            WITH stats AS (
                -- إحصائيات العملاء
                SELECT 'TOTAL_CUSTOMERS' AS stat_name, COUNT(*) AS stat_value
                FROM customers
                UNION ALL
                SELECT 'ACTIVE_CUSTOMERS', COUNT(*)
                FROM customers
                WHERE CUSTOMER_STATUS = 'ACTIVE'
                UNION ALL
                SELECT 'INDIVIDUAL_CUSTOMERS', COUNT(*)
                FROM customers
                WHERE customer_type = 'INDIVIDUAL'
                UNION ALL
                SELECT 'CORPORATE_CUSTOMERS', COUNT(*)
                FROM customers
                WHERE customer_type = 'CORPORATE'
                
                -- إحصائيات طلبات التمويل
                UNION ALL
                SELECT 'TOTAL_APPLICATIONS', COUNT(*)
                FROM finance_applications
                UNION ALL
                SELECT 'PENDING_APPLICATIONS', COUNT(*)
                FROM finance_applications
                WHERE status IN ('DRAFT', 'SUBMITTED', 'UNDER_REVIEW')
                UNION ALL
                SELECT 'APPROVED_APPLICATIONS', COUNT(*)
                FROM finance_applications
                WHERE status = 'APPROVED'
                UNION ALL
                SELECT 'REJECTED_APPLICATIONS', COUNT(*)
                FROM finance_applications
                WHERE status = 'REJECTED'
                
                -- إحصائيات الحسابات
                UNION ALL
                SELECT 'TOTAL_ACCOUNTS', COUNT(*)
                FROM finance_accounts
                UNION ALL
                SELECT 'ACTIVE_ACCOUNTS', COUNT(*)
                FROM finance_accounts
                WHERE status = 'ACTIVE'
                UNION ALL
                SELECT 'CLOSED_ACCOUNTS', COUNT(*)
                FROM finance_accounts
                WHERE status = 'CLOSED'
                UNION ALL
                SELECT 'DELINQUENT_ACCOUNTS', COUNT(*)
                FROM finance_accounts
                WHERE status = 'DELINQUENT'
                
                -- إحصائيات الأقساط
                UNION ALL
                SELECT 'TOTAL_INSTALLMENTS', COUNT(*)
                FROM installment_schedule
                UNION ALL
                SELECT 'PAID_INSTALLMENTS', COUNT(*)
                FROM installment_schedule
                WHERE status = 'PAID'
                UNION ALL
                SELECT 'PENDING_INSTALLMENTS', COUNT(*)
                FROM installment_schedule
                WHERE status = 'PENDING'
                UNION ALL
                SELECT 'OVERDUE_INSTALLMENTS', COUNT(*)
                FROM installment_schedule
                WHERE status = 'OVERDUE'
                
                -- إحصائيات المدفوعات
                UNION ALL
                SELECT 'TOTAL_PAYMENTS', COUNT(*)
                FROM payments
                UNION ALL
                SELECT 'TOTAL_PAYMENT_AMOUNT', TO_CHAR(NVL(SUM(amount), 0))
                FROM payments
                UNION ALL
                SELECT 'PAYMENTS_TODAY', COUNT(*)
                FROM payments
                WHERE TRUNC(payment_date) = TRUNC(SYSDATE)
                UNION ALL
                SELECT 'PAYMENT_AMOUNT_TODAY', TO_CHAR(NVL(SUM(amount), 0))
                FROM payments
                WHERE TRUNC(payment_date) = TRUNC(SYSDATE)
                
                -- إحصائيات المستخدمين
                UNION ALL
                SELECT 'TOTAL_USERS', COUNT(*)
                FROM users
                UNION ALL
                SELECT 'ACTIVE_USERS', COUNT(*)
                FROM users
                WHERE is_active = 1
                UNION ALL
                SELECT 'ADMIN_USERS', COUNT(*)
                FROM users u
                JOIN roles r ON u.role_id = r.role_id
                WHERE r.role_name = 'ADMIN'
                
                -- إحصائيات المنتجات
                UNION ALL
                SELECT 'TOTAL_PRODUCTS', COUNT(*)
                FROM products
                UNION ALL
                SELECT 'ACTIVE_PRODUCTS', COUNT(*)
                FROM products
                WHERE is_active = 1
                
                -- إحصائيات أنشطة التحصيل
                UNION ALL
                SELECT 'TOTAL_COLLECTION_ACTIVITIES', COUNT(*)
                FROM collection_activities
                UNION ALL
                SELECT 'PENDING_COLLECTION_ACTIVITIES', COUNT(*)
                FROM collection_activities
                WHERE status = 'PENDING'
                UNION ALL
                SELECT 'COMPLETED_COLLECTION_ACTIVITIES', COUNT(*)
                FROM collection_activities
                WHERE status = 'COMPLETED'
                
                -- إحصائيات المهام
                UNION ALL
                SELECT 'TOTAL_TASKS', COUNT(*)
                FROM tasks
                UNION ALL
                SELECT 'PENDING_TASKS', COUNT(*)
                FROM tasks
                WHERE status = 'PENDING'
                UNION ALL
                SELECT 'COMPLETED_TASKS', COUNT(*)
                FROM tasks
                WHERE status = 'COMPLETED'
                UNION ALL
                SELECT 'OVERDUE_TASKS', COUNT(*)
                FROM tasks
                WHERE status <> 'COMPLETED'
                AND due_date < TRUNC(SYSDATE)
                
                -- إحصائيات المستندات
                UNION ALL
                SELECT 'TOTAL_DOCUMENTS', COUNT(*)
                FROM documents
                
                -- إحصائيات النظام
                UNION ALL
                SELECT 'SYSTEM_ERRORS_TODAY', COUNT(*)
                FROM system_errors
                WHERE TRUNC(error_time) = TRUNC(SYSDATE)
                UNION ALL
                SELECT 'USER_LOGINS_TODAY', COUNT(*)
                FROM user_login_history
                WHERE TRUNC(login_time) = TRUNC(SYSDATE)
                AND status = 'SUCCESS'
            )
            SELECT 
                stat_name,
                stat_value,
                CASE 
                    WHEN stat_name LIKE '%AMOUNT%' THEN 'CURRENCY'
                    WHEN stat_name LIKE '%PERCENTAGE%' THEN 'PERCENTAGE'
                    ELSE 'NUMBER'
                END AS value_type
            FROM stats
            ORDER BY stat_name;
    EXCEPTION
        WHEN OTHERS THEN
            log_system_error(
                SQLCODE,
                SQLERRM,
                'system_management.get_system_statistics',
                NULL,
                NULL,
                NULL,
                NULL
            );
            RAISE;
    END get_system_statistics;
    */
    -- تنظيف السجلات القديمة
    PROCEDURE cleanup_old_logs(
        p_days_to_keep IN NUMBER DEFAULT 90
    ) IS
        v_cutoff_date DATE := TRUNC(SYSDATE) - p_days_to_keep;
        v_deleted_count NUMBER;
    BEGIN
        -- تنظيف سجلات أحداث النظام
        DELETE FROM system_events
        WHERE event_time < v_cutoff_date;
        v_deleted_count := SQL%ROWCOUNT;
        
        log_system_event(
            'MAINTENANCE',
            'تم حذف ' || v_deleted_count || ' من سجلات أحداث النظام القديمة',
            'system_management.cleanup_old_logs'
        );
        
        -- تنظيف سجلات أخطاء النظام
        DELETE FROM system_errors
        WHERE error_time < v_cutoff_date;
        v_deleted_count := SQL%ROWCOUNT;
        
        log_system_event(
            'MAINTENANCE',
            'تم حذف ' || v_deleted_count || ' من سجلات أخطاء النظام القديمة',
            'system_management.cleanup_old_logs'
        );
        
        -- تنظيف سجلات أنشطة المستخدمين
        DELETE FROM user_activities
        WHERE activity_time < v_cutoff_date;
        v_deleted_count := SQL%ROWCOUNT;
        
        log_system_event(
            'MAINTENANCE',
            'تم حذف ' || v_deleted_count || ' من سجلات أنشطة المستخدمين القديمة',
            'system_management.cleanup_old_logs'
        );
        
        -- تنظيف سجلات تسجيل الدخول
        DELETE FROM login_history
        WHERE login_DATE < v_cutoff_date;
        v_deleted_count := SQL%ROWCOUNT;
        
        log_system_event(
            'MAINTENANCE',
            'تم حذف ' || v_deleted_count || ' من سجلات تسجيل الدخول القديمة',
            'system_management.cleanup_old_logs'
        );
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            log_system_error(
                SQLCODE,
                SQLERRM,
                'system_management.cleanup_old_logs',
                NULL,
                NULL,
                NULL,
                NULL
            );
    END cleanup_old_logs;
    
    -- تحديث إعدادات النظام
    PROCEDURE update_system_setting(
        p_setting_name IN VARCHAR2,
        p_setting_value IN VARCHAR2,
        p_updated_by IN VARCHAR2
    ) IS
        v_count NUMBER;
    BEGIN
        -- التحقق من وجود الإعداد
        SELECT COUNT(*) INTO v_count
        FROM system_settings
        WHERE SETTING_KEY = p_setting_name;
        
        IF v_count > 0 THEN
            -- تحديث الإعداد الموجود
            UPDATE system_settings
            SET setting_value = p_setting_value,
                LAST_UPDATED_BY = p_updated_by,
                LAST_UPDATE_DATE = SYSTIMESTAMP
            WHERE SETTING_KEY = p_setting_name;
        ELSE
            -- إضافة إعداد جديد
            INSERT INTO system_settings (
                SETTING_KEY,
                setting_value,
                CREATED_BY,
                CREATED_DATE,
                LAST_UPDATED_BY,
                LAST_UPDATE_DATE
            ) VALUES (
                p_setting_name,
                p_setting_value,
                p_updated_by,
                SYSTIMESTAMP,
                p_updated_by,
                SYSTIMESTAMP
            );
        END IF;
        
        COMMIT;
        
        -- تسجيل الحدث
        log_system_event(
            'SETTINGS',
            'تم تحديث إعداد النظام: ' || p_setting_name || ' = ' || p_setting_value,
            'system_management.update_system_setting',
            NULL,
            NULL,
            NULL
        );
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            log_system_error(
                SQLCODE,
                SQLERRM,
                'system_management.update_system_setting',
                NULL,
                NULL,
                NULL,
                NULL
            );
            RAISE;
    END update_system_setting;
    
    -- الحصول على قيمة إعداد النظام
    FUNCTION get_system_setting(
        p_setting_name IN VARCHAR2,
        p_default_value IN VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        v_setting_value VARCHAR2(4000);
    BEGIN
        SELECT setting_value INTO v_setting_value
        FROM system_settings
        WHERE SETTING_KEY = p_setting_name;
        
        RETURN v_setting_value;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN p_default_value;
        WHEN OTHERS THEN
            log_system_error(
                SQLCODE,
                SQLERRM,
                'system_management.get_system_setting',
                NULL,
                NULL,
                NULL,
                NULL
            );
            RETURN p_default_value;
    END get_system_setting;
END system_management;
/
